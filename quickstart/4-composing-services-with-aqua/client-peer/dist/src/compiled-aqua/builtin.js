"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerDist = exports.registerScript = exports.registerKademlia = exports.registerOp = exports.registerPeer = exports.registerSrv = void 0;
/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/.
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.3.0-226
 *
 */
var fluence_1 = require("@fluencelabs/fluence");
var v1_1 = require("@fluencelabs/fluence/dist/internal/compilerSupport/v1");
function registerSrv() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var peer;
    var serviceId;
    var service;
    if (fluence_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
    }
    else {
        peer = fluence_1.Fluence.getPeer();
    }
    if (typeof args[0] === 'string') {
        serviceId = args[0];
    }
    else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }
    else {
        serviceId = "srv";
    }
    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(fluence_1.FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    }
    else if (typeof args[1] === 'object') {
        service = args[1];
    }
    else {
        service = args[2];
    }
    peer.internals.callServiceHandler.use(function (req, resp, next) {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }
        if (req.fnName === 'add_alias') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    alias: req.tetraplets[0], service_id: req.tetraplets[1]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            service.add_alias(req.args[0], req.args[1], callParams);
            resp.result = {};
        }
        if (req.fnName === 'create') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    blueprint_id: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.create(req.args[0], callParams);
        }
        if (req.fnName === 'get_interface') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    service_id: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.get_interface(req.args[0], callParams);
        }
        if (req.fnName === 'list') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {} });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.list(callParams);
        }
        if (req.fnName === 'remove') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    service_id: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            service.remove(req.args[0], callParams);
            resp.result = {};
        }
        if (req.fnName === 'resolve_alias') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    alias: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.resolve_alias(req.args[0], callParams);
        }
        next();
    });
}
exports.registerSrv = registerSrv;
function registerPeer() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var peer;
    var serviceId;
    var service;
    if (fluence_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
    }
    else {
        peer = fluence_1.Fluence.getPeer();
    }
    if (typeof args[0] === 'string') {
        serviceId = args[0];
    }
    else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }
    else {
        serviceId = "peer";
    }
    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(fluence_1.FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    }
    else if (typeof args[1] === 'object') {
        service = args[1];
    }
    else {
        service = args[2];
    }
    peer.internals.callServiceHandler.use(function (req, resp, next) {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }
        if (req.fnName === 'connect') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    id: req.tetraplets[0], multiaddrs: req.tetraplets[1]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.connect(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], callParams);
        }
        if (req.fnName === 'get_contact') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    peer: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.get_contact(req.args[0], callParams);
        }
        if (req.fnName === 'identify') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {} });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.identify(callParams);
        }
        if (req.fnName === 'is_connected') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    peer: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.is_connected(req.args[0], callParams);
        }
        if (req.fnName === 'timestamp_ms') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {} });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.timestamp_ms(callParams);
        }
        if (req.fnName === 'timestamp_sec') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {} });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.timestamp_sec(callParams);
        }
        next();
    });
}
exports.registerPeer = registerPeer;
function registerOp() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var peer;
    var serviceId;
    var service;
    if (fluence_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
    }
    else {
        peer = fluence_1.Fluence.getPeer();
    }
    if (typeof args[0] === 'string') {
        serviceId = args[0];
    }
    else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }
    else {
        serviceId = "op";
    }
    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(fluence_1.FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    }
    else if (typeof args[1] === 'object') {
        service = args[1];
    }
    else {
        service = args[2];
    }
    peer.internals.callServiceHandler.use(function (req, resp, next) {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }
        if (req.fnName === 'array') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    a: req.tetraplets[0], b: req.tetraplets[1], c: req.tetraplets[2], d: req.tetraplets[3]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.array(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], callParams);
        }
        if (req.fnName === 'array_length') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    array: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.array_length(req.args[0], callParams);
        }
        if (req.fnName === 'bytes_from_b58') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    b: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.bytes_from_b58(req.args[0], callParams);
        }
        if (req.fnName === 'bytes_to_b58') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    bs: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.bytes_to_b58(req.args[0], callParams);
        }
        if (req.fnName === 'concat') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    a: req.tetraplets[0], b: req.tetraplets[1], c: req.tetraplets[2], d: req.tetraplets[3]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.concat(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], callParams);
        }
        if (req.fnName === 'concat_strings') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    a: req.tetraplets[0], b: req.tetraplets[1]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.concat_strings(req.args[0], req.args[1], callParams);
        }
        if (req.fnName === 'identity') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    s: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            var respResult = service.identity(req.args[0].length === 0 ? null : req.args[0][0], callParams);
            resp.result = respResult === null ? [] : [respResult];
        }
        if (req.fnName === 'noop') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {} });
            resp.retCode = v1_1.ResultCodes.success;
            service.noop(callParams);
            resp.result = {};
        }
        if (req.fnName === 'sha256_string') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    s: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.sha256_string(req.args[0], callParams);
        }
        if (req.fnName === 'string_from_b58') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    b: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.string_from_b58(req.args[0], callParams);
        }
        if (req.fnName === 'string_to_b58') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    s: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.string_to_b58(req.args[0], callParams);
        }
        next();
    });
}
exports.registerOp = registerOp;
function registerKademlia() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var peer;
    var serviceId;
    var service;
    if (fluence_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
    }
    else {
        peer = fluence_1.Fluence.getPeer();
    }
    if (typeof args[0] === 'string') {
        serviceId = args[0];
    }
    else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }
    else {
        serviceId = "kad";
    }
    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(fluence_1.FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    }
    else if (typeof args[1] === 'object') {
        service = args[1];
    }
    else {
        service = args[2];
    }
    peer.internals.callServiceHandler.use(function (req, resp, next) {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }
        if (req.fnName === 'merge') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    target: req.tetraplets[0], left: req.tetraplets[1], right: req.tetraplets[2], count: req.tetraplets[3]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.merge(req.args[0], req.args[1], req.args[2], req.args[3].length === 0 ? null : req.args[3][0], callParams);
        }
        if (req.fnName === 'neighborhood') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    key: req.tetraplets[0], already_hashed: req.tetraplets[1], count: req.tetraplets[2]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.neighborhood(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], callParams);
        }
        next();
    });
}
exports.registerKademlia = registerKademlia;
function registerScript() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var peer;
    var serviceId;
    var service;
    if (fluence_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
    }
    else {
        peer = fluence_1.Fluence.getPeer();
    }
    if (typeof args[0] === 'string') {
        serviceId = args[0];
    }
    else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }
    else {
        serviceId = "script";
    }
    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(fluence_1.FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    }
    else if (typeof args[1] === 'object') {
        service = args[1];
    }
    else {
        service = args[2];
    }
    peer.internals.callServiceHandler.use(function (req, resp, next) {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }
        if (req.fnName === 'add') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    air_script: req.tetraplets[0], interval: req.tetraplets[1]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.add(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], callParams);
        }
        if (req.fnName === 'list') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {} });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.list(callParams);
        }
        if (req.fnName === 'remove') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    script_id: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.remove(req.args[0], callParams);
        }
        next();
    });
}
exports.registerScript = registerScript;
function registerDist() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var peer;
    var serviceId;
    var service;
    if (fluence_1.FluencePeer.isInstance(args[0])) {
        peer = args[0];
    }
    else {
        peer = fluence_1.Fluence.getPeer();
    }
    if (typeof args[0] === 'string') {
        serviceId = args[0];
    }
    else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }
    else {
        serviceId = "dist";
    }
    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(fluence_1.FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    }
    else if (typeof args[1] === 'object') {
        service = args[1];
    }
    else {
        service = args[2];
    }
    peer.internals.callServiceHandler.use(function (req, resp, next) {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }
        if (req.fnName === 'add_blueprint') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    blueprint: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.add_blueprint(req.args[0], callParams);
        }
        if (req.fnName === 'add_module') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    wasm_b56_content: req.tetraplets[0], conf: req.tetraplets[1]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.add_module(req.args[0], req.args[1], callParams);
        }
        if (req.fnName === 'add_module_from_vault') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    path: req.tetraplets[0], config: req.tetraplets[1]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.add_module_from_vault(req.args[0], req.args[1], callParams);
        }
        if (req.fnName === 'default_module_config') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    module_name: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.default_module_config(req.args[0], callParams);
        }
        if (req.fnName === 'get_interface') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    module_id: req.tetraplets[0]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.get_interface(req.args[0], callParams);
        }
        if (req.fnName === 'list_blueprints') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {} });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.list_blueprints(callParams);
        }
        if (req.fnName === 'list_modules') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {} });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.list_modules(callParams);
        }
        if (req.fnName === 'make_blueprint') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    name: req.tetraplets[0], dependencies: req.tetraplets[1]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.make_blueprint(req.args[0], req.args[1], callParams);
        }
        if (req.fnName === 'make_module_config') {
            var callParams = __assign(__assign({}, req.particleContext), { tetraplets: {
                    name: req.tetraplets[0], mem_pages_count: req.tetraplets[1], logger_enabled: req.tetraplets[2], preopened_files: req.tetraplets[3], envs: req.tetraplets[4], mapped_dirs: req.tetraplets[5], mounted_binaries: req.tetraplets[6], logging_mask: req.tetraplets[7]
                } });
            resp.retCode = v1_1.ResultCodes.success;
            resp.result = service.make_module_config(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], req.args[4].length === 0 ? null : req.args[4][0], req.args[5].length === 0 ? null : req.args[5][0], req.args[6].length === 0 ? null : req.args[6][0], req.args[7].length === 0 ? null : req.args[7][0], callParams);
        }
        next();
    });
}
exports.registerDist = registerDist;
// Functions
