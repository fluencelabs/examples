/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/. 
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.3.0-226
 *
 */
import { Fluence, FluencePeer } from '@fluencelabs/fluence';
import {
    ResultCodes,
    RequestFlow,
    RequestFlowBuilder,
    CallParams,
} from '@fluencelabs/fluence/dist/internal/compilerSupport/v1';


// Services

 export interface SrvDef {
     add_alias: (alias: string, service_id: string, callParams: CallParams<'alias' | 'service_id'>) => void;
create: (blueprint_id: string, callParams: CallParams<'blueprint_id'>) => string;
get_interface: (service_id: string, callParams: CallParams<'service_id'>) => {function_signatures:{arguments:string[][];name:string;output_types:string[]}[];record_types:{fields:string[][];id:number;name:string}[]};
list: (callParams: CallParams<null>) => {blueprint_id:string;id:string;owner_id:string}[];
remove: (service_id: string, callParams: CallParams<'service_id'>) => void;
resolve_alias: (alias: string, callParams: CallParams<'alias'>) => string;
 }

 export function registerSrv(service: SrvDef): void;
export function registerSrv(serviceId: string, service: SrvDef): void;
export function registerSrv(peer: FluencePeer, service: SrvDef): void;
export function registerSrv(peer: FluencePeer, serviceId: string, service: SrvDef): void;
 export function registerSrv(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }  
 else {
     serviceId = "srv"
}

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

      peer.internals.callServiceHandler.use((req, resp, next) => {
          if (req.serviceId !== serviceId) {
              next();
              return;
          }
  
          
 if (req.fnName === 'add_alias') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         alias: req.tetraplets[0],service_id: req.tetraplets[1]
     },
 };
 resp.retCode = ResultCodes.success;
 service.add_alias(req.args[0], req.args[1], callParams); resp.result = {}

 }
    


 if (req.fnName === 'create') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         blueprint_id: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.create(req.args[0], callParams)

 }
    


 if (req.fnName === 'get_interface') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         service_id: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.get_interface(req.args[0], callParams)

 }
    


 if (req.fnName === 'list') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.list(callParams)

 }
    


 if (req.fnName === 'remove') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         service_id: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 service.remove(req.args[0], callParams); resp.result = {}

 }
    


 if (req.fnName === 'resolve_alias') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         alias: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.resolve_alias(req.args[0], callParams)

 }
    
  
          next();
      });
 }
      


 export interface PeerDef {
     connect: (id: string, multiaddrs: string[] | null, callParams: CallParams<'id' | 'multiaddrs'>) => boolean;
get_contact: (peer: string, callParams: CallParams<'peer'>) => {addresses:string[];peer_id:string};
identify: (callParams: CallParams<null>) => {external_addresses:string[]};
is_connected: (peer: string, callParams: CallParams<'peer'>) => boolean;
timestamp_ms: (callParams: CallParams<null>) => number;
timestamp_sec: (callParams: CallParams<null>) => number;
 }

 export function registerPeer(service: PeerDef): void;
export function registerPeer(serviceId: string, service: PeerDef): void;
export function registerPeer(peer: FluencePeer, service: PeerDef): void;
export function registerPeer(peer: FluencePeer, serviceId: string, service: PeerDef): void;
 export function registerPeer(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }  
 else {
     serviceId = "peer"
}

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

      peer.internals.callServiceHandler.use((req, resp, next) => {
          if (req.serviceId !== serviceId) {
              next();
              return;
          }
  
          
 if (req.fnName === 'connect') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         id: req.tetraplets[0],multiaddrs: req.tetraplets[1]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.connect(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], callParams)

 }
    


 if (req.fnName === 'get_contact') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         peer: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.get_contact(req.args[0], callParams)

 }
    


 if (req.fnName === 'identify') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.identify(callParams)

 }
    


 if (req.fnName === 'is_connected') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         peer: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.is_connected(req.args[0], callParams)

 }
    


 if (req.fnName === 'timestamp_ms') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.timestamp_ms(callParams)

 }
    


 if (req.fnName === 'timestamp_sec') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.timestamp_sec(callParams)

 }
    
  
          next();
      });
 }
      


 export interface OpDef {
     array: (a: string, b: string | null, c: string | null, d: string | null, callParams: CallParams<'a' | 'b' | 'c' | 'd'>) => string[];
array_length: (array: string[], callParams: CallParams<'array'>) => number;
bytes_from_b58: (b: string, callParams: CallParams<'b'>) => number[];
bytes_to_b58: (bs: number[], callParams: CallParams<'bs'>) => string;
concat: (a: string[], b: string[] | null, c: string[] | null, d: string[] | null, callParams: CallParams<'a' | 'b' | 'c' | 'd'>) => string[];
concat_strings: (a: string, b: string, callParams: CallParams<'a' | 'b'>) => string;
identity: (s: string | null, callParams: CallParams<'s'>) => string | null;
noop: (callParams: CallParams<null>) => void;
sha256_string: (s: string, callParams: CallParams<'s'>) => string;
string_from_b58: (b: string, callParams: CallParams<'b'>) => string;
string_to_b58: (s: string, callParams: CallParams<'s'>) => string;
 }

 export function registerOp(service: OpDef): void;
export function registerOp(serviceId: string, service: OpDef): void;
export function registerOp(peer: FluencePeer, service: OpDef): void;
export function registerOp(peer: FluencePeer, serviceId: string, service: OpDef): void;
 export function registerOp(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }  
 else {
     serviceId = "op"
}

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

      peer.internals.callServiceHandler.use((req, resp, next) => {
          if (req.serviceId !== serviceId) {
              next();
              return;
          }
  
          
 if (req.fnName === 'array') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         a: req.tetraplets[0],b: req.tetraplets[1],c: req.tetraplets[2],d: req.tetraplets[3]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.array(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], callParams)

 }
    


 if (req.fnName === 'array_length') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         array: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.array_length(req.args[0], callParams)

 }
    


 if (req.fnName === 'bytes_from_b58') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         b: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.bytes_from_b58(req.args[0], callParams)

 }
    


 if (req.fnName === 'bytes_to_b58') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         bs: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.bytes_to_b58(req.args[0], callParams)

 }
    


 if (req.fnName === 'concat') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         a: req.tetraplets[0],b: req.tetraplets[1],c: req.tetraplets[2],d: req.tetraplets[3]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.concat(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], callParams)

 }
    


 if (req.fnName === 'concat_strings') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         a: req.tetraplets[0],b: req.tetraplets[1]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.concat_strings(req.args[0], req.args[1], callParams)

 }
    


 if (req.fnName === 'identity') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         s: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 
 var respResult = service.identity(req.args[0].length === 0 ? null : req.args[0][0], callParams);
 resp.result = respResult === null ? [] : [respResult]


 }
    


 if (req.fnName === 'noop') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         
     },
 };
 resp.retCode = ResultCodes.success;
 service.noop(callParams); resp.result = {}

 }
    


 if (req.fnName === 'sha256_string') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         s: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.sha256_string(req.args[0], callParams)

 }
    


 if (req.fnName === 'string_from_b58') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         b: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.string_from_b58(req.args[0], callParams)

 }
    


 if (req.fnName === 'string_to_b58') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         s: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.string_to_b58(req.args[0], callParams)

 }
    
  
          next();
      });
 }
      


 export interface KademliaDef {
     merge: (target: string, left: string[], right: string[], count: number | null, callParams: CallParams<'target' | 'left' | 'right' | 'count'>) => string[];
neighborhood: (key: string, already_hashed: boolean | null, count: number | null, callParams: CallParams<'key' | 'already_hashed' | 'count'>) => string[];
 }

 export function registerKademlia(service: KademliaDef): void;
export function registerKademlia(serviceId: string, service: KademliaDef): void;
export function registerKademlia(peer: FluencePeer, service: KademliaDef): void;
export function registerKademlia(peer: FluencePeer, serviceId: string, service: KademliaDef): void;
 export function registerKademlia(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }  
 else {
     serviceId = "kad"
}

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

      peer.internals.callServiceHandler.use((req, resp, next) => {
          if (req.serviceId !== serviceId) {
              next();
              return;
          }
  
          
 if (req.fnName === 'merge') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         target: req.tetraplets[0],left: req.tetraplets[1],right: req.tetraplets[2],count: req.tetraplets[3]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.merge(req.args[0], req.args[1], req.args[2], req.args[3].length === 0 ? null : req.args[3][0], callParams)

 }
    


 if (req.fnName === 'neighborhood') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         key: req.tetraplets[0],already_hashed: req.tetraplets[1],count: req.tetraplets[2]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.neighborhood(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], callParams)

 }
    
  
          next();
      });
 }
      


 export interface ScriptDef {
     add: (air_script: string, interval: string | null, callParams: CallParams<'air_script' | 'interval'>) => string;
list: (callParams: CallParams<null>) => {failures:number;id:string;interval:string;owner:string;src:string};
remove: (script_id: string, callParams: CallParams<'script_id'>) => boolean;
 }

 export function registerScript(service: ScriptDef): void;
export function registerScript(serviceId: string, service: ScriptDef): void;
export function registerScript(peer: FluencePeer, service: ScriptDef): void;
export function registerScript(peer: FluencePeer, serviceId: string, service: ScriptDef): void;
 export function registerScript(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }  
 else {
     serviceId = "script"
}

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

      peer.internals.callServiceHandler.use((req, resp, next) => {
          if (req.serviceId !== serviceId) {
              next();
              return;
          }
  
          
 if (req.fnName === 'add') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         air_script: req.tetraplets[0],interval: req.tetraplets[1]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.add(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], callParams)

 }
    


 if (req.fnName === 'list') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.list(callParams)

 }
    


 if (req.fnName === 'remove') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         script_id: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.remove(req.args[0], callParams)

 }
    
  
          next();
      });
 }
      


 export interface DistDef {
     add_blueprint: (blueprint: {dependencies:string[];name:string}, callParams: CallParams<'blueprint'>) => string;
add_module: (wasm_b56_content: number[], conf: {name:string}, callParams: CallParams<'wasm_b56_content' | 'conf'>) => string;
add_module_from_vault: (path: string, config: {name:string}, callParams: CallParams<'path' | 'config'>) => string;
default_module_config: (module_name: string, callParams: CallParams<'module_name'>) => {name:string};
get_interface: (module_id: string, callParams: CallParams<'module_id'>) => {function_signatures:{arguments:string[][];name:string;output_types:string[]}[];record_types:{fields:string[][];id:number;name:string}[]};
list_blueprints: (callParams: CallParams<null>) => {dependencies:string[];id:string;name:string}[];
list_modules: (callParams: CallParams<null>) => {config:{name:string};hash:string;name:string}[];
make_blueprint: (name: string, dependencies: string[], callParams: CallParams<'name' | 'dependencies'>) => {dependencies:string[];name:string};
make_module_config: (name: string, mem_pages_count: number | null, logger_enabled: boolean | null, preopened_files: string[] | null, envs: string[][] | null, mapped_dirs: string[][] | null, mounted_binaries: string[][] | null, logging_mask: number | null, callParams: CallParams<'name' | 'mem_pages_count' | 'logger_enabled' | 'preopened_files' | 'envs' | 'mapped_dirs' | 'mounted_binaries' | 'logging_mask'>) => {name:string};
 }

 export function registerDist(service: DistDef): void;
export function registerDist(serviceId: string, service: DistDef): void;
export function registerDist(peer: FluencePeer, service: DistDef): void;
export function registerDist(peer: FluencePeer, serviceId: string, service: DistDef): void;
 export function registerDist(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    }  
 else {
     serviceId = "dist"
}

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

      peer.internals.callServiceHandler.use((req, resp, next) => {
          if (req.serviceId !== serviceId) {
              next();
              return;
          }
  
          
 if (req.fnName === 'add_blueprint') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         blueprint: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.add_blueprint(req.args[0], callParams)

 }
    


 if (req.fnName === 'add_module') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         wasm_b56_content: req.tetraplets[0],conf: req.tetraplets[1]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.add_module(req.args[0], req.args[1], callParams)

 }
    


 if (req.fnName === 'add_module_from_vault') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         path: req.tetraplets[0],config: req.tetraplets[1]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.add_module_from_vault(req.args[0], req.args[1], callParams)

 }
    


 if (req.fnName === 'default_module_config') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         module_name: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.default_module_config(req.args[0], callParams)

 }
    


 if (req.fnName === 'get_interface') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         module_id: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.get_interface(req.args[0], callParams)

 }
    


 if (req.fnName === 'list_blueprints') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.list_blueprints(callParams)

 }
    


 if (req.fnName === 'list_modules') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.list_modules(callParams)

 }
    


 if (req.fnName === 'make_blueprint') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         name: req.tetraplets[0],dependencies: req.tetraplets[1]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.make_blueprint(req.args[0], req.args[1], callParams)

 }
    


 if (req.fnName === 'make_module_config') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         name: req.tetraplets[0],mem_pages_count: req.tetraplets[1],logger_enabled: req.tetraplets[2],preopened_files: req.tetraplets[3],envs: req.tetraplets[4],mapped_dirs: req.tetraplets[5],mounted_binaries: req.tetraplets[6],logging_mask: req.tetraplets[7]
     },
 };
 resp.retCode = ResultCodes.success;
 resp.result = service.make_module_config(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], req.args[4].length === 0 ? null : req.args[4][0], req.args[5].length === 0 ? null : req.args[5][0], req.args[6].length === 0 ? null : req.args[6][0], req.args[7].length === 0 ? null : req.args[7][0], callParams)

 }
    
  
          next();
      });
 }
      

// Functions

