/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/backgroundScript.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@wasmer/wasi/lib/bindings/browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/bindings/browser.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-ignore\nvar randomfill = __webpack_require__(/*! randomfill */ \"./node_modules/randomfill/browser.js\");\nvar browser_hrtime_1 = __webpack_require__(/*! ../polyfills/browser-hrtime */ \"./node_modules/@wasmer/wasi/lib/polyfills/browser-hrtime.js\");\n// @ts-ignore\nvar path = __webpack_require__(/*! path-browserify */ \"./node_modules/path-browserify/index.js\");\nvar index_1 = __webpack_require__(/*! ../index */ \"./node_modules/@wasmer/wasi/lib/index.js\");\nvar hrtime_bigint_1 = __webpack_require__(/*! ../polyfills/hrtime.bigint */ \"./node_modules/@wasmer/wasi/lib/polyfills/hrtime.bigint.js\");\nvar bindings = {\n    hrtime: hrtime_bigint_1.default(browser_hrtime_1.default),\n    exit: function (code) {\n        throw new index_1.WASIExitError(code);\n    },\n    kill: function (signal) {\n        throw new index_1.WASIKillError(signal);\n    },\n    // @ts-ignore\n    randomFillSync: randomfill.randomFillSync,\n    isTTY: function () { return true; },\n    path: path,\n    // Let the user attach the fs at runtime\n    fs: null\n};\nexports.default = bindings;\n\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/bindings/browser.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasi/lib/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/constants.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar _a;\n/*\n\nThis project is based from the Node implementation made by Gus Caplan\nhttps://github.com/devsnek/node-wasi\nHowever, JavaScript WASI is focused on:\n * Bringing WASI to the Browsers\n * Make easy to plug different filesystems\n * Provide a type-safe api using Typescript\n\n\nCopyright 2019 Gus Caplan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bigint_1 = __webpack_require__(/*! ./polyfills/bigint */ \"./node_modules/@wasmer/wasi/lib/polyfills/bigint.js\");\nexports.WASI_ESUCCESS = 0;\nexports.WASI_E2BIG = 1;\nexports.WASI_EACCES = 2;\nexports.WASI_EADDRINUSE = 3;\nexports.WASI_EADDRNOTAVAIL = 4;\nexports.WASI_EAFNOSUPPORT = 5;\nexports.WASI_EAGAIN = 6;\nexports.WASI_EALREADY = 7;\nexports.WASI_EBADF = 8;\nexports.WASI_EBADMSG = 9;\nexports.WASI_EBUSY = 10;\nexports.WASI_ECANCELED = 11;\nexports.WASI_ECHILD = 12;\nexports.WASI_ECONNABORTED = 13;\nexports.WASI_ECONNREFUSED = 14;\nexports.WASI_ECONNRESET = 15;\nexports.WASI_EDEADLK = 16;\nexports.WASI_EDESTADDRREQ = 17;\nexports.WASI_EDOM = 18;\nexports.WASI_EDQUOT = 19;\nexports.WASI_EEXIST = 20;\nexports.WASI_EFAULT = 21;\nexports.WASI_EFBIG = 22;\nexports.WASI_EHOSTUNREACH = 23;\nexports.WASI_EIDRM = 24;\nexports.WASI_EILSEQ = 25;\nexports.WASI_EINPROGRESS = 26;\nexports.WASI_EINTR = 27;\nexports.WASI_EINVAL = 28;\nexports.WASI_EIO = 29;\nexports.WASI_EISCONN = 30;\nexports.WASI_EISDIR = 31;\nexports.WASI_ELOOP = 32;\nexports.WASI_EMFILE = 33;\nexports.WASI_EMLINK = 34;\nexports.WASI_EMSGSIZE = 35;\nexports.WASI_EMULTIHOP = 36;\nexports.WASI_ENAMETOOLONG = 37;\nexports.WASI_ENETDOWN = 38;\nexports.WASI_ENETRESET = 39;\nexports.WASI_ENETUNREACH = 40;\nexports.WASI_ENFILE = 41;\nexports.WASI_ENOBUFS = 42;\nexports.WASI_ENODEV = 43;\nexports.WASI_ENOENT = 44;\nexports.WASI_ENOEXEC = 45;\nexports.WASI_ENOLCK = 46;\nexports.WASI_ENOLINK = 47;\nexports.WASI_ENOMEM = 48;\nexports.WASI_ENOMSG = 49;\nexports.WASI_ENOPROTOOPT = 50;\nexports.WASI_ENOSPC = 51;\nexports.WASI_ENOSYS = 52;\nexports.WASI_ENOTCONN = 53;\nexports.WASI_ENOTDIR = 54;\nexports.WASI_ENOTEMPTY = 55;\nexports.WASI_ENOTRECOVERABLE = 56;\nexports.WASI_ENOTSOCK = 57;\nexports.WASI_ENOTSUP = 58;\nexports.WASI_ENOTTY = 59;\nexports.WASI_ENXIO = 60;\nexports.WASI_EOVERFLOW = 61;\nexports.WASI_EOWNERDEAD = 62;\nexports.WASI_EPERM = 63;\nexports.WASI_EPIPE = 64;\nexports.WASI_EPROTO = 65;\nexports.WASI_EPROTONOSUPPORT = 66;\nexports.WASI_EPROTOTYPE = 67;\nexports.WASI_ERANGE = 68;\nexports.WASI_EROFS = 69;\nexports.WASI_ESPIPE = 70;\nexports.WASI_ESRCH = 71;\nexports.WASI_ESTALE = 72;\nexports.WASI_ETIMEDOUT = 73;\nexports.WASI_ETXTBSY = 74;\nexports.WASI_EXDEV = 75;\nexports.WASI_ENOTCAPABLE = 76;\nexports.WASI_SIGABRT = 0;\nexports.WASI_SIGALRM = 1;\nexports.WASI_SIGBUS = 2;\nexports.WASI_SIGCHLD = 3;\nexports.WASI_SIGCONT = 4;\nexports.WASI_SIGFPE = 5;\nexports.WASI_SIGHUP = 6;\nexports.WASI_SIGILL = 7;\nexports.WASI_SIGINT = 8;\nexports.WASI_SIGKILL = 9;\nexports.WASI_SIGPIPE = 10;\nexports.WASI_SIGQUIT = 11;\nexports.WASI_SIGSEGV = 12;\nexports.WASI_SIGSTOP = 13;\nexports.WASI_SIGTERM = 14;\nexports.WASI_SIGTRAP = 15;\nexports.WASI_SIGTSTP = 16;\nexports.WASI_SIGTTIN = 17;\nexports.WASI_SIGTTOU = 18;\nexports.WASI_SIGURG = 19;\nexports.WASI_SIGUSR1 = 20;\nexports.WASI_SIGUSR2 = 21;\nexports.WASI_SIGVTALRM = 22;\nexports.WASI_SIGXCPU = 23;\nexports.WASI_SIGXFSZ = 24;\nexports.WASI_FILETYPE_UNKNOWN = 0;\nexports.WASI_FILETYPE_BLOCK_DEVICE = 1;\nexports.WASI_FILETYPE_CHARACTER_DEVICE = 2;\nexports.WASI_FILETYPE_DIRECTORY = 3;\nexports.WASI_FILETYPE_REGULAR_FILE = 4;\nexports.WASI_FILETYPE_SOCKET_DGRAM = 5;\nexports.WASI_FILETYPE_SOCKET_STREAM = 6;\nexports.WASI_FILETYPE_SYMBOLIC_LINK = 7;\nexports.WASI_FDFLAG_APPEND = 0x0001;\nexports.WASI_FDFLAG_DSYNC = 0x0002;\nexports.WASI_FDFLAG_NONBLOCK = 0x0004;\nexports.WASI_FDFLAG_RSYNC = 0x0008;\nexports.WASI_FDFLAG_SYNC = 0x0010;\nexports.WASI_RIGHT_FD_DATASYNC = bigint_1.BigIntPolyfill(0x0000000000000001);\nexports.WASI_RIGHT_FD_READ = bigint_1.BigIntPolyfill(0x0000000000000002);\nexports.WASI_RIGHT_FD_SEEK = bigint_1.BigIntPolyfill(0x0000000000000004);\nexports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = bigint_1.BigIntPolyfill(0x0000000000000008);\nexports.WASI_RIGHT_FD_SYNC = bigint_1.BigIntPolyfill(0x0000000000000010);\nexports.WASI_RIGHT_FD_TELL = bigint_1.BigIntPolyfill(0x0000000000000020);\nexports.WASI_RIGHT_FD_WRITE = bigint_1.BigIntPolyfill(0x0000000000000040);\nexports.WASI_RIGHT_FD_ADVISE = bigint_1.BigIntPolyfill(0x0000000000000080);\nexports.WASI_RIGHT_FD_ALLOCATE = bigint_1.BigIntPolyfill(0x0000000000000100);\nexports.WASI_RIGHT_PATH_CREATE_DIRECTORY = bigint_1.BigIntPolyfill(0x0000000000000200);\nexports.WASI_RIGHT_PATH_CREATE_FILE = bigint_1.BigIntPolyfill(0x0000000000000400);\nexports.WASI_RIGHT_PATH_LINK_SOURCE = bigint_1.BigIntPolyfill(0x0000000000000800);\nexports.WASI_RIGHT_PATH_LINK_TARGET = bigint_1.BigIntPolyfill(0x0000000000001000);\nexports.WASI_RIGHT_PATH_OPEN = bigint_1.BigIntPolyfill(0x0000000000002000);\nexports.WASI_RIGHT_FD_READDIR = bigint_1.BigIntPolyfill(0x0000000000004000);\nexports.WASI_RIGHT_PATH_READLINK = bigint_1.BigIntPolyfill(0x0000000000008000);\nexports.WASI_RIGHT_PATH_RENAME_SOURCE = bigint_1.BigIntPolyfill(0x0000000000010000);\nexports.WASI_RIGHT_PATH_RENAME_TARGET = bigint_1.BigIntPolyfill(0x0000000000020000);\nexports.WASI_RIGHT_PATH_FILESTAT_GET = bigint_1.BigIntPolyfill(0x0000000000040000);\nexports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = bigint_1.BigIntPolyfill(0x0000000000080000);\nexports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = bigint_1.BigIntPolyfill(0x0000000000100000);\nexports.WASI_RIGHT_FD_FILESTAT_GET = bigint_1.BigIntPolyfill(0x0000000000200000);\nexports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = bigint_1.BigIntPolyfill(0x0000000000400000);\nexports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = bigint_1.BigIntPolyfill(0x0000000000800000);\nexports.WASI_RIGHT_PATH_SYMLINK = bigint_1.BigIntPolyfill(0x0000000001000000);\nexports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = bigint_1.BigIntPolyfill(0x0000000002000000);\nexports.WASI_RIGHT_PATH_UNLINK_FILE = bigint_1.BigIntPolyfill(0x0000000004000000);\nexports.WASI_RIGHT_POLL_FD_READWRITE = bigint_1.BigIntPolyfill(0x0000000008000000);\nexports.WASI_RIGHT_SOCK_SHUTDOWN = bigint_1.BigIntPolyfill(0x0000000010000000);\nexports.RIGHTS_ALL = exports.WASI_RIGHT_FD_DATASYNC |\n    exports.WASI_RIGHT_FD_READ |\n    exports.WASI_RIGHT_FD_SEEK |\n    exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_SYNC |\n    exports.WASI_RIGHT_FD_TELL |\n    exports.WASI_RIGHT_FD_WRITE |\n    exports.WASI_RIGHT_FD_ADVISE |\n    exports.WASI_RIGHT_FD_ALLOCATE |\n    exports.WASI_RIGHT_PATH_CREATE_DIRECTORY |\n    exports.WASI_RIGHT_PATH_CREATE_FILE |\n    exports.WASI_RIGHT_PATH_LINK_SOURCE |\n    exports.WASI_RIGHT_PATH_LINK_TARGET |\n    exports.WASI_RIGHT_PATH_OPEN |\n    exports.WASI_RIGHT_FD_READDIR |\n    exports.WASI_RIGHT_PATH_READLINK |\n    exports.WASI_RIGHT_PATH_RENAME_SOURCE |\n    exports.WASI_RIGHT_PATH_RENAME_TARGET |\n    exports.WASI_RIGHT_PATH_FILESTAT_GET |\n    exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE |\n    exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE |\n    exports.WASI_RIGHT_PATH_SYMLINK |\n    exports.WASI_RIGHT_PATH_UNLINK_FILE |\n    exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY |\n    exports.WASI_RIGHT_POLL_FD_READWRITE |\n    exports.WASI_RIGHT_SOCK_SHUTDOWN;\nexports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL;\nexports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_ALL;\nexports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_ALL;\nexports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_ALL;\nexports.RIGHTS_REGULAR_FILE_BASE = exports.WASI_RIGHT_FD_DATASYNC |\n    exports.WASI_RIGHT_FD_READ |\n    exports.WASI_RIGHT_FD_SEEK |\n    exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_SYNC |\n    exports.WASI_RIGHT_FD_TELL |\n    exports.WASI_RIGHT_FD_WRITE |\n    exports.WASI_RIGHT_FD_ADVISE |\n    exports.WASI_RIGHT_FD_ALLOCATE |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_POLL_FD_READWRITE;\nexports.RIGHTS_REGULAR_FILE_INHERITING = bigint_1.BigIntPolyfill(0);\nexports.RIGHTS_DIRECTORY_BASE = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_SYNC |\n    exports.WASI_RIGHT_FD_ADVISE |\n    exports.WASI_RIGHT_PATH_CREATE_DIRECTORY |\n    exports.WASI_RIGHT_PATH_CREATE_FILE |\n    exports.WASI_RIGHT_PATH_LINK_SOURCE |\n    exports.WASI_RIGHT_PATH_LINK_TARGET |\n    exports.WASI_RIGHT_PATH_OPEN |\n    exports.WASI_RIGHT_FD_READDIR |\n    exports.WASI_RIGHT_PATH_READLINK |\n    exports.WASI_RIGHT_PATH_RENAME_SOURCE |\n    exports.WASI_RIGHT_PATH_RENAME_TARGET |\n    exports.WASI_RIGHT_PATH_FILESTAT_GET |\n    exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE |\n    exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES |\n    exports.WASI_RIGHT_PATH_SYMLINK |\n    exports.WASI_RIGHT_PATH_UNLINK_FILE |\n    exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY |\n    exports.WASI_RIGHT_POLL_FD_READWRITE;\nexports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE | exports.RIGHTS_REGULAR_FILE_BASE;\nexports.RIGHTS_SOCKET_BASE = exports.WASI_RIGHT_FD_READ |\n    exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_WRITE |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_POLL_FD_READWRITE |\n    exports.WASI_RIGHT_SOCK_SHUTDOWN;\nexports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_ALL;\nexports.RIGHTS_TTY_BASE = exports.WASI_RIGHT_FD_READ |\n    exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS |\n    exports.WASI_RIGHT_FD_WRITE |\n    exports.WASI_RIGHT_FD_FILESTAT_GET |\n    exports.WASI_RIGHT_POLL_FD_READWRITE;\nexports.RIGHTS_TTY_INHERITING = bigint_1.BigIntPolyfill(0);\nexports.WASI_CLOCK_REALTIME = 0;\nexports.WASI_CLOCK_MONOTONIC = 1;\nexports.WASI_CLOCK_PROCESS_CPUTIME_ID = 2;\nexports.WASI_CLOCK_THREAD_CPUTIME_ID = 3;\nexports.WASI_EVENTTYPE_CLOCK = 0;\nexports.WASI_EVENTTYPE_FD_READ = 1;\nexports.WASI_EVENTTYPE_FD_WRITE = 2;\nexports.WASI_FILESTAT_SET_ATIM = 1 << 0;\nexports.WASI_FILESTAT_SET_ATIM_NOW = 1 << 1;\nexports.WASI_FILESTAT_SET_MTIM = 1 << 2;\nexports.WASI_FILESTAT_SET_MTIM_NOW = 1 << 3;\nexports.WASI_O_CREAT = 1 << 0;\nexports.WASI_O_DIRECTORY = 1 << 1;\nexports.WASI_O_EXCL = 1 << 2;\nexports.WASI_O_TRUNC = 1 << 3;\nexports.WASI_PREOPENTYPE_DIR = 0;\nexports.WASI_DIRCOOKIE_START = 0;\nexports.WASI_STDIN_FILENO = 0;\nexports.WASI_STDOUT_FILENO = 1;\nexports.WASI_STDERR_FILENO = 2;\nexports.WASI_WHENCE_SET = 0;\nexports.WASI_WHENCE_CUR = 1;\nexports.WASI_WHENCE_END = 2;\n// http://man7.org/linux/man-pages/man3/errno.3.html\nexports.ERROR_MAP = {\n    E2BIG: exports.WASI_E2BIG,\n    EACCES: exports.WASI_EACCES,\n    EADDRINUSE: exports.WASI_EADDRINUSE,\n    EADDRNOTAVAIL: exports.WASI_EADDRNOTAVAIL,\n    EAFNOSUPPORT: exports.WASI_EAFNOSUPPORT,\n    EALREADY: exports.WASI_EALREADY,\n    EAGAIN: exports.WASI_EAGAIN,\n    // EBADE: WASI_EBADE,\n    EBADF: exports.WASI_EBADF,\n    // EBADFD: WASI_EBADFD,\n    EBADMSG: exports.WASI_EBADMSG,\n    // EBADR: WASI_EBADR,\n    // EBADRQC: WASI_EBADRQC,\n    // EBADSLT: WASI_EBADSLT,\n    EBUSY: exports.WASI_EBUSY,\n    ECANCELED: exports.WASI_ECANCELED,\n    ECHILD: exports.WASI_ECHILD,\n    // ECHRNG: WASI_ECHRNG,\n    // ECOMM: WASI_ECOMM,\n    ECONNABORTED: exports.WASI_ECONNABORTED,\n    ECONNREFUSED: exports.WASI_ECONNREFUSED,\n    ECONNRESET: exports.WASI_ECONNRESET,\n    EDEADLOCK: exports.WASI_EDEADLK,\n    EDESTADDRREQ: exports.WASI_EDESTADDRREQ,\n    EDOM: exports.WASI_EDOM,\n    EDQUOT: exports.WASI_EDQUOT,\n    EEXIST: exports.WASI_EEXIST,\n    EFAULT: exports.WASI_EFAULT,\n    EFBIG: exports.WASI_EFBIG,\n    EHOSTDOWN: exports.WASI_EHOSTUNREACH,\n    EHOSTUNREACH: exports.WASI_EHOSTUNREACH,\n    // EHWPOISON: WASI_EHWPOISON,\n    EIDRM: exports.WASI_EIDRM,\n    EILSEQ: exports.WASI_EILSEQ,\n    EINPROGRESS: exports.WASI_EINPROGRESS,\n    EINTR: exports.WASI_EINTR,\n    EINVAL: exports.WASI_EINVAL,\n    EIO: exports.WASI_EIO,\n    EISCONN: exports.WASI_EISCONN,\n    EISDIR: exports.WASI_EISDIR,\n    ELOOP: exports.WASI_ELOOP,\n    EMFILE: exports.WASI_EMFILE,\n    EMLINK: exports.WASI_EMLINK,\n    EMSGSIZE: exports.WASI_EMSGSIZE,\n    EMULTIHOP: exports.WASI_EMULTIHOP,\n    ENAMETOOLONG: exports.WASI_ENAMETOOLONG,\n    ENETDOWN: exports.WASI_ENETDOWN,\n    ENETRESET: exports.WASI_ENETRESET,\n    ENETUNREACH: exports.WASI_ENETUNREACH,\n    ENFILE: exports.WASI_ENFILE,\n    ENOBUFS: exports.WASI_ENOBUFS,\n    ENODEV: exports.WASI_ENODEV,\n    ENOENT: exports.WASI_ENOENT,\n    ENOEXEC: exports.WASI_ENOEXEC,\n    ENOLCK: exports.WASI_ENOLCK,\n    ENOLINK: exports.WASI_ENOLINK,\n    ENOMEM: exports.WASI_ENOMEM,\n    ENOMSG: exports.WASI_ENOMSG,\n    ENOPROTOOPT: exports.WASI_ENOPROTOOPT,\n    ENOSPC: exports.WASI_ENOSPC,\n    ENOSYS: exports.WASI_ENOSYS,\n    ENOTCONN: exports.WASI_ENOTCONN,\n    ENOTDIR: exports.WASI_ENOTDIR,\n    ENOTEMPTY: exports.WASI_ENOTEMPTY,\n    ENOTRECOVERABLE: exports.WASI_ENOTRECOVERABLE,\n    ENOTSOCK: exports.WASI_ENOTSOCK,\n    ENOTTY: exports.WASI_ENOTTY,\n    ENXIO: exports.WASI_ENXIO,\n    EOVERFLOW: exports.WASI_EOVERFLOW,\n    EOWNERDEAD: exports.WASI_EOWNERDEAD,\n    EPERM: exports.WASI_EPERM,\n    EPIPE: exports.WASI_EPIPE,\n    EPROTO: exports.WASI_EPROTO,\n    EPROTONOSUPPORT: exports.WASI_EPROTONOSUPPORT,\n    EPROTOTYPE: exports.WASI_EPROTOTYPE,\n    ERANGE: exports.WASI_ERANGE,\n    EROFS: exports.WASI_EROFS,\n    ESPIPE: exports.WASI_ESPIPE,\n    ESRCH: exports.WASI_ESRCH,\n    ESTALE: exports.WASI_ESTALE,\n    ETIMEDOUT: exports.WASI_ETIMEDOUT,\n    ETXTBSY: exports.WASI_ETXTBSY,\n    EXDEV: exports.WASI_EXDEV\n};\nexports.SIGNAL_MAP = (_a = {},\n    _a[exports.WASI_SIGHUP] = \"SIGHUP\",\n    _a[exports.WASI_SIGINT] = \"SIGINT\",\n    _a[exports.WASI_SIGQUIT] = \"SIGQUIT\",\n    _a[exports.WASI_SIGILL] = \"SIGILL\",\n    _a[exports.WASI_SIGTRAP] = \"SIGTRAP\",\n    _a[exports.WASI_SIGABRT] = \"SIGABRT\",\n    _a[exports.WASI_SIGBUS] = \"SIGBUS\",\n    _a[exports.WASI_SIGFPE] = \"SIGFPE\",\n    _a[exports.WASI_SIGKILL] = \"SIGKILL\",\n    _a[exports.WASI_SIGUSR1] = \"SIGUSR1\",\n    _a[exports.WASI_SIGSEGV] = \"SIGSEGV\",\n    _a[exports.WASI_SIGUSR2] = \"SIGUSR2\",\n    _a[exports.WASI_SIGPIPE] = \"SIGPIPE\",\n    _a[exports.WASI_SIGALRM] = \"SIGALRM\",\n    _a[exports.WASI_SIGTERM] = \"SIGTERM\",\n    _a[exports.WASI_SIGCHLD] = \"SIGCHLD\",\n    _a[exports.WASI_SIGCONT] = \"SIGCONT\",\n    _a[exports.WASI_SIGSTOP] = \"SIGSTOP\",\n    _a[exports.WASI_SIGTSTP] = \"SIGTSTP\",\n    _a[exports.WASI_SIGTTIN] = \"SIGTTIN\",\n    _a[exports.WASI_SIGTTOU] = \"SIGTTOU\",\n    _a[exports.WASI_SIGURG] = \"SIGURG\",\n    _a[exports.WASI_SIGXCPU] = \"SIGXCPU\",\n    _a[exports.WASI_SIGXFSZ] = \"SIGXFSZ\",\n    _a[exports.WASI_SIGVTALRM] = \"SIGVTALRM\",\n    _a);\n\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/constants.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasi/lib/index.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/index.esm.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WASIKillError = exports.WASIExitError = exports.WASIError = exports.WASI = void 0;\n/*\n *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n*****************************************************************************/\nfunction aa(a, b) { aa = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (a, b) { a.__proto__ = b; } || function (a, b) { for (var c in b)\n    b.hasOwnProperty(c) && (a[c] = b[c]); }; return aa(a, b); }\nfunction ba(a, b) { function c() { this.constructor = a; } aa(a, b); a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c); }\nfunction ca(a) { var b = \"function\" === typeof Symbol && a[Symbol.iterator], c = 0; return b ? b.call(a) : { next: function () { a && c >= a.length && (a = void 0); return { value: a && a[c++], done: !a }; } }; }\nfunction da(a, b) { var c = \"function\" === typeof Symbol && a[Symbol.iterator]; if (!c)\n    return a; a = c.call(a); var d, e = []; try {\n    for (; (void 0 === b || 0 < b--) && !(d = a.next()).done;)\n        e.push(d.value);\n}\ncatch (g) {\n    var f = { error: g };\n}\nfinally {\n    try {\n        d && !d.done && (c = a[\"return\"]) && c.call(a);\n    }\n    finally {\n        if (f)\n            throw f.error;\n    }\n} return e; }\nfunction fa() { for (var a = [], b = 0; b < arguments.length; b++)\n    a = a.concat(da(arguments[b])); return a; }\nvar ha = \"undefined\" !== typeof globalThis ? globalThis : \"undefined\" !== typeof global ? global : {}, k = \"undefined\" !== typeof BigInt ? BigInt : ha.BigInt || Number, ia = DataView;\nia.prototype.setBigUint64 || (ia.prototype.setBigUint64 = function (a, b, c) { if (b < Math.pow(2, 32)) {\n    b = Number(b);\n    var d = 0;\n}\nelse {\n    d = b.toString(2);\n    b = \"\";\n    for (var e = 0; e < 64 - d.length; e++)\n        b += \"0\";\n    b += d;\n    d = parseInt(b.substring(0, 32), 2);\n    b = parseInt(b.substring(32), 2);\n} this.setUint32(a + (c ? 0 : 4), b, c); this.setUint32(a + (c ? 4 : 0), d, c); }, ia.prototype.getBigUint64 = function (a, b) { var c = this.getUint32(a + (b ? 0 : 4), b); a = this.getUint32(a + (b ? 4 : 0), b); c = c.toString(2); a = a.toString(2); b = \"\"; for (var d = 0; d < 32 - c.length; d++)\n    b += \"0\"; return k(\"0b\" + a + (b + c)); });\nvar ja = \"undefined\" !== typeof global ? global : \"undefined\" !== typeof self ? self : \"undefined\" !== typeof window ? window : {}, m = [], u = [], ka = \"undefined\" !== typeof Uint8Array ? Uint8Array : Array, la = !1;\nfunction ma() { la = !0; for (var a = 0; 64 > a; ++a)\n    m[a] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[a], u[\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charCodeAt(a)] = a; u[45] = 62; u[95] = 63; }\nfunction na(a, b, c) { for (var d = [], e = b; e < c; e += 3)\n    b = (a[e] << 16) + (a[e + 1] << 8) + a[e + 2], d.push(m[b >> 18 & 63] + m[b >> 12 & 63] + m[b >> 6 & 63] + m[b & 63]); return d.join(\"\"); }\nfunction oa(a) { la || ma(); for (var b = a.length, c = b % 3, d = \"\", e = [], f = 0, g = b - c; f < g; f += 16383)\n    e.push(na(a, f, f + 16383 > g ? g : f + 16383)); 1 === c ? (a = a[b - 1], d += m[a >> 2], d += m[a << 4 & 63], d += \"==\") : 2 === c && (a = (a[b - 2] << 8) + a[b - 1], d += m[a >> 10], d += m[a >> 4 & 63], d += m[a << 2 & 63], d += \"=\"); e.push(d); return e.join(\"\"); }\nfunction pa(a, b, c, d, e) { var f = 8 * e - d - 1; var g = (1 << f) - 1, h = g >> 1, l = -7; e = c ? e - 1 : 0; var n = c ? -1 : 1, r = a[b + e]; e += n; c = r & (1 << -l) - 1; r >>= -l; for (l += f; 0 < l; c = 256 * c + a[b + e], e += n, l -= 8)\n    ; f = c & (1 << -l) - 1; c >>= -l; for (l += d; 0 < l; f = 256 * f + a[b + e], e += n, l -= 8)\n    ; if (0 === c)\n    c = 1 - h;\nelse {\n    if (c === g)\n        return f ? NaN : Infinity * (r ? -1 : 1);\n    f += Math.pow(2, d);\n    c -= h;\n} return (r ? -1 : 1) * f * Math.pow(2, c - d); }\nfunction qa(a, b, c, d, e, f) {\n    var g, h = 8 * f - e - 1, l = (1 << h) - 1, n = l >> 1, r = 23 === e ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    f = d ? 0 : f - 1;\n    var p = d ? 1 : -1, y = 0 > b || 0 === b && 0 > 1 / b ? 1 : 0;\n    b = Math.abs(b);\n    isNaN(b) || Infinity === b ? (b = isNaN(b) ? 1 : 0, d = l) : (d = Math.floor(Math.log(b) / Math.LN2), 1 > b * (g = Math.pow(2, -d)) && (d--, g *= 2), b = 1 <= d + n ? b + r / g : b + r * Math.pow(2, 1 - n), 2 <= b * g && (d++, g /= 2), d + n >= l ? (b = 0, d = l) : 1 <= d + n ? (b = (b * g - 1) * Math.pow(2, e), d += n) : (b = b * Math.pow(2, n - 1) * Math.pow(2, e), d = 0));\n    for (; 8 <= e; a[c + f] = b & 255, f += p, b /= 256, e -= 8)\n        ;\n    d = d << e | b;\n    for (h += e; 0 < h; a[c + f] = d & 255,\n        f += p, d /= 256, h -= 8)\n        ;\n    a[c + f - p] |= 128 * y;\n}\nvar ra = {}.toString, sa = Array.isArray || function (a) { return \"[object Array]\" == ra.call(a); };\nv.TYPED_ARRAY_SUPPORT = void 0 !== ja.TYPED_ARRAY_SUPPORT ? ja.TYPED_ARRAY_SUPPORT : !0;\nvar ta = v.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;\nfunction w(a, b) { if ((v.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823) < b)\n    throw new RangeError(\"Invalid typed array length\"); v.TYPED_ARRAY_SUPPORT ? (a = new Uint8Array(b), a.__proto__ = v.prototype) : (null === a && (a = new v(b)), a.length = b); return a; }\nfunction v(a, b, c) { if (!(v.TYPED_ARRAY_SUPPORT || this instanceof v))\n    return new v(a, b, c); if (\"number\" === typeof a) {\n    if (\"string\" === typeof b)\n        throw Error(\"If encoding is specified then the first argument must be a string\");\n    return va(this, a);\n} return wa(this, a, b, c); }\nv.poolSize = 8192;\nv._augment = function (a) { a.__proto__ = v.prototype; return a; };\nfunction wa(a, b, c, d) {\n    if (\"number\" === typeof b)\n        throw new TypeError('\"value\" argument must not be a number');\n    if (\"undefined\" !== typeof ArrayBuffer && b instanceof ArrayBuffer) {\n        b.byteLength;\n        if (0 > c || b.byteLength < c)\n            throw new RangeError(\"'offset' is out of bounds\");\n        if (b.byteLength < c + (d || 0))\n            throw new RangeError(\"'length' is out of bounds\");\n        b = void 0 === c && void 0 === d ? new Uint8Array(b) : void 0 === d ? new Uint8Array(b, c) : new Uint8Array(b, c, d);\n        v.TYPED_ARRAY_SUPPORT ? (a = b, a.__proto__ = v.prototype) : a = xa(a, b);\n        return a;\n    }\n    if (\"string\" ===\n        typeof b) {\n        d = a;\n        a = c;\n        if (\"string\" !== typeof a || \"\" === a)\n            a = \"utf8\";\n        if (!v.isEncoding(a))\n            throw new TypeError('\"encoding\" must be a valid string encoding');\n        c = ya(b, a) | 0;\n        d = w(d, c);\n        b = d.write(b, a);\n        b !== c && (d = d.slice(0, b));\n        return d;\n    }\n    return za(a, b);\n}\nv.from = function (a, b, c) { return wa(null, a, b, c); };\nv.TYPED_ARRAY_SUPPORT && (v.prototype.__proto__ = Uint8Array.prototype, v.__proto__ = Uint8Array);\nfunction Aa(a) { if (\"number\" !== typeof a)\n    throw new TypeError('\"size\" argument must be a number'); if (0 > a)\n    throw new RangeError('\"size\" argument must not be negative'); }\nv.alloc = function (a, b, c) { Aa(a); a = 0 >= a ? w(null, a) : void 0 !== b ? \"string\" === typeof c ? w(null, a).fill(b, c) : w(null, a).fill(b) : w(null, a); return a; };\nfunction va(a, b) { Aa(b); a = w(a, 0 > b ? 0 : Ba(b) | 0); if (!v.TYPED_ARRAY_SUPPORT)\n    for (var c = 0; c < b; ++c)\n        a[c] = 0; return a; }\nv.allocUnsafe = function (a) { return va(null, a); };\nv.allocUnsafeSlow = function (a) { return va(null, a); };\nfunction xa(a, b) { var c = 0 > b.length ? 0 : Ba(b.length) | 0; a = w(a, c); for (var d = 0; d < c; d += 1)\n    a[d] = b[d] & 255; return a; }\nfunction za(a, b) { if (z(b)) {\n    var c = Ba(b.length) | 0;\n    a = w(a, c);\n    if (0 === a.length)\n        return a;\n    b.copy(a, 0, 0, c);\n    return a;\n} if (b) {\n    if (\"undefined\" !== typeof ArrayBuffer && b.buffer instanceof ArrayBuffer || \"length\" in b)\n        return (c = \"number\" !== typeof b.length) || (c = b.length, c = c !== c), c ? w(a, 0) : xa(a, b);\n    if (\"Buffer\" === b.type && sa(b.data))\n        return xa(a, b.data);\n} throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\"); }\nfunction Ba(a) { if (a >= (v.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823))\n    throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + (v.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823).toString(16) + \" bytes\"); return a | 0; }\nv.isBuffer = Ca;\nfunction z(a) { return !(null == a || !a._isBuffer); }\nv.compare = function (a, b) { if (!z(a) || !z(b))\n    throw new TypeError(\"Arguments must be Buffers\"); if (a === b)\n    return 0; for (var c = a.length, d = b.length, e = 0, f = Math.min(c, d); e < f; ++e)\n    if (a[e] !== b[e]) {\n        c = a[e];\n        d = b[e];\n        break;\n    } return c < d ? -1 : d < c ? 1 : 0; };\nv.isEncoding = function (a) { switch (String(a).toLowerCase()) {\n    case \"hex\":\n    case \"utf8\":\n    case \"utf-8\":\n    case \"ascii\":\n    case \"latin1\":\n    case \"binary\":\n    case \"base64\":\n    case \"ucs2\":\n    case \"ucs-2\":\n    case \"utf16le\":\n    case \"utf-16le\": return !0;\n    default: return !1;\n} };\nv.concat = function (a, b) { if (!sa(a))\n    throw new TypeError('\"list\" argument must be an Array of Buffers'); if (0 === a.length)\n    return v.alloc(0); var c; if (void 0 === b)\n    for (c = b = 0; c < a.length; ++c)\n        b += a[c].length; b = v.allocUnsafe(b); var d = 0; for (c = 0; c < a.length; ++c) {\n    var e = a[c];\n    if (!z(e))\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    e.copy(b, d);\n    d += e.length;\n} return b; };\nfunction ya(a, b) {\n    if (z(a))\n        return a.length;\n    if (\"undefined\" !== typeof ArrayBuffer && \"function\" === typeof ArrayBuffer.isView && (ArrayBuffer.isView(a) || a instanceof ArrayBuffer))\n        return a.byteLength;\n    \"string\" !== typeof a && (a = \"\" + a);\n    var c = a.length;\n    if (0 === c)\n        return 0;\n    for (var d = !1;;)\n        switch (b) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\": return c;\n            case \"utf8\":\n            case \"utf-8\":\n            case void 0: return Da(a).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\": return 2 * c;\n            case \"hex\": return c >>> 1;\n            case \"base64\": return Ea(a).length;\n            default:\n                if (d)\n                    return Da(a).length;\n                b = (\"\" + b).toLowerCase();\n                d = !0;\n        }\n}\nv.byteLength = ya;\nfunction Fa(a, b, c) {\n    var d = !1;\n    if (void 0 === b || 0 > b)\n        b = 0;\n    if (b > this.length)\n        return \"\";\n    if (void 0 === c || c > this.length)\n        c = this.length;\n    if (0 >= c)\n        return \"\";\n    c >>>= 0;\n    b >>>= 0;\n    if (c <= b)\n        return \"\";\n    for (a || (a = \"utf8\");;)\n        switch (a) {\n            case \"hex\":\n                a = b;\n                b = c;\n                c = this.length;\n                if (!a || 0 > a)\n                    a = 0;\n                if (!b || 0 > b || b > c)\n                    b = c;\n                d = \"\";\n                for (c = a; c < b; ++c)\n                    a = d, d = this[c], d = 16 > d ? \"0\" + d.toString(16) : d.toString(16), d = a + d;\n                return d;\n            case \"utf8\":\n            case \"utf-8\": return Ga(this, b, c);\n            case \"ascii\":\n                a = \"\";\n                for (c = Math.min(this.length, c); b < c; ++b)\n                    a += String.fromCharCode(this[b] & 127);\n                return a;\n            case \"latin1\":\n            case \"binary\":\n                a = \"\";\n                for (c = Math.min(this.length, c); b < c; ++b)\n                    a += String.fromCharCode(this[b]);\n                return a;\n            case \"base64\": return b = 0 === b && c === this.length ? oa(this) : oa(this.slice(b, c)), b;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                b = this.slice(b, c);\n                c = \"\";\n                for (a = 0; a < b.length; a += 2)\n                    c += String.fromCharCode(b[a] + 256 * b[a + 1]);\n                return c;\n            default:\n                if (d)\n                    throw new TypeError(\"Unknown encoding: \" + a);\n                a = (a + \"\").toLowerCase();\n                d = !0;\n        }\n}\nv.prototype._isBuffer = !0;\nfunction A(a, b, c) { var d = a[b]; a[b] = a[c]; a[c] = d; }\nv.prototype.swap16 = function () { var a = this.length; if (0 !== a % 2)\n    throw new RangeError(\"Buffer size must be a multiple of 16-bits\"); for (var b = 0; b < a; b += 2)\n    A(this, b, b + 1); return this; };\nv.prototype.swap32 = function () { var a = this.length; if (0 !== a % 4)\n    throw new RangeError(\"Buffer size must be a multiple of 32-bits\"); for (var b = 0; b < a; b += 4)\n    A(this, b, b + 3), A(this, b + 1, b + 2); return this; };\nv.prototype.swap64 = function () { var a = this.length; if (0 !== a % 8)\n    throw new RangeError(\"Buffer size must be a multiple of 64-bits\"); for (var b = 0; b < a; b += 8)\n    A(this, b, b + 7), A(this, b + 1, b + 6), A(this, b + 2, b + 5), A(this, b + 3, b + 4); return this; };\nv.prototype.toString = function () { var a = this.length | 0; return 0 === a ? \"\" : 0 === arguments.length ? Ga(this, 0, a) : Fa.apply(this, arguments); };\nv.prototype.equals = function (a) { if (!z(a))\n    throw new TypeError(\"Argument must be a Buffer\"); return this === a ? !0 : 0 === v.compare(this, a); };\nv.prototype.inspect = function () { var a = \"\"; 0 < this.length && (a = this.toString(\"hex\", 0, 50).match(/.{2}/g).join(\" \"), 50 < this.length && (a += \" ... \")); return \"<Buffer \" + a + \">\"; };\nv.prototype.compare = function (a, b, c, d, e) {\n    if (!z(a))\n        throw new TypeError(\"Argument must be a Buffer\");\n    void 0 === b && (b = 0);\n    void 0 === c && (c = a ? a.length : 0);\n    void 0 === d && (d = 0);\n    void 0 === e && (e = this.length);\n    if (0 > b || c > a.length || 0 > d || e > this.length)\n        throw new RangeError(\"out of range index\");\n    if (d >= e && b >= c)\n        return 0;\n    if (d >= e)\n        return -1;\n    if (b >= c)\n        return 1;\n    b >>>= 0;\n    c >>>= 0;\n    d >>>= 0;\n    e >>>= 0;\n    if (this === a)\n        return 0;\n    var f = e - d, g = c - b, h = Math.min(f, g);\n    d = this.slice(d, e);\n    a = a.slice(b, c);\n    for (b = 0; b < h; ++b)\n        if (d[b] !== a[b]) {\n            f = d[b];\n            g = a[b];\n            break;\n        }\n    return f <\n        g ? -1 : g < f ? 1 : 0;\n};\nfunction Ha(a, b, c, d, e) {\n    if (0 === a.length)\n        return -1;\n    \"string\" === typeof c ? (d = c, c = 0) : 2147483647 < c ? c = 2147483647 : -2147483648 > c && (c = -2147483648);\n    c = +c;\n    isNaN(c) && (c = e ? 0 : a.length - 1);\n    0 > c && (c = a.length + c);\n    if (c >= a.length) {\n        if (e)\n            return -1;\n        c = a.length - 1;\n    }\n    else if (0 > c)\n        if (e)\n            c = 0;\n        else\n            return -1;\n    \"string\" === typeof b && (b = v.from(b, d));\n    if (z(b))\n        return 0 === b.length ? -1 : Ia(a, b, c, d, e);\n    if (\"number\" === typeof b)\n        return b &= 255, v.TYPED_ARRAY_SUPPORT && \"function\" === typeof Uint8Array.prototype.indexOf ? e ? Uint8Array.prototype.indexOf.call(a, b, c) :\n            Uint8Array.prototype.lastIndexOf.call(a, b, c) : Ia(a, [b], c, d, e);\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction Ia(a, b, c, d, e) { function f(a, b) { return 1 === g ? a[b] : a.readUInt16BE(b * g); } var g = 1, h = a.length, l = b.length; if (void 0 !== d && (d = String(d).toLowerCase(), \"ucs2\" === d || \"ucs-2\" === d || \"utf16le\" === d || \"utf-16le\" === d)) {\n    if (2 > a.length || 2 > b.length)\n        return -1;\n    g = 2;\n    h /= 2;\n    l /= 2;\n    c /= 2;\n} if (e)\n    for (d = -1; c < h; c++)\n        if (f(a, c) === f(b, -1 === d ? 0 : c - d)) {\n            if (-1 === d && (d = c), c - d + 1 === l)\n                return d * g;\n        }\n        else\n            -1 !== d && (c -= c - d), d = -1;\nelse\n    for (c + l > h && (c = h - l); 0 <= c; c--) {\n        h = !0;\n        for (d = 0; d < l; d++)\n            if (f(a, c + d) !== f(b, d)) {\n                h = !1;\n                break;\n            }\n        if (h)\n            return c;\n    } return -1; }\nv.prototype.includes = function (a, b, c) { return -1 !== this.indexOf(a, b, c); };\nv.prototype.indexOf = function (a, b, c) { return Ha(this, a, b, c, !0); };\nv.prototype.lastIndexOf = function (a, b, c) { return Ha(this, a, b, c, !1); };\nv.prototype.write = function (a, b, c, d) {\n    if (void 0 === b)\n        d = \"utf8\", c = this.length, b = 0;\n    else if (void 0 === c && \"string\" === typeof b)\n        d = b, c = this.length, b = 0;\n    else if (isFinite(b))\n        b |= 0, isFinite(c) ? (c |= 0, void 0 === d && (d = \"utf8\")) : (d = c, c = void 0);\n    else\n        throw Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    var e = this.length - b;\n    if (void 0 === c || c > e)\n        c = e;\n    if (0 < a.length && (0 > c || 0 > b) || b > this.length)\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    d || (d = \"utf8\");\n    for (e = !1;;)\n        switch (d) {\n            case \"hex\":\n                a: {\n                    b =\n                        Number(b) || 0;\n                    d = this.length - b;\n                    c ? (c = Number(c), c > d && (c = d)) : c = d;\n                    d = a.length;\n                    if (0 !== d % 2)\n                        throw new TypeError(\"Invalid hex string\");\n                    c > d / 2 && (c = d / 2);\n                    for (d = 0; d < c; ++d) {\n                        e = parseInt(a.substr(2 * d, 2), 16);\n                        if (isNaN(e)) {\n                            a = d;\n                            break a;\n                        }\n                        this[b + d] = e;\n                    }\n                    a = d;\n                }\n                return a;\n            case \"utf8\":\n            case \"utf-8\": return Ja(Da(a, this.length - b), this, b, c);\n            case \"ascii\": return Ja(Ka(a), this, b, c);\n            case \"latin1\":\n            case \"binary\": return Ja(Ka(a), this, b, c);\n            case \"base64\": return Ja(Ea(a), this, b, c);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                d = a;\n                e = this.length -\n                    b;\n                for (var f = [], g = 0; g < d.length && !(0 > (e -= 2)); ++g) {\n                    var h = d.charCodeAt(g);\n                    a = h >> 8;\n                    h %= 256;\n                    f.push(h);\n                    f.push(a);\n                }\n                return Ja(f, this, b, c);\n            default:\n                if (e)\n                    throw new TypeError(\"Unknown encoding: \" + d);\n                d = (\"\" + d).toLowerCase();\n                e = !0;\n        }\n};\nv.prototype.toJSON = function () { return { type: \"Buffer\", data: Array.prototype.slice.call(this._arr || this, 0) }; };\nfunction Ga(a, b, c) {\n    c = Math.min(a.length, c);\n    for (var d = []; b < c;) {\n        var e = a[b], f = null, g = 239 < e ? 4 : 223 < e ? 3 : 191 < e ? 2 : 1;\n        if (b + g <= c)\n            switch (g) {\n                case 1:\n                    128 > e && (f = e);\n                    break;\n                case 2:\n                    var h = a[b + 1];\n                    128 === (h & 192) && (e = (e & 31) << 6 | h & 63, 127 < e && (f = e));\n                    break;\n                case 3:\n                    h = a[b + 1];\n                    var l = a[b + 2];\n                    128 === (h & 192) && 128 === (l & 192) && (e = (e & 15) << 12 | (h & 63) << 6 | l & 63, 2047 < e && (55296 > e || 57343 < e) && (f = e));\n                    break;\n                case 4:\n                    h = a[b + 1];\n                    l = a[b + 2];\n                    var n = a[b + 3];\n                    128 === (h & 192) && 128 === (l & 192) && 128 === (n & 192) && (e = (e & 15) << 18 | (h & 63) << 12 | (l & 63) << 6 | n & 63, 65535 < e && 1114112 > e && (f =\n                        e));\n            }\n        null === f ? (f = 65533, g = 1) : 65535 < f && (f -= 65536, d.push(f >>> 10 & 1023 | 55296), f = 56320 | f & 1023);\n        d.push(f);\n        b += g;\n    }\n    a = d.length;\n    if (a <= La)\n        d = String.fromCharCode.apply(String, d);\n    else {\n        c = \"\";\n        for (b = 0; b < a;)\n            c += String.fromCharCode.apply(String, d.slice(b, b += La));\n        d = c;\n    }\n    return d;\n}\nvar La = 4096;\nv.prototype.slice = function (a, b) { var c = this.length; a = ~~a; b = void 0 === b ? c : ~~b; 0 > a ? (a += c, 0 > a && (a = 0)) : a > c && (a = c); 0 > b ? (b += c, 0 > b && (b = 0)) : b > c && (b = c); b < a && (b = a); if (v.TYPED_ARRAY_SUPPORT)\n    b = this.subarray(a, b), b.__proto__ = v.prototype;\nelse {\n    c = b - a;\n    b = new v(c, void 0);\n    for (var d = 0; d < c; ++d)\n        b[d] = this[d + a];\n} return b; };\nfunction C(a, b, c) { if (0 !== a % 1 || 0 > a)\n    throw new RangeError(\"offset is not uint\"); if (a + b > c)\n    throw new RangeError(\"Trying to access beyond buffer length\"); }\nv.prototype.readUIntLE = function (a, b, c) { a |= 0; b |= 0; c || C(a, b, this.length); c = this[a]; for (var d = 1, e = 0; ++e < b && (d *= 256);)\n    c += this[a + e] * d; return c; };\nv.prototype.readUIntBE = function (a, b, c) { a |= 0; b |= 0; c || C(a, b, this.length); c = this[a + --b]; for (var d = 1; 0 < b && (d *= 256);)\n    c += this[a + --b] * d; return c; };\nv.prototype.readUInt8 = function (a, b) { b || C(a, 1, this.length); return this[a]; };\nv.prototype.readUInt16LE = function (a, b) { b || C(a, 2, this.length); return this[a] | this[a + 1] << 8; };\nv.prototype.readUInt16BE = function (a, b) { b || C(a, 2, this.length); return this[a] << 8 | this[a + 1]; };\nv.prototype.readUInt32LE = function (a, b) { b || C(a, 4, this.length); return (this[a] | this[a + 1] << 8 | this[a + 2] << 16) + 16777216 * this[a + 3]; };\nv.prototype.readUInt32BE = function (a, b) { b || C(a, 4, this.length); return 16777216 * this[a] + (this[a + 1] << 16 | this[a + 2] << 8 | this[a + 3]); };\nv.prototype.readIntLE = function (a, b, c) { a |= 0; b |= 0; c || C(a, b, this.length); c = this[a]; for (var d = 1, e = 0; ++e < b && (d *= 256);)\n    c += this[a + e] * d; c >= 128 * d && (c -= Math.pow(2, 8 * b)); return c; };\nv.prototype.readIntBE = function (a, b, c) { a |= 0; b |= 0; c || C(a, b, this.length); c = b; for (var d = 1, e = this[a + --c]; 0 < c && (d *= 256);)\n    e += this[a + --c] * d; e >= 128 * d && (e -= Math.pow(2, 8 * b)); return e; };\nv.prototype.readInt8 = function (a, b) { b || C(a, 1, this.length); return this[a] & 128 ? -1 * (255 - this[a] + 1) : this[a]; };\nv.prototype.readInt16LE = function (a, b) { b || C(a, 2, this.length); a = this[a] | this[a + 1] << 8; return a & 32768 ? a | 4294901760 : a; };\nv.prototype.readInt16BE = function (a, b) { b || C(a, 2, this.length); a = this[a + 1] | this[a] << 8; return a & 32768 ? a | 4294901760 : a; };\nv.prototype.readInt32LE = function (a, b) { b || C(a, 4, this.length); return this[a] | this[a + 1] << 8 | this[a + 2] << 16 | this[a + 3] << 24; };\nv.prototype.readInt32BE = function (a, b) { b || C(a, 4, this.length); return this[a] << 24 | this[a + 1] << 16 | this[a + 2] << 8 | this[a + 3]; };\nv.prototype.readFloatLE = function (a, b) { b || C(a, 4, this.length); return pa(this, a, !0, 23, 4); };\nv.prototype.readFloatBE = function (a, b) { b || C(a, 4, this.length); return pa(this, a, !1, 23, 4); };\nv.prototype.readDoubleLE = function (a, b) { b || C(a, 8, this.length); return pa(this, a, !0, 52, 8); };\nv.prototype.readDoubleBE = function (a, b) { b || C(a, 8, this.length); return pa(this, a, !1, 52, 8); };\nfunction D(a, b, c, d, e, f) { if (!z(a))\n    throw new TypeError('\"buffer\" argument must be a Buffer instance'); if (b > e || b < f)\n    throw new RangeError('\"value\" argument is out of bounds'); if (c + d > a.length)\n    throw new RangeError(\"Index out of range\"); }\nv.prototype.writeUIntLE = function (a, b, c, d) { a = +a; b |= 0; c |= 0; d || D(this, a, b, c, Math.pow(2, 8 * c) - 1, 0); d = 1; var e = 0; for (this[b] = a & 255; ++e < c && (d *= 256);)\n    this[b + e] = a / d & 255; return b + c; };\nv.prototype.writeUIntBE = function (a, b, c, d) { a = +a; b |= 0; c |= 0; d || D(this, a, b, c, Math.pow(2, 8 * c) - 1, 0); d = c - 1; var e = 1; for (this[b + d] = a & 255; 0 <= --d && (e *= 256);)\n    this[b + d] = a / e & 255; return b + c; };\nv.prototype.writeUInt8 = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 1, 255, 0); v.TYPED_ARRAY_SUPPORT || (a = Math.floor(a)); this[b] = a & 255; return b + 1; };\nfunction Ma(a, b, c, d) { 0 > b && (b = 65535 + b + 1); for (var e = 0, f = Math.min(a.length - c, 2); e < f; ++e)\n    a[c + e] = (b & 255 << 8 * (d ? e : 1 - e)) >>> 8 * (d ? e : 1 - e); }\nv.prototype.writeUInt16LE = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 2, 65535, 0); v.TYPED_ARRAY_SUPPORT ? (this[b] = a & 255, this[b + 1] = a >>> 8) : Ma(this, a, b, !0); return b + 2; };\nv.prototype.writeUInt16BE = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 2, 65535, 0); v.TYPED_ARRAY_SUPPORT ? (this[b] = a >>> 8, this[b + 1] = a & 255) : Ma(this, a, b, !1); return b + 2; };\nfunction Na(a, b, c, d) { 0 > b && (b = 4294967295 + b + 1); for (var e = 0, f = Math.min(a.length - c, 4); e < f; ++e)\n    a[c + e] = b >>> 8 * (d ? e : 3 - e) & 255; }\nv.prototype.writeUInt32LE = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 4, 4294967295, 0); v.TYPED_ARRAY_SUPPORT ? (this[b + 3] = a >>> 24, this[b + 2] = a >>> 16, this[b + 1] = a >>> 8, this[b] = a & 255) : Na(this, a, b, !0); return b + 4; };\nv.prototype.writeUInt32BE = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 4, 4294967295, 0); v.TYPED_ARRAY_SUPPORT ? (this[b] = a >>> 24, this[b + 1] = a >>> 16, this[b + 2] = a >>> 8, this[b + 3] = a & 255) : Na(this, a, b, !1); return b + 4; };\nv.prototype.writeIntLE = function (a, b, c, d) { a = +a; b |= 0; d || (d = Math.pow(2, 8 * c - 1), D(this, a, b, c, d - 1, -d)); d = 0; var e = 1, f = 0; for (this[b] = a & 255; ++d < c && (e *= 256);)\n    0 > a && 0 === f && 0 !== this[b + d - 1] && (f = 1), this[b + d] = (a / e >> 0) - f & 255; return b + c; };\nv.prototype.writeIntBE = function (a, b, c, d) { a = +a; b |= 0; d || (d = Math.pow(2, 8 * c - 1), D(this, a, b, c, d - 1, -d)); d = c - 1; var e = 1, f = 0; for (this[b + d] = a & 255; 0 <= --d && (e *= 256);)\n    0 > a && 0 === f && 0 !== this[b + d + 1] && (f = 1), this[b + d] = (a / e >> 0) - f & 255; return b + c; };\nv.prototype.writeInt8 = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 1, 127, -128); v.TYPED_ARRAY_SUPPORT || (a = Math.floor(a)); 0 > a && (a = 255 + a + 1); this[b] = a & 255; return b + 1; };\nv.prototype.writeInt16LE = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 2, 32767, -32768); v.TYPED_ARRAY_SUPPORT ? (this[b] = a & 255, this[b + 1] = a >>> 8) : Ma(this, a, b, !0); return b + 2; };\nv.prototype.writeInt16BE = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 2, 32767, -32768); v.TYPED_ARRAY_SUPPORT ? (this[b] = a >>> 8, this[b + 1] = a & 255) : Ma(this, a, b, !1); return b + 2; };\nv.prototype.writeInt32LE = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 4, 2147483647, -2147483648); v.TYPED_ARRAY_SUPPORT ? (this[b] = a & 255, this[b + 1] = a >>> 8, this[b + 2] = a >>> 16, this[b + 3] = a >>> 24) : Na(this, a, b, !0); return b + 4; };\nv.prototype.writeInt32BE = function (a, b, c) { a = +a; b |= 0; c || D(this, a, b, 4, 2147483647, -2147483648); 0 > a && (a = 4294967295 + a + 1); v.TYPED_ARRAY_SUPPORT ? (this[b] = a >>> 24, this[b + 1] = a >>> 16, this[b + 2] = a >>> 8, this[b + 3] = a & 255) : Na(this, a, b, !1); return b + 4; };\nfunction Oa(a, b, c, d) { if (c + d > a.length)\n    throw new RangeError(\"Index out of range\"); if (0 > c)\n    throw new RangeError(\"Index out of range\"); }\nv.prototype.writeFloatLE = function (a, b, c) { c || Oa(this, a, b, 4); qa(this, a, b, !0, 23, 4); return b + 4; };\nv.prototype.writeFloatBE = function (a, b, c) { c || Oa(this, a, b, 4); qa(this, a, b, !1, 23, 4); return b + 4; };\nv.prototype.writeDoubleLE = function (a, b, c) { c || Oa(this, a, b, 8); qa(this, a, b, !0, 52, 8); return b + 8; };\nv.prototype.writeDoubleBE = function (a, b, c) { c || Oa(this, a, b, 8); qa(this, a, b, !1, 52, 8); return b + 8; };\nv.prototype.copy = function (a, b, c, d) {\n    c || (c = 0);\n    d || 0 === d || (d = this.length);\n    b >= a.length && (b = a.length);\n    b || (b = 0);\n    0 < d && d < c && (d = c);\n    if (d === c || 0 === a.length || 0 === this.length)\n        return 0;\n    if (0 > b)\n        throw new RangeError(\"targetStart out of bounds\");\n    if (0 > c || c >= this.length)\n        throw new RangeError(\"sourceStart out of bounds\");\n    if (0 > d)\n        throw new RangeError(\"sourceEnd out of bounds\");\n    d > this.length && (d = this.length);\n    a.length - b < d - c && (d = a.length - b + c);\n    var e = d - c;\n    if (this === a && c < b && b < d)\n        for (d = e - 1; 0 <= d; --d)\n            a[d + b] = this[d + c];\n    else if (1E3 > e ||\n        !v.TYPED_ARRAY_SUPPORT)\n        for (d = 0; d < e; ++d)\n            a[d + b] = this[d + c];\n    else\n        Uint8Array.prototype.set.call(a, this.subarray(c, c + e), b);\n    return e;\n};\nv.prototype.fill = function (a, b, c, d) {\n    if (\"string\" === typeof a) {\n        \"string\" === typeof b ? (d = b, b = 0, c = this.length) : \"string\" === typeof c && (d = c, c = this.length);\n        if (1 === a.length) {\n            var e = a.charCodeAt(0);\n            256 > e && (a = e);\n        }\n        if (void 0 !== d && \"string\" !== typeof d)\n            throw new TypeError(\"encoding must be a string\");\n        if (\"string\" === typeof d && !v.isEncoding(d))\n            throw new TypeError(\"Unknown encoding: \" + d);\n    }\n    else\n        \"number\" === typeof a && (a &= 255);\n    if (0 > b || this.length < b || this.length < c)\n        throw new RangeError(\"Out of range index\");\n    if (c <= b)\n        return this;\n    b >>>=\n        0;\n    c = void 0 === c ? this.length : c >>> 0;\n    a || (a = 0);\n    if (\"number\" === typeof a)\n        for (d = b; d < c; ++d)\n            this[d] = a;\n    else\n        for (a = z(a) ? a : Da((new v(a, d)).toString()), e = a.length, d = 0; d < c - b; ++d)\n            this[d + b] = a[d % e];\n    return this;\n};\nvar Pa = /[^+\\/0-9A-Za-z-_]/g;\nfunction Da(a, b) {\n    b = b || Infinity;\n    for (var c, d = a.length, e = null, f = [], g = 0; g < d; ++g) {\n        c = a.charCodeAt(g);\n        if (55295 < c && 57344 > c) {\n            if (!e) {\n                if (56319 < c) {\n                    -1 < (b -= 3) && f.push(239, 191, 189);\n                    continue;\n                }\n                else if (g + 1 === d) {\n                    -1 < (b -= 3) && f.push(239, 191, 189);\n                    continue;\n                }\n                e = c;\n                continue;\n            }\n            if (56320 > c) {\n                -1 < (b -= 3) && f.push(239, 191, 189);\n                e = c;\n                continue;\n            }\n            c = (e - 55296 << 10 | c - 56320) + 65536;\n        }\n        else\n            e && -1 < (b -= 3) && f.push(239, 191, 189);\n        e = null;\n        if (128 > c) {\n            if (0 > --b)\n                break;\n            f.push(c);\n        }\n        else if (2048 > c) {\n            if (0 > (b -= 2))\n                break;\n            f.push(c >> 6 | 192, c & 63 | 128);\n        }\n        else if (65536 > c) {\n            if (0 > (b -= 3))\n                break;\n            f.push(c >> 12 | 224, c >> 6 & 63 | 128, c & 63 | 128);\n        }\n        else if (1114112 > c) {\n            if (0 > (b -= 4))\n                break;\n            f.push(c >> 18 | 240, c >> 12 & 63 | 128, c >> 6 & 63 | 128, c & 63 | 128);\n        }\n        else\n            throw Error(\"Invalid code point\");\n    }\n    return f;\n}\nfunction Ka(a) { for (var b = [], c = 0; c < a.length; ++c)\n    b.push(a.charCodeAt(c) & 255); return b; }\nfunction Ea(a) {\n    a = (a.trim ? a.trim() : a.replace(/^\\s+|\\s+$/g, \"\")).replace(Pa, \"\");\n    if (2 > a.length)\n        a = \"\";\n    else\n        for (; 0 !== a.length % 4;)\n            a += \"=\";\n    la || ma();\n    var b = a.length;\n    if (0 < b % 4)\n        throw Error(\"Invalid string. Length must be a multiple of 4\");\n    var c = \"=\" === a[b - 2] ? 2 : \"=\" === a[b - 1] ? 1 : 0;\n    var d = new ka(3 * b / 4 - c);\n    var e = 0 < c ? b - 4 : b;\n    var f = 0;\n    for (b = 0; b < e; b += 4) {\n        var g = u[a.charCodeAt(b)] << 18 | u[a.charCodeAt(b + 1)] << 12 | u[a.charCodeAt(b + 2)] << 6 | u[a.charCodeAt(b + 3)];\n        d[f++] = g >> 16 & 255;\n        d[f++] = g >> 8 & 255;\n        d[f++] = g & 255;\n    }\n    2 === c ? (g = u[a.charCodeAt(b)] << 2 |\n        u[a.charCodeAt(b + 1)] >> 4, d[f++] = g & 255) : 1 === c && (g = u[a.charCodeAt(b)] << 10 | u[a.charCodeAt(b + 1)] << 4 | u[a.charCodeAt(b + 2)] >> 2, d[f++] = g >> 8 & 255, d[f++] = g & 255);\n    return d;\n}\nfunction Ja(a, b, c, d) { for (var e = 0; e < d && !(e + c >= b.length || e >= a.length); ++e)\n    b[e + c] = a[e]; return e; }\nfunction Ca(a) { return null != a && (!!a._isBuffer || Qa(a) || \"function\" === typeof a.readFloatLE && \"function\" === typeof a.slice && Qa(a.slice(0, 0))); }\nfunction Qa(a) { return !!a.constructor && \"function\" === typeof a.constructor.isBuffer && a.constructor.isBuffer(a); }\nvar Ra = Object.freeze({ __proto__: null, INSPECT_MAX_BYTES: 50, kMaxLength: ta, Buffer: v, SlowBuffer: function (a) { +a != a && (a = 0); return v.alloc(+a); }, isBuffer: Ca }), E = v, Sa = \"undefined\" !== typeof globalThis ? globalThis : \"undefined\" !== typeof window ? window : \"undefined\" !== typeof global ? global : \"undefined\" !== typeof self ? self : {};\nfunction Ta(a, b) { return b = { exports: {} }, a(b, b.exports), b.exports; }\nfunction Ua() { throw Error(\"setTimeout has not been defined\"); }\nfunction Va() { throw Error(\"clearTimeout has not been defined\"); }\nvar F = Ua, G = Va;\n\"function\" === typeof ja.setTimeout && (F = setTimeout);\n\"function\" === typeof ja.clearTimeout && (G = clearTimeout);\nfunction Wa(a) { if (F === setTimeout)\n    return setTimeout(a, 0); if ((F === Ua || !F) && setTimeout)\n    return F = setTimeout, setTimeout(a, 0); try {\n    return F(a, 0);\n}\ncatch (b) {\n    try {\n        return F.call(null, a, 0);\n    }\n    catch (c) {\n        return F.call(this, a, 0);\n    }\n} }\nfunction Xa(a) { if (G === clearTimeout)\n    return clearTimeout(a); if ((G === Va || !G) && clearTimeout)\n    return G = clearTimeout, clearTimeout(a); try {\n    return G(a);\n}\ncatch (b) {\n    try {\n        return G.call(null, a);\n    }\n    catch (c) {\n        return G.call(this, a);\n    }\n} }\nvar H = [], I = !1, J, Ya = -1;\nfunction Za() { I && J && (I = !1, J.length ? H = J.concat(H) : Ya = -1, H.length && $a()); }\nfunction $a() { if (!I) {\n    var a = Wa(Za);\n    I = !0;\n    for (var b = H.length; b;) {\n        J = H;\n        for (H = []; ++Ya < b;)\n            J && J[Ya].run();\n        Ya = -1;\n        b = H.length;\n    }\n    J = null;\n    I = !1;\n    Xa(a);\n} }\nfunction ab(a) { var b = Array(arguments.length - 1); if (1 < arguments.length)\n    for (var c = 1; c < arguments.length; c++)\n        b[c - 1] = arguments[c]; H.push(new bb(a, b)); 1 !== H.length || I || Wa($a); }\nfunction bb(a, b) { this.fun = a; this.array = b; }\nbb.prototype.run = function () { this.fun.apply(null, this.array); };\nfunction K() { }\nvar L = ja.performance || {}, cb = L.now || L.mozNow || L.msNow || L.oNow || L.webkitNow || function () { return (new Date).getTime(); }, db = new Date, eb = { nextTick: ab, title: \"browser\", browser: !0, env: {}, argv: [], version: \"\", versions: {}, on: K, addListener: K, once: K, off: K, removeListener: K, removeAllListeners: K, emit: K, binding: function () { throw Error(\"process.binding is not supported\"); }, cwd: function () { return \"/\"; }, chdir: function () { throw Error(\"process.chdir is not supported\"); }, umask: function () { return 0; }, hrtime: function (a) {\n        var b = .001 *\n            cb.call(L), c = Math.floor(b);\n        b = Math.floor(b % 1 * 1E9);\n        a && (c -= a[0], b -= a[1], 0 > b && (c--, b += 1E9));\n        return [c, b];\n    }, platform: \"browser\", release: {}, config: {}, uptime: function () { return (new Date - db) / 1E3; } }, fb = Ta(function (a, b) {\n    function c(a, b) { for (var c in a)\n        b[c] = a[c]; }\n    function d(a, b, c) { return e(a, b, c); }\n    var e = Ra.Buffer;\n    e.from && e.alloc && e.allocUnsafe && e.allocUnsafeSlow ? a.exports = Ra : (c(Ra, b), b.Buffer = d);\n    d.prototype = Object.create(e.prototype);\n    c(e, d);\n    d.from = function (a, b, c) {\n        if (\"number\" === typeof a)\n            throw new TypeError(\"Argument must not be a number\");\n        return e(a, b, c);\n    };\n    d.alloc = function (a, b, c) { if (\"number\" !== typeof a)\n        throw new TypeError(\"Argument must be a number\"); a = e(a); void 0 !== b ? \"string\" === typeof c ? a.fill(b, c) : a.fill(b) : a.fill(0); return a; };\n    d.allocUnsafe = function (a) { if (\"number\" !== typeof a)\n        throw new TypeError(\"Argument must be a number\"); return e(a); };\n    d.allocUnsafeSlow = function (a) { if (\"number\" !== typeof a)\n        throw new TypeError(\"Argument must be a number\"); return Ra.SlowBuffer(a); };\n}), gb = Ta(function (a, b) {\n    function c() {\n        throw Error(\"secure random number generation not supported by this browser\\nuse chrome, FireFox or Internet Explorer 11\");\n    }\n    function d(a, b) { if (\"number\" !== typeof a || a !== a)\n        throw new TypeError(\"offset must be a number\"); if (a > p || 0 > a)\n        throw new TypeError(\"offset must be a uint32\"); if (a > n || a > b)\n        throw new RangeError(\"offset out of range\"); }\n    function e(a, b, c) { if (\"number\" !== typeof a || a !== a)\n        throw new TypeError(\"size must be a number\"); if (a > p || 0 > a)\n        throw new TypeError(\"size must be a uint32\"); if (a + b > c || a > n)\n        throw new RangeError(\"buffer too small\"); }\n    function f(a, b, c, f) {\n        if (!(l.isBuffer(a) || a instanceof Sa.Uint8Array))\n            throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array');\n        if (\"function\" === typeof b)\n            f = b, b = 0, c = a.length;\n        else if (\"function\" === typeof c)\n            f = c, c = a.length - b;\n        else if (\"function\" !== typeof f)\n            throw new TypeError('\"cb\" argument must be a function');\n        d(b, a.length);\n        e(c, b, a.length);\n        return g(a, b, c, f);\n    }\n    function g(a, b, c, d) { b = new Uint8Array(a.buffer, b, c); r.getRandomValues(b); if (d)\n        ab(function () { d(null, a); });\n    else\n        return a; }\n    function h(a, b, c) {\n        \"undefined\" === typeof b && (b = 0);\n        if (!(l.isBuffer(a) || a instanceof Sa.Uint8Array))\n            throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array');\n        d(b, a.length);\n        void 0 === c && (c = a.length - b);\n        e(c, b, a.length);\n        return g(a, b, c);\n    }\n    var l = fb.Buffer, n = fb.kMaxLength, r = Sa.crypto || Sa.msCrypto, p = Math.pow(2, 32) - 1;\n    r && r.getRandomValues ? (b.randomFill = f, b.randomFillSync = h) : (b.randomFill = c, b.randomFillSync = c);\n}), hb = Ta(function (a) { a.exports = gb; }).randomFillSync, ib = Math.floor(.001 * (Date.now() - performance.now()));\nfunction M(a) { if (\"string\" !== typeof a)\n    throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(a)); }\nfunction jb(a, b) {\n    for (var c = \"\", d = 0, e = -1, f = 0, g, h = 0; h <= a.length; ++h) {\n        if (h < a.length)\n            g = a.charCodeAt(h);\n        else if (47 === g)\n            break;\n        else\n            g = 47;\n        if (47 === g) {\n            if (e !== h - 1 && 1 !== f)\n                if (e !== h - 1 && 2 === f) {\n                    if (2 > c.length || 2 !== d || 46 !== c.charCodeAt(c.length - 1) || 46 !== c.charCodeAt(c.length - 2))\n                        if (2 < c.length) {\n                            if (e = c.lastIndexOf(\"/\"), e !== c.length - 1) {\n                                -1 === e ? (c = \"\", d = 0) : (c = c.slice(0, e), d = c.length - 1 - c.lastIndexOf(\"/\"));\n                                e = h;\n                                f = 0;\n                                continue;\n                            }\n                        }\n                        else if (2 === c.length || 1 === c.length) {\n                            c = \"\";\n                            d = 0;\n                            e = h;\n                            f = 0;\n                            continue;\n                        }\n                    b && (c = 0 < c.length ? c + \"/..\" : \"..\", d = 2);\n                }\n                else\n                    c =\n                        0 < c.length ? c + (\"/\" + a.slice(e + 1, h)) : a.slice(e + 1, h), d = h - e - 1;\n            e = h;\n            f = 0;\n        }\n        else\n            46 === g && -1 !== f ? ++f : f = -1;\n    }\n    return c;\n}\nvar kb = { resolve: function () { for (var a = \"\", b = !1, c, d = arguments.length - 1; -1 <= d && !b; d--) {\n        if (0 <= d)\n            var e = arguments[d];\n        else\n            void 0 === c && (c = eb.cwd()), e = c;\n        M(e);\n        0 !== e.length && (a = e + \"/\" + a, b = 47 === e.charCodeAt(0));\n    } a = jb(a, !b); return b ? 0 < a.length ? \"/\" + a : \"/\" : 0 < a.length ? a : \".\"; }, normalize: function (a) { M(a); if (0 === a.length)\n        return \".\"; var b = 47 === a.charCodeAt(0), c = 47 === a.charCodeAt(a.length - 1); a = jb(a, !b); 0 !== a.length || b || (a = \".\"); 0 < a.length && c && (a += \"/\"); return b ? \"/\" + a : a; }, isAbsolute: function (a) { M(a); return 0 < a.length && 47 === a.charCodeAt(0); },\n    join: function () { if (0 === arguments.length)\n        return \".\"; for (var a, b = 0; b < arguments.length; ++b) {\n        var c = arguments[b];\n        M(c);\n        0 < c.length && (a = void 0 === a ? c : a + (\"/\" + c));\n    } return void 0 === a ? \".\" : kb.normalize(a); }, relative: function (a, b) {\n        M(a);\n        M(b);\n        if (a === b)\n            return \"\";\n        a = kb.resolve(a);\n        b = kb.resolve(b);\n        if (a === b)\n            return \"\";\n        for (var c = 1; c < a.length && 47 === a.charCodeAt(c); ++c)\n            ;\n        for (var d = a.length, e = d - c, f = 1; f < b.length && 47 === b.charCodeAt(f); ++f)\n            ;\n        for (var g = b.length - f, h = e < g ? e : g, l = -1, n = 0; n <= h; ++n) {\n            if (n === h) {\n                if (g > h) {\n                    if (47 === b.charCodeAt(f + n))\n                        return b.slice(f +\n                            n + 1);\n                    if (0 === n)\n                        return b.slice(f + n);\n                }\n                else\n                    e > h && (47 === a.charCodeAt(c + n) ? l = n : 0 === n && (l = 0));\n                break;\n            }\n            var r = a.charCodeAt(c + n), p = b.charCodeAt(f + n);\n            if (r !== p)\n                break;\n            else\n                47 === r && (l = n);\n        }\n        e = \"\";\n        for (n = c + l + 1; n <= d; ++n)\n            if (n === d || 47 === a.charCodeAt(n))\n                e = 0 === e.length ? e + \"..\" : e + \"/..\";\n        if (0 < e.length)\n            return e + b.slice(f + l);\n        f += l;\n        47 === b.charCodeAt(f) && ++f;\n        return b.slice(f);\n    }, _makeLong: function (a) { return a; }, dirname: function (a) {\n        M(a);\n        if (0 === a.length)\n            return \".\";\n        for (var b = a.charCodeAt(0), c = 47 === b, d = -1, e = !0, f = a.length - 1; 1 <= f; --f)\n            if (b = a.charCodeAt(f),\n                47 === b) {\n                if (!e) {\n                    d = f;\n                    break;\n                }\n            }\n            else\n                e = !1;\n        return -1 === d ? c ? \"/\" : \".\" : c && 1 === d ? \"//\" : a.slice(0, d);\n    }, basename: function (a, b) {\n        if (void 0 !== b && \"string\" !== typeof b)\n            throw new TypeError('\"ext\" argument must be a string');\n        M(a);\n        var c = 0, d = -1, e = !0, f;\n        if (void 0 !== b && 0 < b.length && b.length <= a.length) {\n            if (b.length === a.length && b === a)\n                return \"\";\n            var g = b.length - 1, h = -1;\n            for (f = a.length - 1; 0 <= f; --f) {\n                var l = a.charCodeAt(f);\n                if (47 === l) {\n                    if (!e) {\n                        c = f + 1;\n                        break;\n                    }\n                }\n                else\n                    -1 === h && (e = !1, h = f + 1), 0 <= g && (l === b.charCodeAt(g) ? -1 === --g && (d = f) : (g = -1, d = h));\n            }\n            c === d ? d =\n                h : -1 === d && (d = a.length);\n            return a.slice(c, d);\n        }\n        for (f = a.length - 1; 0 <= f; --f)\n            if (47 === a.charCodeAt(f)) {\n                if (!e) {\n                    c = f + 1;\n                    break;\n                }\n            }\n            else\n                -1 === d && (e = !1, d = f + 1);\n        return -1 === d ? \"\" : a.slice(c, d);\n    }, extname: function (a) { M(a); for (var b = -1, c = 0, d = -1, e = !0, f = 0, g = a.length - 1; 0 <= g; --g) {\n        var h = a.charCodeAt(g);\n        if (47 === h) {\n            if (!e) {\n                c = g + 1;\n                break;\n            }\n        }\n        else\n            -1 === d && (e = !1, d = g + 1), 46 === h ? -1 === b ? b = g : 1 !== f && (f = 1) : -1 !== b && (f = -1);\n    } return -1 === b || -1 === d || 0 === f || 1 === f && b === d - 1 && b === c + 1 ? \"\" : a.slice(b, d); }, format: function (a) {\n        if (null === a || \"object\" !== typeof a)\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' +\n                typeof a);\n        var b = a.dir || a.root, c = a.base || (a.name || \"\") + (a.ext || \"\");\n        a = b ? b === a.root ? b + c : b + \"/\" + c : c;\n        return a;\n    }, parse: function (a) {\n        M(a);\n        var b = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n        if (0 === a.length)\n            return b;\n        var c = a.charCodeAt(0), d = 47 === c;\n        if (d) {\n            b.root = \"/\";\n            var e = 1;\n        }\n        else\n            e = 0;\n        for (var f = -1, g = 0, h = -1, l = !0, n = a.length - 1, r = 0; n >= e; --n)\n            if (c = a.charCodeAt(n), 47 === c) {\n                if (!l) {\n                    g = n + 1;\n                    break;\n                }\n            }\n            else\n                -1 === h && (l = !1, h = n + 1), 46 === c ? -1 === f ? f = n : 1 !== r && (r = 1) : -1 !== f && (r = -1);\n        -1 === f || -1 === h || 0 === r || 1 === r && f === h - 1 && f === g + 1 ? -1 !== h && (b.base = 0 ===\n            g && d ? b.name = a.slice(1, h) : b.name = a.slice(g, h)) : (0 === g && d ? (b.name = a.slice(1, f), b.base = a.slice(1, h)) : (b.name = a.slice(g, f), b.base = a.slice(g, h)), b.ext = a.slice(f, h));\n        0 < g ? b.dir = a.slice(0, g - 1) : d && (b.dir = \"/\");\n        return b;\n    }, sep: \"/\", delimiter: \":\", win32: null, posix: null }, lb = kb.posix = kb, mb = Object.freeze({ __proto__: null, \"default\": lb, __moduleExports: lb }), pb = { hrtime: function (a) { return function (b) { b = a(b); return 1E9 * b[0] + b[1]; }; }(function (a) {\n        var b = .001 * performance.now(), c = Math.floor(b) + ib;\n        b = Math.floor(b % 1 * 1E9);\n        a && (c -= a[0],\n            b -= a[1], 0 > b && (c--, b += 1E9));\n        return [c, b];\n    }), exit: function (a) { throw new nb(a); }, kill: function (a) { throw new ob(a); }, randomFillSync: hb, isTTY: function () { return !0; }, path: mb, fs: null }, N, O = k(1), P = k(2), Q = k(4), R = k(8), S = k(16), qb = k(32), T = k(64), V = k(128), sb = k(256), tb = k(512), ub = k(1024), vb = k(2048), wb = k(4096), xb = k(8192), yb = k(16384), zb = k(32768), Ab = k(65536), Bb = k(131072), Cb = k(262144), Db = k(524288), Eb = k(1048576), W = k(2097152), Ib = k(4194304), Jb = k(8388608), Kb = k(16777216), Lb = k(33554432), Mb = k(67108864), X = k(134217728), Nb = k(268435456), Ob = O | P | Q | R | S | qb | T | V | sb | tb | ub | vb | wb | xb | yb | zb | Ab | Bb | Cb | Db | Eb | W | Jb | Ib | Kb | Mb | Lb | X | Nb, Pb = O | P | Q | R | S | qb | T | V | sb | W | Ib | Jb | X, Qb = k(0), Rb = R | S | V | tb | ub | vb | wb | xb | yb | zb | Ab | Bb | Cb | Db | Eb | W | Jb | Kb | Mb | Lb | X, Sb = Rb | Pb, Tb = P | R | T | W | X | Nb, Ub = P | R | T | W | X, Vb = k(0), Wb = { E2BIG: 1, EACCES: 2, EADDRINUSE: 3, EADDRNOTAVAIL: 4, EAFNOSUPPORT: 5, EALREADY: 7, EAGAIN: 6, EBADF: 8, EBADMSG: 9, EBUSY: 10, ECANCELED: 11, ECHILD: 12, ECONNABORTED: 13, ECONNREFUSED: 14, ECONNRESET: 15, EDEADLOCK: 16, EDESTADDRREQ: 17, EDOM: 18, EDQUOT: 19, EEXIST: 20, EFAULT: 21, EFBIG: 22, EHOSTDOWN: 23, EHOSTUNREACH: 23,\n    EIDRM: 24, EILSEQ: 25, EINPROGRESS: 26, EINTR: 27, EINVAL: 28, EIO: 29, EISCONN: 30, EISDIR: 31, ELOOP: 32, EMFILE: 33, EMLINK: 34, EMSGSIZE: 35, EMULTIHOP: 36, ENAMETOOLONG: 37, ENETDOWN: 38, ENETRESET: 39, ENETUNREACH: 40, ENFILE: 41, ENOBUFS: 42, ENODEV: 43, ENOENT: 44, ENOEXEC: 45, ENOLCK: 46, ENOLINK: 47, ENOMEM: 48, ENOMSG: 49, ENOPROTOOPT: 50, ENOSPC: 51, ENOSYS: 52, ENOTCONN: 53, ENOTDIR: 54, ENOTEMPTY: 55, ENOTRECOVERABLE: 56, ENOTSOCK: 57, ENOTTY: 59, ENXIO: 60, EOVERFLOW: 61, EOWNERDEAD: 62, EPERM: 63, EPIPE: 64, EPROTO: 65, EPROTONOSUPPORT: 66, EPROTOTYPE: 67, ERANGE: 68,\n    EROFS: 69, ESPIPE: 70, ESRCH: 71, ESTALE: 72, ETIMEDOUT: 73, ETXTBSY: 74, EXDEV: 75 }, Xb = (N = {}, N[6] = \"SIGHUP\", N[8] = \"SIGINT\", N[11] = \"SIGQUIT\", N[7] = \"SIGILL\", N[15] = \"SIGTRAP\", N[0] = \"SIGABRT\", N[2] = \"SIGBUS\", N[5] = \"SIGFPE\", N[9] = \"SIGKILL\", N[20] = \"SIGUSR1\", N[12] = \"SIGSEGV\", N[21] = \"SIGUSR2\", N[10] = \"SIGPIPE\", N[1] = \"SIGALRM\", N[14] = \"SIGTERM\", N[3] = \"SIGCHLD\", N[4] = \"SIGCONT\", N[13] = \"SIGSTOP\", N[16] = \"SIGTSTP\", N[17] = \"SIGTTIN\", N[18] = \"SIGTTOU\", N[19] = \"SIGURG\", N[23] = \"SIGXCPU\", N[24] = \"SIGXFSZ\", N[22] = \"SIGVTALRM\", N), Yb = O | P | S | V | W | X, Zb = O | T | S | V | W | X;\nfunction Y(a) { var b = Math.trunc(a); a = k(Math.round(1E6 * (a - b))); return k(b) * k(1E6) + a; }\nfunction $b(a) { \"number\" === typeof a && (a = Math.trunc(a)); a = k(a); return Number(a / k(1E6)); }\nfunction Z(a) { return function () { for (var b = [], c = 0; c < arguments.length; c++)\n    b[c] = arguments[c]; try {\n    return a.apply(void 0, fa(b));\n}\ncatch (d) {\n    if (d && d.code && \"string\" === typeof d.code)\n        return Wb[d.code] || 28;\n    if (d instanceof ac)\n        return d.errno;\n    throw d;\n} }; }\nfunction bc(a, b) { var c = a.FD_MAP.get(b); if (!c)\n    throw new ac(8); if (void 0 === c.filetype) {\n    var d = a.bindings.fs.fstatSync(c.real);\n    a = cc(a, b, d);\n    b = a.rightsBase;\n    d = a.rightsInheriting;\n    c.filetype = a.filetype;\n    c.rights || (c.rights = { base: b, inheriting: d });\n} return c; }\nfunction cc(a, b, c) {\n    switch (!0) {\n        case c.isBlockDevice(): return { filetype: 1, rightsBase: Ob, rightsInheriting: Ob };\n        case c.isCharacterDevice(): return void 0 !== b && a.bindings.isTTY(b) ? { filetype: 2, rightsBase: Ub, rightsInheriting: Vb } : { filetype: 2, rightsBase: Ob, rightsInheriting: Ob };\n        case c.isDirectory(): return { filetype: 3, rightsBase: Rb, rightsInheriting: Sb };\n        case c.isFIFO(): return { filetype: 6, rightsBase: Tb, rightsInheriting: Ob };\n        case c.isFile(): return { filetype: 4, rightsBase: Pb, rightsInheriting: Qb };\n        case c.isSocket(): return { filetype: 6,\n            rightsBase: Tb, rightsInheriting: Ob };\n        case c.isSymbolicLink(): return { filetype: 7, rightsBase: k(0), rightsInheriting: k(0) };\n        default: return { filetype: 0, rightsBase: k(0), rightsInheriting: k(0) };\n    }\n}\nvar ac = function (a) { function b(c) { var d = a.call(this) || this; d.errno = c; Object.setPrototypeOf(d, b.prototype); return d; } ba(b, a); return b; }(Error), nb = function (a) { function b(c) { var d = a.call(this, \"WASI Exit error: \" + c) || this; d.code = c; Object.setPrototypeOf(d, b.prototype); return d; } ba(b, a); return b; }(Error), ob = function (a) { function b(c) { var d = a.call(this, \"WASI Kill signal: \" + c) || this; d.signal = c; Object.setPrototypeOf(d, b.prototype); return d; } ba(b, a); return b; }(Error), dc = function () {\n    function a(a) {\n        function b(a) {\n            switch (a) {\n                case 1: return r.hrtime();\n                case 0: return Y(Date.now());\n                case 2:\n                case 3: return r.hrtime() - ec;\n                default: return null;\n            }\n        }\n        function d(a, b) { a = bc(g, a); if (b !== k(0) && (a.rights.base & b) === k(0))\n            throw new ac(63); return a; }\n        function e(a, b) { g.refreshMemory(); return Array.from({ length: b }, function (b, c) { c = a + 8 * c; b = g.view.getUint32(c, !0); c = g.view.getUint32(c + 4, !0); return new Uint8Array(g.memory.buffer, b, c); }); }\n        var f, g = this, h = {};\n        a && a.preopens ? h = a.preopens : a && a.preopenDirectories && (h = a.preopenDirectories);\n        var l = {};\n        a && a.env && (l = a.env);\n        var n = [];\n        a && a.args && (n =\n            a.args);\n        var r = pb;\n        a && a.bindings && (r = a.bindings);\n        this.view = this.memory = void 0;\n        this.bindings = r;\n        this.FD_MAP = new Map([[0, { real: 0, filetype: 2, rights: { base: Yb, inheriting: k(0) }, path: void 0 }], [1, { real: 1, filetype: 2, rights: { base: Zb, inheriting: k(0) }, path: void 0 }], [2, { real: 2, filetype: 2, rights: { base: Zb, inheriting: k(0) }, path: void 0 }]]);\n        var p = this.bindings.fs, y = this.bindings.path;\n        try {\n            for (var ua = ca(Object.entries(h)), ea = ua.next(); !ea.done; ea = ua.next()) {\n                var rb = da(ea.value, 2), fc = rb[0], Fb = rb[1], gc = p.openSync(Fb, p.constants.O_RDONLY), hc = fa(this.FD_MAP.keys()).reverse()[0] + 1;\n                this.FD_MAP.set(hc, { real: gc, filetype: 3, rights: { base: Rb, inheriting: Sb }, fakePath: fc, path: Fb });\n            }\n        }\n        catch (t) {\n            var Gb = { error: t };\n        }\n        finally {\n            try {\n                ea && !ea.done && (f = ua.return) && f.call(ua);\n            }\n            finally {\n                if (Gb)\n                    throw Gb.error;\n            }\n        }\n        var ec = r.hrtime();\n        this.wasiImport = { args_get: function (a, b) { g.refreshMemory(); var c = a, d = b; n.forEach(function (a) { g.view.setUint32(c, d, !0); c += 4; d += E.from(g.memory.buffer).write(a + \"\\x00\", d); }); return 0; }, args_sizes_get: function (a, b) {\n                g.refreshMemory();\n                g.view.setUint32(a, n.length, !0);\n                a = n.reduce(function (a, b) { return a + E.byteLength(b) + 1; }, 0);\n                g.view.setUint32(b, a, !0);\n                return 0;\n            }, environ_get: function (a, b) { g.refreshMemory(); var c = a, d = b; Object.entries(l).forEach(function (a) { var b = da(a, 2); a = b[0]; b = b[1]; g.view.setUint32(c, d, !0); c += 4; d += E.from(g.memory.buffer).write(a + \"=\" + b + \"\\x00\", d); }); return 0; }, environ_sizes_get: function (a, b) {\n                g.refreshMemory();\n                var c = Object.entries(l).map(function (a) { a = da(a, 2); return a[0] + \"=\" + a[1] + \"\\x00\"; }), d = c.reduce(function (a, b) { return a + E.byteLength(b); }, 0);\n                g.view.setUint32(a, c.length, !0);\n                g.view.setUint32(b, d, !0);\n                return 0;\n            }, clock_res_get: function (a, b) { switch (a) {\n                case 1:\n                case 2:\n                case 3:\n                    var c = k(1);\n                    break;\n                case 0: c = k(1E3);\n            } g.view.setBigUint64(b, c); return 0; }, clock_time_get: function (a, c, d) { g.refreshMemory(); a = b(a); if (null === a)\n                return 28; g.view.setBigUint64(d, k(a), !0); return 0; }, fd_advise: Z(function (a) { d(a, V); return 52; }), fd_allocate: Z(function (a) { d(a, sb); return 52; }), fd_close: Z(function (a) { var b = d(a, k(0)); p.closeSync(b.real); g.FD_MAP.delete(a); return 0; }), fd_datasync: Z(function (a) {\n                a =\n                    d(a, O);\n                p.fdatasyncSync(a.real);\n                return 0;\n            }), fd_fdstat_get: Z(function (a, b) { a = d(a, k(0)); g.refreshMemory(); g.view.setUint8(b, a.filetype); g.view.setUint16(b + 2, 0, !0); g.view.setUint16(b + 4, 0, !0); g.view.setBigUint64(b + 8, k(a.rights.base), !0); g.view.setBigUint64(b + 8 + 8, k(a.rights.inheriting), !0); return 0; }), fd_fdstat_set_flags: Z(function (a) { d(a, R); return 52; }), fd_fdstat_set_rights: Z(function (a, b, c) {\n                a = d(a, k(0));\n                if ((a.rights.base | b) > a.rights.base || (a.rights.inheriting | c) > a.rights.inheriting)\n                    return 63;\n                a.rights.base =\n                    b;\n                a.rights.inheriting = c;\n                return 0;\n            }), fd_filestat_get: Z(function (a, b) { a = d(a, W); var c = p.fstatSync(a.real); g.refreshMemory(); g.view.setBigUint64(b, k(c.dev), !0); b += 8; g.view.setBigUint64(b, k(c.ino), !0); b += 8; g.view.setUint8(b, a.filetype); b += 8; g.view.setBigUint64(b, k(c.nlink), !0); b += 8; g.view.setBigUint64(b, k(c.size), !0); b += 8; g.view.setBigUint64(b, Y(c.atimeMs), !0); b += 8; g.view.setBigUint64(b, Y(c.mtimeMs), !0); g.view.setBigUint64(b + 8, Y(c.ctimeMs), !0); return 0; }), fd_filestat_set_size: Z(function (a, b) {\n                a = d(a, Ib);\n                p.ftruncateSync(a.real, Number(b));\n                return 0;\n            }), fd_filestat_set_times: Z(function (a, c, e, g) { a = d(a, Jb); var f = p.fstatSync(a.real), t = f.atime; f = f.mtime; var q = $b(b(0)); if (3 === (g & 3) || 12 === (g & 12))\n                return 28; 1 === (g & 1) ? t = $b(c) : 2 === (g & 2) && (t = q); 4 === (g & 4) ? f = $b(e) : 8 === (g & 8) && (f = q); p.futimesSync(a.real, new Date(t), new Date(f)); return 0; }), fd_prestat_get: Z(function (a, b) { a = d(a, k(0)); if (!a.path)\n                return 28; g.refreshMemory(); g.view.setUint8(b, 0); g.view.setUint32(b + 4, E.byteLength(a.fakePath), !0); return 0; }), fd_prestat_dir_name: Z(function (a, b, c) {\n                a =\n                    d(a, k(0));\n                if (!a.path)\n                    return 28;\n                g.refreshMemory();\n                E.from(g.memory.buffer).write(a.fakePath, b, c, \"utf8\");\n                return 0;\n            }), fd_pwrite: Z(function (a, b, c, f, h) { var t = d(a, T | Q), q = 0; e(b, c).forEach(function (a) { for (var b = 0; b < a.byteLength;)\n                b += p.writeSync(t.real, a, b, a.byteLength - b, Number(f) + q + b); q += b; }); g.view.setUint32(h, q, !0); return 0; }), fd_write: Z(function (a, b, c, f) {\n                var t = d(a, T), q = 0;\n                e(b, c).forEach(function (a) {\n                    for (var b = 0; b < a.byteLength;) {\n                        var c = p.writeSync(t.real, a, b, a.byteLength - b, t.offset ? Number(t.offset) : null);\n                        t.offset &&\n                            (t.offset += k(c));\n                        b += c;\n                    }\n                    q += b;\n                });\n                g.view.setUint32(f, q, !0);\n                return 0;\n            }), fd_pread: Z(function (a, b, c, f, h) { var t; a = d(a, P | Q); var q = 0; try {\n                var x = ca(e(b, c)), l = x.next();\n                a: for (; !l.done; l = x.next()) {\n                    var n = l.value;\n                    for (b = 0; b < n.byteLength;) {\n                        var ic = n.byteLength - b, B = p.readSync(a.real, n, b, n.byteLength - b, Number(f) + q + b);\n                        b += B;\n                        q += B;\n                        if (0 === B || B < ic)\n                            break a;\n                    }\n                    q += b;\n                }\n            }\n            catch (U) {\n                var r = { error: U };\n            }\n            finally {\n                try {\n                    l && !l.done && (t = x.return) && t.call(x);\n                }\n                finally {\n                    if (r)\n                        throw r.error;\n                }\n            } g.view.setUint32(h, q, !0); return 0; }), fd_read: Z(function (a, b, c, f) {\n                var t;\n                a = d(a, P);\n                var q = 0 === a.real, h = 0;\n                try {\n                    var x = ca(e(b, c)), l = x.next();\n                    a: for (; !l.done; l = x.next()) {\n                        var n = l.value;\n                        for (b = 0; b < n.byteLength;) {\n                            var B = n.byteLength - b, r = p.readSync(a.real, n, b, B, q || void 0 === a.offset ? null : Number(a.offset));\n                            q || (a.offset = (a.offset ? a.offset : k(0)) + k(r));\n                            b += r;\n                            h += r;\n                            if (0 === r || r < B)\n                                break a;\n                        }\n                    }\n                }\n                catch (U) {\n                    var y = { error: U };\n                }\n                finally {\n                    try {\n                        l && !l.done && (t = x.return) && t.call(x);\n                    }\n                    finally {\n                        if (y)\n                            throw y.error;\n                    }\n                }\n                g.view.setUint32(f, h, !0);\n                return 0;\n            }), fd_readdir: Z(function (a, b, c, e, f) {\n                a = d(a, yb);\n                g.refreshMemory();\n                var t = p.readdirSync(a.path, { withFileTypes: !0 }), q = b;\n                for (e = Number(e); e < t.length; e += 1) {\n                    var h = t[e], x = E.byteLength(h.name);\n                    if (b - q > c)\n                        break;\n                    g.view.setBigUint64(b, k(e + 1), !0);\n                    b += 8;\n                    if (b - q > c)\n                        break;\n                    var l = p.statSync(y.resolve(a.path, h.name));\n                    g.view.setBigUint64(b, k(l.ino), !0);\n                    b += 8;\n                    if (b - q > c)\n                        break;\n                    g.view.setUint32(b, x, !0);\n                    b += 4;\n                    if (b - q > c)\n                        break;\n                    switch (!0) {\n                        case l.isBlockDevice():\n                            l = 1;\n                            break;\n                        case l.isCharacterDevice():\n                            l = 2;\n                            break;\n                        case l.isDirectory():\n                            l = 3;\n                            break;\n                        case l.isFIFO():\n                            l = 6;\n                            break;\n                        case l.isFile():\n                            l = 4;\n                            break;\n                        case l.isSocket():\n                            l =\n                                6;\n                            break;\n                        case l.isSymbolicLink():\n                            l = 7;\n                            break;\n                        default: l = 0;\n                    }\n                    g.view.setUint8(b, l);\n                    b += 1;\n                    b += 3;\n                    if (b + x >= q + c)\n                        break;\n                    E.from(g.memory.buffer).write(h.name, b);\n                    b += x;\n                }\n                g.view.setUint32(f, Math.min(b - q, c), !0);\n                return 0;\n            }), fd_renumber: Z(function (a, b) { d(a, k(0)); d(b, k(0)); p.closeSync(g.FD_MAP.get(a).real); g.FD_MAP.set(a, g.FD_MAP.get(b)); g.FD_MAP.delete(b); return 0; }), fd_seek: Z(function (a, b, c, e) {\n                a = d(a, Q);\n                g.refreshMemory();\n                switch (c) {\n                    case 1:\n                        a.offset = (a.offset ? a.offset : k(0)) + k(b);\n                        break;\n                    case 2:\n                        c = p.fstatSync(a.real).size;\n                        a.offset =\n                            k(c) + k(b);\n                        break;\n                    case 0: a.offset = k(b);\n                }\n                g.view.setBigUint64(e, a.offset, !0);\n                return 0;\n            }), fd_tell: Z(function (a, b) { a = d(a, qb); g.refreshMemory(); a.offset || (a.offset = k(0)); g.view.setBigUint64(b, a.offset, !0); return 0; }), fd_sync: Z(function (a) { a = d(a, S); p.fsyncSync(a.real); return 0; }), path_create_directory: Z(function (a, b, c) { a = d(a, tb); if (!a.path)\n                return 28; g.refreshMemory(); b = E.from(g.memory.buffer, b, c).toString(); p.mkdirSync(y.resolve(a.path, b)); return 0; }), path_filestat_get: Z(function (a, b, c, e, f) {\n                a = d(a, Cb);\n                if (!a.path)\n                    return 28;\n                g.refreshMemory();\n                c = E.from(g.memory.buffer, c, e).toString();\n                c = p.statSync(y.resolve(a.path, c));\n                g.view.setBigUint64(f, k(c.dev), !0);\n                f += 8;\n                g.view.setBigUint64(f, k(c.ino), !0);\n                f += 8;\n                g.view.setUint8(f, cc(g, void 0, c).filetype);\n                f += 8;\n                g.view.setBigUint64(f, k(c.nlink), !0);\n                f += 8;\n                g.view.setBigUint64(f, k(c.size), !0);\n                f += 8;\n                g.view.setBigUint64(f, Y(c.atimeMs), !0);\n                f += 8;\n                g.view.setBigUint64(f, Y(c.mtimeMs), !0);\n                g.view.setBigUint64(f + 8, Y(c.ctimeMs), !0);\n                return 0;\n            }), path_filestat_set_times: Z(function (a, c, e, f, h, l, n) {\n                a = d(a, Eb);\n                if (!a.path)\n                    return 28;\n                g.refreshMemory();\n                var t = p.fstatSync(a.real);\n                c = t.atime;\n                t = t.mtime;\n                var q = $b(b(0));\n                if (3 === (n & 3) || 12 === (n & 12))\n                    return 28;\n                1 === (n & 1) ? c = $b(h) : 2 === (n & 2) && (c = q);\n                4 === (n & 4) ? t = $b(l) : 8 === (n & 8) && (t = q);\n                e = E.from(g.memory.buffer, e, f).toString();\n                p.utimesSync(y.resolve(a.path, e), new Date(c), new Date(t));\n                return 0;\n            }), path_link: Z(function (a, b, c, e, f, h, l) {\n                a = d(a, vb);\n                f = d(f, wb);\n                if (!a.path || !f.path)\n                    return 28;\n                g.refreshMemory();\n                c = E.from(g.memory.buffer, c, e).toString();\n                h = E.from(g.memory.buffer, h, l).toString();\n                p.linkSync(y.resolve(a.path, c), y.resolve(f.path, h));\n                return 0;\n            }), path_open: Z(function (a, b, c, e, f, h, l, n, r) {\n                b = d(a, xb);\n                h = k(h);\n                l = k(l);\n                a = (h & (P | yb)) !== k(0);\n                var t = (h & (O | T | sb | Ib)) !== k(0);\n                if (t && a)\n                    var q = p.constants.O_RDWR;\n                else\n                    a ? q = p.constants.O_RDONLY : t && (q = p.constants.O_WRONLY);\n                a = h | xb;\n                h |= l;\n                0 !== (f & 1) && (q |= p.constants.O_CREAT, a |= ub);\n                0 !== (f & 2) && (q |= p.constants.O_DIRECTORY);\n                0 !== (f & 4) && (q |= p.constants.O_EXCL);\n                0 !== (f & 8) && (q |= p.constants.O_TRUNC, a |= Db);\n                0 !== (n & 1) && (q |= p.constants.O_APPEND);\n                0 !== (n & 2) && (q = p.constants.O_DSYNC ? q | p.constants.O_DSYNC :\n                    q | p.constants.O_SYNC, h |= O);\n                0 !== (n & 4) && (q |= p.constants.O_NONBLOCK);\n                0 !== (n & 8) && (q = p.constants.O_RSYNC ? q | p.constants.O_RSYNC : q | p.constants.O_SYNC, h |= S);\n                0 !== (n & 16) && (q |= p.constants.O_SYNC, h |= S);\n                t && 0 === (q & (p.constants.O_APPEND | p.constants.O_TRUNC)) && (h |= Q);\n                g.refreshMemory();\n                c = E.from(g.memory.buffer, c, e).toString();\n                c = y.resolve(b.path, c);\n                if (y.relative(b.path, c).startsWith(\"..\"))\n                    return 76;\n                try {\n                    var x = p.realpathSync(c);\n                    if (y.relative(b.path, x).startsWith(\"..\"))\n                        return 76;\n                }\n                catch (U) {\n                    if (\"ENOENT\" === U.code)\n                        x = c;\n                    else\n                        throw U;\n                }\n                try {\n                    var B = p.statSync(x).isDirectory();\n                }\n                catch (U) { }\n                q = !t && B ? p.openSync(x, p.constants.O_RDONLY) : p.openSync(x, q);\n                B = fa(g.FD_MAP.keys()).reverse()[0] + 1;\n                g.FD_MAP.set(B, { real: q, filetype: void 0, rights: { base: a, inheriting: h }, path: x });\n                bc(g, B);\n                g.view.setUint32(r, B, !0);\n                return 0;\n            }), path_readlink: Z(function (a, b, c, e, f, h) { a = d(a, zb); if (!a.path)\n                return 28; g.refreshMemory(); b = E.from(g.memory.buffer, b, c).toString(); b = y.resolve(a.path, b); b = p.readlinkSync(b); e = E.from(g.memory.buffer).write(b, e, f); g.view.setUint32(h, e, !0); return 0; }),\n            path_remove_directory: Z(function (a, b, c) { a = d(a, Lb); if (!a.path)\n                return 28; g.refreshMemory(); b = E.from(g.memory.buffer, b, c).toString(); p.rmdirSync(y.resolve(a.path, b)); return 0; }), path_rename: Z(function (a, b, c, e, f, h) { a = d(a, Ab); e = d(e, Bb); if (!a.path || !e.path)\n                return 28; g.refreshMemory(); b = E.from(g.memory.buffer, b, c).toString(); f = E.from(g.memory.buffer, f, h).toString(); p.renameSync(y.resolve(a.path, b), y.resolve(e.path, f)); return 0; }), path_symlink: Z(function (a, b, c, e, f) {\n                c = d(c, Kb);\n                if (!c.path)\n                    return 28;\n                g.refreshMemory();\n                a = E.from(g.memory.buffer, a, b).toString();\n                e = E.from(g.memory.buffer, e, f).toString();\n                p.symlinkSync(a, y.resolve(c.path, e));\n                return 0;\n            }), path_unlink_file: Z(function (a, b, c) { a = d(a, Mb); if (!a.path)\n                return 28; g.refreshMemory(); b = E.from(g.memory.buffer, b, c).toString(); p.unlinkSync(y.resolve(a.path, b)); return 0; }), poll_oneoff: function (a, c, d, e) {\n                var f = 0, h = 0;\n                g.refreshMemory();\n                for (var l = 0; l < d; l += 1) {\n                    var n = g.view.getBigUint64(a, !0);\n                    a += 8;\n                    var p = g.view.getUint8(a);\n                    a += 1;\n                    switch (p) {\n                        case 0:\n                            a += 7;\n                            g.view.getBigUint64(a, !0);\n                            a += 8;\n                            var q = g.view.getUint32(a, !0);\n                            a += 4;\n                            a += 4;\n                            p = g.view.getBigUint64(a, !0);\n                            a += 8;\n                            g.view.getBigUint64(a, !0);\n                            a += 8;\n                            var t = g.view.getUint16(a, !0);\n                            a += 2;\n                            a += 6;\n                            var x = 1 === t;\n                            t = 0;\n                            q = k(b(q));\n                            null === q ? t = 28 : (p = x ? p : q + p, h = p > h ? p : h);\n                            g.view.setBigUint64(c, n, !0);\n                            c += 8;\n                            g.view.setUint16(c, t, !0);\n                            c += 2;\n                            g.view.setUint8(c, 0);\n                            c += 1;\n                            c += 5;\n                            f += 1;\n                            break;\n                        case 1:\n                        case 2:\n                            a += 3;\n                            g.view.getUint32(a, !0);\n                            a += 4;\n                            g.view.setBigUint64(c, n, !0);\n                            c += 8;\n                            g.view.setUint16(c, 52, !0);\n                            c += 2;\n                            g.view.setUint8(c, p);\n                            c += 1;\n                            c += 5;\n                            f += 1;\n                            break;\n                        default: return 28;\n                    }\n                }\n                for (g.view.setUint32(e, f, !0); r.hrtime() < h;)\n                    ;\n                return 0;\n            }, proc_exit: function (a) { r.exit(a); return 0; }, proc_raise: function (a) { if (!(a in Xb))\n                return 28; r.kill(Xb[a]); return 0; }, random_get: function (a, b) { g.refreshMemory(); r.randomFillSync(new Uint8Array(g.memory.buffer), a, b); return 0; }, sched_yield: function () { return 0; }, sock_recv: function () { return 52; }, sock_send: function () { return 52; }, sock_shutdown: function () { return 52; } };\n        a.traceSyscalls && Object.keys(this.wasiImport).forEach(function (a) {\n            var b = g.wasiImport[a];\n            g.wasiImport[a] = function () {\n                for (var c = [], d = 0; d < arguments.length; d++)\n                    c[d] = arguments[d];\n                console.log(\"WASI: wasiImport called: \" + a + \" (\" + c + \")\");\n                try {\n                    var e = b.apply(void 0, fa(c));\n                    console.log(\"WASI:  => \" + e);\n                    return e;\n                }\n                catch (Hb) {\n                    throw console.log(\"Catched error: \" + Hb), Hb;\n                }\n            };\n        });\n    }\n    a.prototype.refreshMemory = function () { this.view && 0 !== this.view.buffer.byteLength || (this.view = new ia(this.memory.buffer)); };\n    a.prototype.setMemory = function (a) { this.memory = a; };\n    a.prototype.start = function (a) {\n        a = a.exports;\n        if (null === a || \"object\" !== typeof a)\n            throw Error(\"instance.exports must be an Object. Received \" +\n                a + \".\");\n        var b = a.memory;\n        if (!(b instanceof WebAssembly.Memory))\n            throw Error(\"instance.exports.memory must be a WebAssembly.Memory. Recceived \" + b + \".\");\n        this.setMemory(b);\n        a._start && a._start();\n    };\n    a.prototype.getImportNamespace = function (a) {\n        var b, d = null;\n        try {\n            for (var e = ca(WebAssembly.Module.imports(a)), f = e.next(); !f.done; f = e.next()) {\n                var g = f.value;\n                if (\"function\" === g.kind && g.module.startsWith(\"wasi_\"))\n                    if (!d)\n                        d = g.module;\n                    else if (d !== g.module)\n                        throw Error(\"Multiple namespaces detected.\");\n            }\n        }\n        catch (l) {\n            var h = { error: l };\n        }\n        finally {\n            try {\n                f &&\n                    !f.done && (b = e.return) && b.call(e);\n            }\n            finally {\n                if (h)\n                    throw h.error;\n            }\n        }\n        return d;\n    };\n    a.prototype.getImports = function (a) { switch (this.getImportNamespace(a)) {\n        case \"wasi_unstable\": return { wasi_unstable: this.wasiImport };\n        case \"wasi_snapshot_preview1\": return { wasi_snapshot_preview1: this.wasiImport };\n        default: throw Error(\"Can't detect a WASI namespace for the WebAssembly Module\");\n    } };\n    a.defaultBindings = pb;\n    return a;\n}();\nexports.WASIError = ac;\nexports.WASIExitError = nb;\nexports.WASIKillError = ob;\nexports.WASI = dc;\nexports.default = dc;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/index.esm.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasi/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/* eslint-disable no-unused-vars */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bigint_1 = __webpack_require__(/*! ./polyfills/bigint */ \"./node_modules/@wasmer/wasi/lib/polyfills/bigint.js\");\nvar dataview_1 = __webpack_require__(/*! ./polyfills/dataview */ \"./node_modules/@wasmer/wasi/lib/polyfills/dataview.js\");\nvar buffer_1 = __webpack_require__(/*! ./polyfills/buffer */ \"./node_modules/@wasmer/wasi/lib/polyfills/buffer.js\");\n// Import our default bindings depending on the environment\nvar defaultBindings;\n/*ROLLUP_REPLACE_NODE\nimport nodeBindings from \"./bindings/node\";\ndefaultBindings = nodeBindings;\nROLLUP_REPLACE_NODE*/\n/*ROLLUP_REPLACE_BROWSER\nimport browserBindings from \"./bindings/browser\";\ndefaultBindings = browserBindings;\nROLLUP_REPLACE_BROWSER*/\n/*\n\nThis project is based from the Node implementation made by Gus Caplan\nhttps://github.com/devsnek/node-wasi\nHowever, JavaScript WASI is focused on:\n * Bringing WASI to the Browsers\n * Make easy to plug different filesystems\n * Provide a type-safe api using Typescript\n * Providing multiple output targets to support both browsers and node\n * The API is adapted to the Node-WASI API: https://github.com/nodejs/wasi/blob/wasi/lib/wasi.js\n\nCopyright 2019 Gus Caplan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\n */\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/@wasmer/wasi/lib/constants.js\");\nvar STDIN_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC |\n    constants_1.WASI_RIGHT_FD_READ |\n    constants_1.WASI_RIGHT_FD_SYNC |\n    constants_1.WASI_RIGHT_FD_ADVISE |\n    constants_1.WASI_RIGHT_FD_FILESTAT_GET |\n    constants_1.WASI_RIGHT_POLL_FD_READWRITE;\nvar STDOUT_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC |\n    constants_1.WASI_RIGHT_FD_WRITE |\n    constants_1.WASI_RIGHT_FD_SYNC |\n    constants_1.WASI_RIGHT_FD_ADVISE |\n    constants_1.WASI_RIGHT_FD_FILESTAT_GET |\n    constants_1.WASI_RIGHT_POLL_FD_READWRITE;\nvar STDERR_DEFAULT_RIGHTS = STDOUT_DEFAULT_RIGHTS;\nvar msToNs = function (ms) {\n    var msInt = Math.trunc(ms);\n    var decimal = bigint_1.BigIntPolyfill(Math.round((ms - msInt) * 1000000));\n    var ns = bigint_1.BigIntPolyfill(msInt) * bigint_1.BigIntPolyfill(1000000);\n    return ns + decimal;\n};\nvar nsToMs = function (ns) {\n    if (typeof ns === 'number') {\n        ns = Math.trunc(ns);\n    }\n    var nsInt = bigint_1.BigIntPolyfill(ns);\n    return Number(nsInt / bigint_1.BigIntPolyfill(1000000));\n};\nvar wrap = function (f) { return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    try {\n        return f.apply(void 0, args);\n    }\n    catch (e) {\n        // If it's an error from the fs\n        if (e && e.code && typeof e.code === \"string\") {\n            return constants_1.ERROR_MAP[e.code] || constants_1.WASI_EINVAL;\n        }\n        // If it's a WASI error, we return it directly\n        if (e instanceof WASIError) {\n            return e.errno;\n        }\n        // Otherwise we let the error bubble up\n        throw e;\n    }\n}; };\nvar stat = function (wasi, fd) {\n    var entry = wasi.FD_MAP.get(fd);\n    if (!entry) {\n        throw new WASIError(constants_1.WASI_EBADF);\n    }\n    if (entry.filetype === undefined) {\n        var stats = wasi.bindings.fs.fstatSync(entry.real);\n        var _a = translateFileAttributes(wasi, fd, stats), filetype = _a.filetype, rightsBase = _a.rightsBase, rightsInheriting = _a.rightsInheriting;\n        entry.filetype = filetype;\n        if (!entry.rights) {\n            entry.rights = {\n                base: rightsBase,\n                inheriting: rightsInheriting\n            };\n        }\n    }\n    return entry;\n};\nvar translateFileAttributes = function (wasi, fd, stats) {\n    switch (true) {\n        case stats.isBlockDevice():\n            return {\n                filetype: constants_1.WASI_FILETYPE_BLOCK_DEVICE,\n                rightsBase: constants_1.RIGHTS_BLOCK_DEVICE_BASE,\n                rightsInheriting: constants_1.RIGHTS_BLOCK_DEVICE_INHERITING\n            };\n        case stats.isCharacterDevice(): {\n            var filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n            if (fd !== undefined && wasi.bindings.isTTY(fd)) {\n                return {\n                    filetype: filetype,\n                    rightsBase: constants_1.RIGHTS_TTY_BASE,\n                    rightsInheriting: constants_1.RIGHTS_TTY_INHERITING\n                };\n            }\n            return {\n                filetype: filetype,\n                rightsBase: constants_1.RIGHTS_CHARACTER_DEVICE_BASE,\n                rightsInheriting: constants_1.RIGHTS_CHARACTER_DEVICE_INHERITING\n            };\n        }\n        case stats.isDirectory():\n            return {\n                filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n                rightsBase: constants_1.RIGHTS_DIRECTORY_BASE,\n                rightsInheriting: constants_1.RIGHTS_DIRECTORY_INHERITING\n            };\n        case stats.isFIFO():\n            return {\n                filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n                rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n                rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING\n            };\n        case stats.isFile():\n            return {\n                filetype: constants_1.WASI_FILETYPE_REGULAR_FILE,\n                rightsBase: constants_1.RIGHTS_REGULAR_FILE_BASE,\n                rightsInheriting: constants_1.RIGHTS_REGULAR_FILE_INHERITING\n            };\n        case stats.isSocket():\n            return {\n                filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n                rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n                rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING\n            };\n        case stats.isSymbolicLink():\n            return {\n                filetype: constants_1.WASI_FILETYPE_SYMBOLIC_LINK,\n                rightsBase: bigint_1.BigIntPolyfill(0),\n                rightsInheriting: bigint_1.BigIntPolyfill(0)\n            };\n        default:\n            return {\n                filetype: constants_1.WASI_FILETYPE_UNKNOWN,\n                rightsBase: bigint_1.BigIntPolyfill(0),\n                rightsInheriting: bigint_1.BigIntPolyfill(0)\n            };\n    }\n};\nvar WASIError = /** @class */ (function (_super) {\n    __extends(WASIError, _super);\n    function WASIError(errno) {\n        var _this = _super.call(this) || this;\n        _this.errno = errno;\n        Object.setPrototypeOf(_this, WASIError.prototype);\n        return _this;\n    }\n    return WASIError;\n}(Error));\nexports.WASIError = WASIError;\nvar WASIExitError = /** @class */ (function (_super) {\n    __extends(WASIExitError, _super);\n    function WASIExitError(code) {\n        var _this = _super.call(this, \"WASI Exit error: \".concat(code)) || this;\n        _this.code = code;\n        Object.setPrototypeOf(_this, WASIExitError.prototype);\n        return _this;\n    }\n    return WASIExitError;\n}(Error));\nexports.WASIExitError = WASIExitError;\nvar WASIKillError = /** @class */ (function (_super) {\n    __extends(WASIKillError, _super);\n    function WASIKillError(signal) {\n        var _this = _super.call(this, \"WASI Kill signal: \".concat(signal)) || this;\n        _this.signal = signal;\n        Object.setPrototypeOf(_this, WASIKillError.prototype);\n        return _this;\n    }\n    return WASIKillError;\n}(Error));\nexports.WASIKillError = WASIKillError;\nvar WASIDefault = /** @class */ (function () {\n    function WASIDefault(wasiConfig) {\n        var _this = this;\n        // Destructure our wasiConfig\n        var preopens = {};\n        if (wasiConfig && wasiConfig.preopens) {\n            preopens = wasiConfig.preopens;\n        }\n        else if (wasiConfig && wasiConfig.preopenDirectories) {\n            preopens = wasiConfig\n                .preopenDirectories;\n        }\n        var env = {};\n        if (wasiConfig && wasiConfig.env) {\n            env = wasiConfig.env;\n        }\n        var args = [];\n        if (wasiConfig && wasiConfig.args) {\n            args = wasiConfig.args;\n        }\n        var bindings = defaultBindings;\n        if (wasiConfig && wasiConfig.bindings) {\n            bindings = wasiConfig.bindings;\n        }\n        // @ts-ignore\n        this.memory = undefined;\n        // @ts-ignore\n        this.view = undefined;\n        this.bindings = bindings;\n        this.FD_MAP = new Map([\n            [\n                constants_1.WASI_STDIN_FILENO,\n                {\n                    real: 0,\n                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n                    // offset: BigInt(0),\n                    rights: {\n                        base: STDIN_DEFAULT_RIGHTS,\n                        inheriting: bigint_1.BigIntPolyfill(0)\n                    },\n                    path: undefined\n                }\n            ],\n            [\n                constants_1.WASI_STDOUT_FILENO,\n                {\n                    real: 1,\n                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n                    // offset: BigInt(0),\n                    rights: {\n                        base: STDOUT_DEFAULT_RIGHTS,\n                        inheriting: bigint_1.BigIntPolyfill(0)\n                    },\n                    path: undefined\n                }\n            ],\n            [\n                constants_1.WASI_STDERR_FILENO,\n                {\n                    real: 2,\n                    filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n                    // offset: BigInt(0),\n                    rights: {\n                        base: STDERR_DEFAULT_RIGHTS,\n                        inheriting: bigint_1.BigIntPolyfill(0)\n                    },\n                    path: undefined\n                }\n            ]\n        ]);\n        var fs = this.bindings.fs;\n        var path = this.bindings.path;\n        for (var _i = 0, _a = Object.entries(preopens); _i < _a.length; _i++) {\n            var _b = _a[_i], k = _b[0], v = _b[1];\n            var real = fs.openSync(v, fs.constants.O_RDONLY);\n            var newfd = __spreadArray([], this.FD_MAP.keys(), true).reverse()[0] + 1;\n            this.FD_MAP.set(newfd, {\n                real: real,\n                filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n                // offset: BigInt(0),\n                rights: {\n                    base: constants_1.RIGHTS_DIRECTORY_BASE,\n                    inheriting: constants_1.RIGHTS_DIRECTORY_INHERITING\n                },\n                fakePath: k,\n                path: v\n            });\n        }\n        var getiovs = function (iovs, iovsLen) {\n            // iovs* -> [iov, iov, ...]\n            // __wasi_ciovec_t {\n            //   void* buf,\n            //   size_t buf_len,\n            // }\n            _this.refreshMemory();\n            var buffers = Array.from({ length: iovsLen }, function (_, i) {\n                var ptr = iovs + i * 8;\n                var buf = _this.view.getUint32(ptr, true);\n                var bufLen = _this.view.getUint32(ptr + 4, true);\n                return new Uint8Array(_this.memory.buffer, buf, bufLen);\n            });\n            return buffers;\n        };\n        var CHECK_FD = function (fd, rights) {\n            var stats = stat(_this, fd);\n            // console.log(`CHECK_FD: stats.real: ${stats.real}, stats.path:`, stats.path);\n            if (rights !== bigint_1.BigIntPolyfill(0) && (stats.rights.base & rights) === bigint_1.BigIntPolyfill(0)) {\n                throw new WASIError(constants_1.WASI_EPERM);\n            }\n            return stats;\n        };\n        var CPUTIME_START = bindings.hrtime();\n        var now = function (clockId) {\n            switch (clockId) {\n                case constants_1.WASI_CLOCK_MONOTONIC:\n                    return bindings.hrtime();\n                case constants_1.WASI_CLOCK_REALTIME:\n                    return msToNs(Date.now());\n                case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n                case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID:\n                    // return bindings.hrtime(CPUTIME_START)\n                    return bindings.hrtime() - CPUTIME_START;\n                default:\n                    return null;\n            }\n        };\n        this.wasiImport = {\n            args_get: function (argv, argvBuf) {\n                _this.refreshMemory();\n                var coffset = argv;\n                var offset = argvBuf;\n                args.forEach(function (a) {\n                    _this.view.setUint32(coffset, offset, true);\n                    coffset += 4;\n                    offset += buffer_1.default.from(_this.memory.buffer).write(\"\".concat(a, \"\\0\"), offset);\n                });\n                return constants_1.WASI_ESUCCESS;\n            },\n            args_sizes_get: function (argc, argvBufSize) {\n                _this.refreshMemory();\n                _this.view.setUint32(argc, args.length, true);\n                var size = args.reduce(function (acc, a) { return acc + buffer_1.default.byteLength(a) + 1; }, 0);\n                _this.view.setUint32(argvBufSize, size, true);\n                return constants_1.WASI_ESUCCESS;\n            },\n            environ_get: function (environ, environBuf) {\n                _this.refreshMemory();\n                var coffset = environ;\n                var offset = environBuf;\n                Object.entries(env).forEach(function (_a) {\n                    var key = _a[0], value = _a[1];\n                    _this.view.setUint32(coffset, offset, true);\n                    coffset += 4;\n                    offset += buffer_1.default.from(_this.memory.buffer).write(\"\".concat(key, \"=\").concat(value, \"\\0\"), offset);\n                });\n                return constants_1.WASI_ESUCCESS;\n            },\n            environ_sizes_get: function (environCount, environBufSize) {\n                _this.refreshMemory();\n                var envProcessed = Object.entries(env).map(function (_a) {\n                    var key = _a[0], value = _a[1];\n                    return \"\".concat(key, \"=\").concat(value, \"\\0\");\n                });\n                var size = envProcessed.reduce(function (acc, e) { return acc + buffer_1.default.byteLength(e); }, 0);\n                _this.view.setUint32(environCount, envProcessed.length, true);\n                _this.view.setUint32(environBufSize, size, true);\n                return constants_1.WASI_ESUCCESS;\n            },\n            clock_res_get: function (clockId, resolution) {\n                var res;\n                switch (clockId) {\n                    case constants_1.WASI_CLOCK_MONOTONIC:\n                    case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n                    case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID: {\n                        res = bigint_1.BigIntPolyfill(1);\n                        break;\n                    }\n                    case constants_1.WASI_CLOCK_REALTIME: {\n                        res = bigint_1.BigIntPolyfill(1000);\n                        break;\n                    }\n                }\n                _this.view.setBigUint64(resolution, res);\n                return constants_1.WASI_ESUCCESS;\n            },\n            clock_time_get: function (clockId, precision, time) {\n                _this.refreshMemory();\n                var n = now(clockId);\n                if (n === null) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.view.setBigUint64(time, bigint_1.BigIntPolyfill(n), true);\n                return constants_1.WASI_ESUCCESS;\n            },\n            fd_advise: wrap(function (fd, offset, len, advice) {\n                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ADVISE);\n                return constants_1.WASI_ENOSYS;\n            }),\n            fd_allocate: wrap(function (fd, offset, len) {\n                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ALLOCATE);\n                return constants_1.WASI_ENOSYS;\n            }),\n            fd_close: wrap(function (fd) {\n                var stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));\n                fs.closeSync(stats.real);\n                _this.FD_MAP.delete(fd);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_datasync: wrap(function (fd) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_DATASYNC);\n                fs.fdatasyncSync(stats.real);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_fdstat_get: wrap(function (fd, bufPtr) {\n                var stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));\n                _this.refreshMemory();\n                _this.view.setUint8(bufPtr, stats.filetype); // FILETYPE u8\n                _this.view.setUint16(bufPtr + 2, 0, true); // FDFLAG u16\n                _this.view.setUint16(bufPtr + 4, 0, true); // FDFLAG u16\n                _this.view.setBigUint64(bufPtr + 8, bigint_1.BigIntPolyfill(stats.rights.base), true); // u64\n                _this.view.setBigUint64(bufPtr + 8 + 8, bigint_1.BigIntPolyfill(stats.rights.inheriting), true); // u64\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_fdstat_set_flags: wrap(function (fd, flags) {\n                CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS);\n                return constants_1.WASI_ENOSYS;\n            }),\n            fd_fdstat_set_rights: wrap(function (fd, fsRightsBase, fsRightsInheriting) {\n                var stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));\n                var nrb = stats.rights.base | fsRightsBase;\n                if (nrb > stats.rights.base) {\n                    return constants_1.WASI_EPERM;\n                }\n                var nri = stats.rights.inheriting | fsRightsInheriting;\n                if (nri > stats.rights.inheriting) {\n                    return constants_1.WASI_EPERM;\n                }\n                stats.rights.base = fsRightsBase;\n                stats.rights.inheriting = fsRightsInheriting;\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_filestat_get: wrap(function (fd, bufPtr) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_GET);\n                var rstats = fs.fstatSync(stats.real);\n                _this.refreshMemory();\n                _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.dev), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.ino), true);\n                bufPtr += 8;\n                _this.view.setUint8(bufPtr, stats.filetype);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.nlink), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.size), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_filestat_set_size: wrap(function (fd, stSize) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE);\n                fs.ftruncateSync(stats.real, Number(stSize));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_filestat_set_times: wrap(function (fd, stAtim, stMtim, fstflags) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_TIMES);\n                var rstats = fs.fstatSync(stats.real);\n                var atim = rstats.atime;\n                var mtim = rstats.mtime;\n                var n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME));\n                var atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n                if ((fstflags & atimflags) === atimflags) {\n                    return constants_1.WASI_EINVAL;\n                }\n                var mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n                if ((fstflags & mtimflags) === mtimflags) {\n                    return constants_1.WASI_EINVAL;\n                }\n                if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM) {\n                    atim = nsToMs(stAtim);\n                }\n                else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) === constants_1.WASI_FILESTAT_SET_ATIM_NOW) {\n                    atim = n;\n                }\n                if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM) {\n                    mtim = nsToMs(stMtim);\n                }\n                else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) === constants_1.WASI_FILESTAT_SET_MTIM_NOW) {\n                    mtim = n;\n                }\n                fs.futimesSync(stats.real, new Date(atim), new Date(mtim));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_prestat_get: wrap(function (fd, bufPtr) {\n                var stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                _this.view.setUint8(bufPtr, constants_1.WASI_PREOPENTYPE_DIR);\n                _this.view.setUint32(bufPtr + 4, buffer_1.default.byteLength(stats.fakePath), true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_prestat_dir_name: wrap(function (fd, pathPtr, pathLen) {\n                var stats = CHECK_FD(fd, bigint_1.BigIntPolyfill(0));\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                buffer_1.default.from(_this.memory.buffer).write(stats.fakePath, pathPtr, pathLen, \"utf8\");\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_pwrite: wrap(function (fd, iovs, iovsLen, offset, nwritten) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SEEK);\n                var written = 0;\n                getiovs(iovs, iovsLen).forEach(function (iov) {\n                    var w = 0;\n                    while (w < iov.byteLength) {\n                        w += fs.writeSync(stats.real, iov, w, iov.byteLength - w, Number(offset) + written + w);\n                    }\n                    written += w;\n                });\n                _this.view.setUint32(nwritten, written, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_write: wrap(function (fd, iovs, iovsLen, nwritten) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE);\n                var written = 0;\n                getiovs(iovs, iovsLen).forEach(function (iov) {\n                    var w = 0;\n                    while (w < iov.byteLength) {\n                        var i = fs.writeSync(stats.real, iov, w, iov.byteLength - w, stats.offset ? Number(stats.offset) : null);\n                        if (stats.offset)\n                            stats.offset += bigint_1.BigIntPolyfill(i);\n                        w += i;\n                    }\n                    written += w;\n                });\n                _this.view.setUint32(nwritten, written, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_pread: wrap(function (fd, iovs, iovsLen, offset, nread) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SEEK);\n                var read = 0;\n                outer: for (var _i = 0, _a = getiovs(iovs, iovsLen); _i < _a.length; _i++) {\n                    var iov = _a[_i];\n                    var r = 0;\n                    while (r < iov.byteLength) {\n                        var length_1 = iov.byteLength - r;\n                        var rr = fs.readSync(stats.real, iov, r, iov.byteLength - r, Number(offset) + read + r);\n                        r += rr;\n                        read += rr;\n                        // If we don't read anything, or we receive less than requested\n                        if (rr === 0 || rr < length_1) {\n                            break outer;\n                        }\n                    }\n                    read += r;\n                }\n                ;\n                _this.view.setUint32(nread, read, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_read: wrap(function (fd, iovs, iovsLen, nread) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ);\n                var IS_STDIN = stats.real === 0;\n                var read = 0;\n                outer: for (var _i = 0, _a = getiovs(iovs, iovsLen); _i < _a.length; _i++) {\n                    var iov = _a[_i];\n                    var r = 0;\n                    while (r < iov.byteLength) {\n                        var length_2 = iov.byteLength - r;\n                        var position = IS_STDIN || stats.offset === undefined\n                            ? null\n                            : Number(stats.offset);\n                        var rr = fs.readSync(stats.real, // fd\n                        iov, // buffer\n                        r, // offset\n                        length_2, // length\n                        position // position\n                        );\n                        if (!IS_STDIN) {\n                            stats.offset =\n                                (stats.offset ? stats.offset : bigint_1.BigIntPolyfill(0)) + bigint_1.BigIntPolyfill(rr);\n                        }\n                        r += rr;\n                        read += rr;\n                        // If we don't read anything, or we receive less than requested\n                        if (rr === 0 || rr < length_2) {\n                            break outer;\n                        }\n                    }\n                }\n                // We should not modify the offset of stdin\n                _this.view.setUint32(nread, read, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_readdir: wrap(function (fd, bufPtr, bufLen, cookie, bufusedPtr) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READDIR);\n                _this.refreshMemory();\n                var entries = fs.readdirSync(stats.path, { withFileTypes: true });\n                var startPtr = bufPtr;\n                for (var i = Number(cookie); i < entries.length; i += 1) {\n                    var entry = entries[i];\n                    var nameLength = buffer_1.default.byteLength(entry.name);\n                    if (bufPtr - startPtr > bufLen) {\n                        break;\n                    }\n                    _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(i + 1), true);\n                    bufPtr += 8;\n                    if (bufPtr - startPtr > bufLen) {\n                        break;\n                    }\n                    var rstats = fs.statSync(path.resolve(stats.path, entry.name));\n                    _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.ino), true);\n                    bufPtr += 8;\n                    if (bufPtr - startPtr > bufLen) {\n                        break;\n                    }\n                    _this.view.setUint32(bufPtr, nameLength, true);\n                    bufPtr += 4;\n                    if (bufPtr - startPtr > bufLen) {\n                        break;\n                    }\n                    var filetype = void 0;\n                    switch (true) {\n                        case rstats.isBlockDevice():\n                            filetype = constants_1.WASI_FILETYPE_BLOCK_DEVICE;\n                            break;\n                        case rstats.isCharacterDevice():\n                            filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n                            break;\n                        case rstats.isDirectory():\n                            filetype = constants_1.WASI_FILETYPE_DIRECTORY;\n                            break;\n                        case rstats.isFIFO():\n                            filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                            break;\n                        case rstats.isFile():\n                            filetype = constants_1.WASI_FILETYPE_REGULAR_FILE;\n                            break;\n                        case rstats.isSocket():\n                            filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                            break;\n                        case rstats.isSymbolicLink():\n                            filetype = constants_1.WASI_FILETYPE_SYMBOLIC_LINK;\n                            break;\n                        default:\n                            filetype = constants_1.WASI_FILETYPE_UNKNOWN;\n                            break;\n                    }\n                    _this.view.setUint8(bufPtr, filetype);\n                    bufPtr += 1;\n                    bufPtr += 3; // padding\n                    if (bufPtr + nameLength >= startPtr + bufLen) {\n                        // It doesn't fit in the buffer\n                        break;\n                    }\n                    var memory_buffer = buffer_1.default.from(_this.memory.buffer);\n                    memory_buffer.write(entry.name, bufPtr);\n                    bufPtr += nameLength;\n                }\n                var bufused = bufPtr - startPtr;\n                _this.view.setUint32(bufusedPtr, Math.min(bufused, bufLen), true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_renumber: wrap(function (from, to) {\n                CHECK_FD(from, bigint_1.BigIntPolyfill(0));\n                CHECK_FD(to, bigint_1.BigIntPolyfill(0));\n                fs.closeSync(_this.FD_MAP.get(from).real);\n                _this.FD_MAP.set(from, _this.FD_MAP.get(to));\n                _this.FD_MAP.delete(to);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_seek: wrap(function (fd, offset, whence, newOffsetPtr) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SEEK);\n                _this.refreshMemory();\n                switch (whence) {\n                    case constants_1.WASI_WHENCE_CUR:\n                        stats.offset =\n                            (stats.offset ? stats.offset : bigint_1.BigIntPolyfill(0)) + bigint_1.BigIntPolyfill(offset);\n                        break;\n                    case constants_1.WASI_WHENCE_END:\n                        var size = fs.fstatSync(stats.real).size;\n                        stats.offset = bigint_1.BigIntPolyfill(size) + bigint_1.BigIntPolyfill(offset);\n                        break;\n                    case constants_1.WASI_WHENCE_SET:\n                        stats.offset = bigint_1.BigIntPolyfill(offset);\n                        break;\n                }\n                _this.view.setBigUint64(newOffsetPtr, stats.offset, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_tell: wrap(function (fd, offsetPtr) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_TELL);\n                _this.refreshMemory();\n                if (!stats.offset) {\n                    stats.offset = bigint_1.BigIntPolyfill(0);\n                }\n                _this.view.setBigUint64(offsetPtr, stats.offset, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            fd_sync: wrap(function (fd) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SYNC);\n                fs.fsyncSync(stats.real);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_create_directory: wrap(function (fd, pathPtr, pathLen) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_CREATE_DIRECTORY);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var p = buffer_1.default.from(_this.memory.buffer, pathPtr, pathLen).toString();\n                fs.mkdirSync(path.resolve(stats.path, p));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_filestat_get: wrap(function (fd, flags, pathPtr, pathLen, bufPtr) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_GET);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var p = buffer_1.default.from(_this.memory.buffer, pathPtr, pathLen).toString();\n                var rstats = fs.statSync(path.resolve(stats.path, p));\n                _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.dev), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.ino), true);\n                bufPtr += 8;\n                _this.view.setUint8(bufPtr, translateFileAttributes(_this, undefined, rstats).filetype);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.nlink), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, bigint_1.BigIntPolyfill(rstats.size), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), true);\n                bufPtr += 8;\n                _this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_filestat_set_times: wrap(function (fd, dirflags, pathPtr, pathLen, stAtim, stMtim, fstflags) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_SET_TIMES);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var rstats = fs.fstatSync(stats.real);\n                var atim = rstats.atime;\n                var mtim = rstats.mtime;\n                var n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME));\n                var atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n                if ((fstflags & atimflags) === atimflags) {\n                    return constants_1.WASI_EINVAL;\n                }\n                var mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n                if ((fstflags & mtimflags) === mtimflags) {\n                    return constants_1.WASI_EINVAL;\n                }\n                if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM) {\n                    atim = nsToMs(stAtim);\n                }\n                else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) === constants_1.WASI_FILESTAT_SET_ATIM_NOW) {\n                    atim = n;\n                }\n                if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM) {\n                    mtim = nsToMs(stMtim);\n                }\n                else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) === constants_1.WASI_FILESTAT_SET_MTIM_NOW) {\n                    mtim = n;\n                }\n                var p = buffer_1.default.from(_this.memory.buffer, pathPtr, pathLen).toString();\n                fs.utimesSync(path.resolve(stats.path, p), new Date(atim), new Date(mtim));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_link: wrap(function (oldFd, oldFlags, oldPath, oldPathLen, newFd, newPath, newPathLen) {\n                var ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_LINK_SOURCE);\n                var nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_LINK_TARGET);\n                if (!ostats.path || !nstats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var op = buffer_1.default.from(_this.memory.buffer, oldPath, oldPathLen).toString();\n                var np = buffer_1.default.from(_this.memory.buffer, newPath, newPathLen).toString();\n                fs.linkSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_open: wrap(function (dirfd, dirflags, pathPtr, pathLen, oflags, fsRightsBase, fsRightsInheriting, fsFlags, fd) {\n                var stats = CHECK_FD(dirfd, constants_1.WASI_RIGHT_PATH_OPEN);\n                fsRightsBase = bigint_1.BigIntPolyfill(fsRightsBase);\n                fsRightsInheriting = bigint_1.BigIntPolyfill(fsRightsInheriting);\n                var read = (fsRightsBase & (constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_READDIR)) !==\n                    bigint_1.BigIntPolyfill(0);\n                var write = (fsRightsBase &\n                    (constants_1.WASI_RIGHT_FD_DATASYNC |\n                        constants_1.WASI_RIGHT_FD_WRITE |\n                        constants_1.WASI_RIGHT_FD_ALLOCATE |\n                        constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE)) !==\n                    bigint_1.BigIntPolyfill(0);\n                var noflags;\n                if (write && read) {\n                    noflags = fs.constants.O_RDWR;\n                }\n                else if (read) {\n                    noflags = fs.constants.O_RDONLY;\n                }\n                else if (write) {\n                    noflags = fs.constants.O_WRONLY;\n                }\n                // fsRightsBase is needed here but perhaps we should do it in neededInheriting\n                var neededBase = fsRightsBase | constants_1.WASI_RIGHT_PATH_OPEN;\n                var neededInheriting = fsRightsBase | fsRightsInheriting;\n                if ((oflags & constants_1.WASI_O_CREAT) !== 0) {\n                    noflags |= fs.constants.O_CREAT;\n                    neededBase |= constants_1.WASI_RIGHT_PATH_CREATE_FILE;\n                }\n                if ((oflags & constants_1.WASI_O_DIRECTORY) !== 0) {\n                    noflags |= fs.constants.O_DIRECTORY;\n                }\n                if ((oflags & constants_1.WASI_O_EXCL) !== 0) {\n                    noflags |= fs.constants.O_EXCL;\n                }\n                if ((oflags & constants_1.WASI_O_TRUNC) !== 0) {\n                    noflags |= fs.constants.O_TRUNC;\n                    neededBase |= constants_1.WASI_RIGHT_PATH_FILESTAT_SET_SIZE;\n                }\n                // Convert file descriptor flags.\n                if ((fsFlags & constants_1.WASI_FDFLAG_APPEND) !== 0) {\n                    noflags |= fs.constants.O_APPEND;\n                }\n                if ((fsFlags & constants_1.WASI_FDFLAG_DSYNC) !== 0) {\n                    if (fs.constants.O_DSYNC) {\n                        noflags |= fs.constants.O_DSYNC;\n                    }\n                    else {\n                        noflags |= fs.constants.O_SYNC;\n                    }\n                    neededInheriting |= constants_1.WASI_RIGHT_FD_DATASYNC;\n                }\n                if ((fsFlags & constants_1.WASI_FDFLAG_NONBLOCK) !== 0) {\n                    noflags |= fs.constants.O_NONBLOCK;\n                }\n                if ((fsFlags & constants_1.WASI_FDFLAG_RSYNC) !== 0) {\n                    if (fs.constants.O_RSYNC) {\n                        noflags |= fs.constants.O_RSYNC;\n                    }\n                    else {\n                        noflags |= fs.constants.O_SYNC;\n                    }\n                    neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n                }\n                if ((fsFlags & constants_1.WASI_FDFLAG_SYNC) !== 0) {\n                    noflags |= fs.constants.O_SYNC;\n                    neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n                }\n                if (write &&\n                    (noflags & (fs.constants.O_APPEND | fs.constants.O_TRUNC)) === 0) {\n                    neededInheriting |= constants_1.WASI_RIGHT_FD_SEEK;\n                }\n                _this.refreshMemory();\n                var p = buffer_1.default.from(_this.memory.buffer, pathPtr, pathLen).toString();\n                var fullUnresolved = path.resolve(stats.path, p);\n                if (path.relative(stats.path, fullUnresolved).startsWith(\"..\")) {\n                    return constants_1.WASI_ENOTCAPABLE;\n                }\n                var full;\n                try {\n                    full = fs.realpathSync(fullUnresolved);\n                    if (path.relative(stats.path, full).startsWith(\"..\")) {\n                        return constants_1.WASI_ENOTCAPABLE;\n                    }\n                }\n                catch (e) {\n                    if (e.code === \"ENOENT\") {\n                        full = fullUnresolved;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n                /* check if the file is a directory (unless opening for write,\n                 * in which case the file may not exist and should be created) */\n                var isDirectory;\n                try {\n                    isDirectory = fs.statSync(full).isDirectory();\n                }\n                catch (e) { }\n                var realfd;\n                if (!write && isDirectory) {\n                    realfd = fs.openSync(full, fs.constants.O_RDONLY);\n                }\n                else {\n                    realfd = fs.openSync(full, noflags);\n                }\n                var newfd = __spreadArray([], _this.FD_MAP.keys(), true).reverse()[0] + 1;\n                _this.FD_MAP.set(newfd, {\n                    real: realfd,\n                    filetype: undefined,\n                    // offset: BigInt(0),\n                    rights: {\n                        base: neededBase,\n                        inheriting: neededInheriting\n                    },\n                    path: full\n                });\n                stat(_this, newfd);\n                _this.view.setUint32(fd, newfd, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_readlink: wrap(function (fd, pathPtr, pathLen, buf, bufLen, bufused) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_READLINK);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var p = buffer_1.default.from(_this.memory.buffer, pathPtr, pathLen).toString();\n                var full = path.resolve(stats.path, p);\n                var r = fs.readlinkSync(full);\n                var used = buffer_1.default.from(_this.memory.buffer).write(r, buf, bufLen);\n                _this.view.setUint32(bufused, used, true);\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_remove_directory: wrap(function (fd, pathPtr, pathLen) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_REMOVE_DIRECTORY);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var p = buffer_1.default.from(_this.memory.buffer, pathPtr, pathLen).toString();\n                fs.rmdirSync(path.resolve(stats.path, p));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_rename: wrap(function (oldFd, oldPath, oldPathLen, newFd, newPath, newPathLen) {\n                var ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_RENAME_SOURCE);\n                var nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_RENAME_TARGET);\n                if (!ostats.path || !nstats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var op = buffer_1.default.from(_this.memory.buffer, oldPath, oldPathLen).toString();\n                var np = buffer_1.default.from(_this.memory.buffer, newPath, newPathLen).toString();\n                fs.renameSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_symlink: wrap(function (oldPath, oldPathLen, fd, newPath, newPathLen) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_SYMLINK);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var op = buffer_1.default.from(_this.memory.buffer, oldPath, oldPathLen).toString();\n                var np = buffer_1.default.from(_this.memory.buffer, newPath, newPathLen).toString();\n                fs.symlinkSync(op, path.resolve(stats.path, np));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            path_unlink_file: wrap(function (fd, pathPtr, pathLen) {\n                var stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_UNLINK_FILE);\n                if (!stats.path) {\n                    return constants_1.WASI_EINVAL;\n                }\n                _this.refreshMemory();\n                var p = buffer_1.default.from(_this.memory.buffer, pathPtr, pathLen).toString();\n                fs.unlinkSync(path.resolve(stats.path, p));\n                return constants_1.WASI_ESUCCESS;\n            }),\n            poll_oneoff: function (sin, sout, nsubscriptions, nevents) {\n                var eventc = 0;\n                var waitEnd = 0;\n                _this.refreshMemory();\n                for (var i = 0; i < nsubscriptions; i += 1) {\n                    var userdata = _this.view.getBigUint64(sin, true);\n                    sin += 8;\n                    var type = _this.view.getUint8(sin);\n                    sin += 1;\n                    switch (type) {\n                        case constants_1.WASI_EVENTTYPE_CLOCK: {\n                            sin += 7; // padding\n                            var identifier = _this.view.getBigUint64(sin, true);\n                            sin += 8;\n                            var clockid = _this.view.getUint32(sin, true);\n                            sin += 4;\n                            sin += 4; // padding\n                            var timestamp = _this.view.getBigUint64(sin, true);\n                            sin += 8;\n                            var precision = _this.view.getBigUint64(sin, true);\n                            sin += 8;\n                            var subclockflags = _this.view.getUint16(sin, true);\n                            sin += 2;\n                            sin += 6; // padding\n                            var absolute = subclockflags === 1;\n                            var e = constants_1.WASI_ESUCCESS;\n                            var n = bigint_1.BigIntPolyfill(now(clockid));\n                            if (n === null) {\n                                e = constants_1.WASI_EINVAL;\n                            }\n                            else {\n                                var end = absolute ? timestamp : n + timestamp;\n                                waitEnd =\n                                    end > waitEnd ? end : waitEnd;\n                            }\n                            _this.view.setBigUint64(sout, userdata, true);\n                            sout += 8;\n                            _this.view.setUint16(sout, e, true); // error\n                            sout += 2; // pad offset 2\n                            _this.view.setUint8(sout, constants_1.WASI_EVENTTYPE_CLOCK);\n                            sout += 1; // pad offset 3\n                            sout += 5; // padding to 8\n                            eventc += 1;\n                            break;\n                        }\n                        case constants_1.WASI_EVENTTYPE_FD_READ:\n                        case constants_1.WASI_EVENTTYPE_FD_WRITE: {\n                            sin += 3; // padding\n                            var fd = _this.view.getUint32(sin, true);\n                            sin += 4;\n                            _this.view.setBigUint64(sout, userdata, true);\n                            sout += 8;\n                            _this.view.setUint16(sout, constants_1.WASI_ENOSYS, true); // error\n                            sout += 2; // pad offset 2\n                            _this.view.setUint8(sout, type);\n                            sout += 1; // pad offset 3\n                            sout += 5; // padding to 8\n                            eventc += 1;\n                            break;\n                        }\n                        default:\n                            return constants_1.WASI_EINVAL;\n                    }\n                }\n                _this.view.setUint32(nevents, eventc, true);\n                while (bindings.hrtime() < waitEnd) {\n                    // nothing\n                }\n                return constants_1.WASI_ESUCCESS;\n            },\n            proc_exit: function (rval) {\n                bindings.exit(rval);\n                return constants_1.WASI_ESUCCESS;\n            },\n            proc_raise: function (sig) {\n                if (!(sig in constants_1.SIGNAL_MAP)) {\n                    return constants_1.WASI_EINVAL;\n                }\n                bindings.kill(constants_1.SIGNAL_MAP[sig]);\n                return constants_1.WASI_ESUCCESS;\n            },\n            random_get: function (bufPtr, bufLen) {\n                _this.refreshMemory();\n                bindings.randomFillSync(new Uint8Array(_this.memory.buffer), bufPtr, bufLen);\n                return constants_1.WASI_ESUCCESS;\n            },\n            sched_yield: function () {\n                // Single threaded environment\n                // This is a no-op in JS\n                return constants_1.WASI_ESUCCESS;\n            },\n            sock_recv: function () {\n                return constants_1.WASI_ENOSYS;\n            },\n            sock_send: function () {\n                return constants_1.WASI_ENOSYS;\n            },\n            sock_shutdown: function () {\n                return constants_1.WASI_ENOSYS;\n            }\n        };\n        // Wrap each of the imports to show the calls in the console\n        if (wasiConfig.traceSyscalls) {\n            Object.keys(this.wasiImport).forEach(function (key) {\n                var prevImport = _this.wasiImport[key];\n                _this.wasiImport[key] = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    console.log(\"WASI: wasiImport called: \".concat(key, \" (\").concat(args, \")\"));\n                    try {\n                        var result = prevImport.apply(void 0, args);\n                        console.log(\"WASI:  => \".concat(result));\n                        return result;\n                    }\n                    catch (e) {\n                        console.log(\"Catched error: \".concat(e));\n                        throw e;\n                    }\n                };\n            });\n        }\n    }\n    WASIDefault.prototype.refreshMemory = function () {\n        // @ts-ignore\n        if (!this.view || this.view.buffer.byteLength === 0) {\n            this.view = new dataview_1.DataViewPolyfill(this.memory.buffer);\n        }\n    };\n    WASIDefault.prototype.setMemory = function (memory) {\n        this.memory = memory;\n    };\n    WASIDefault.prototype.start = function (instance) {\n        var exports = instance.exports;\n        if (exports === null || typeof exports !== \"object\") {\n            throw new Error(\"instance.exports must be an Object. Received \".concat(exports, \".\"));\n        }\n        var memory = exports.memory;\n        if (!(memory instanceof WebAssembly.Memory)) {\n            throw new Error(\"instance.exports.memory must be a WebAssembly.Memory. Recceived \".concat(memory, \".\"));\n        }\n        this.setMemory(memory);\n        if (exports._start) {\n            exports._start();\n        }\n    };\n    WASIDefault.prototype.getImportNamespace = function (module) {\n        var namespace = null;\n        for (var _i = 0, _a = WebAssembly.Module.imports(module); _i < _a.length; _i++) {\n            var imp = _a[_i];\n            // We only check for the functions\n            if (imp.kind !== \"function\") {\n                continue;\n            }\n            // We allow functions in other namespaces other than wasi\n            if (!imp.module.startsWith(\"wasi_\")) {\n                continue;\n            }\n            if (!namespace) {\n                namespace = imp.module;\n            }\n            else {\n                if (namespace !== imp.module) {\n                    throw new Error(\"Multiple namespaces detected.\");\n                }\n            }\n        }\n        return namespace;\n    };\n    WASIDefault.prototype.getImports = function (module) {\n        var namespace = this.getImportNamespace(module);\n        switch (namespace) {\n            case \"wasi_unstable\":\n                return {\n                    wasi_unstable: this.wasiImport\n                };\n            case \"wasi_snapshot_preview1\":\n                return {\n                    wasi_snapshot_preview1: this.wasiImport\n                };\n            default:\n                throw new Error(\"Can't detect a WASI namespace for the WebAssembly Module\");\n        }\n    };\n    return WASIDefault;\n}());\nexports.default = WASIDefault;\nWASIDefault.defaultBindings = defaultBindings;\n// Also export it as a field in the export object\nexports.WASI = WASIDefault;\n\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/index.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasi/lib/polyfills/bigint.js":
/*!***********************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/polyfills/bigint.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n// A very simple workaround for Big int. Works in conjunction with our custom\n// Dataview workaround at ./dataview.ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar globalObj = typeof globalThis !== \"undefined\"\n    ? globalThis\n    : typeof global !== \"undefined\"\n        ? global\n        : {};\nexports.BigIntPolyfill = typeof BigInt !== \"undefined\" ? BigInt : globalObj.BigInt || Number;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/polyfills/bigint.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasi/lib/polyfills/browser-hrtime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/polyfills/browser-hrtime.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// hrtime polyfill for the browser\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar baseNow = Math.floor((Date.now() - performance.now()) * 1e-3);\nfunction hrtime(previousTimestamp) {\n    // initilaize our variables\n    var clocktime = performance.now() * 1e-3;\n    var seconds = Math.floor(clocktime) + baseNow;\n    var nanoseconds = Math.floor((clocktime % 1) * 1e9);\n    // Compare to the prvious timestamp if we have one\n    if (previousTimestamp) {\n        seconds = seconds - previousTimestamp[0];\n        nanoseconds = nanoseconds - previousTimestamp[1];\n        if (nanoseconds < 0) {\n            seconds--;\n            nanoseconds += 1e9;\n        }\n    }\n    // Return our seconds tuple\n    return [seconds, nanoseconds];\n}\nexports.default = hrtime;\n\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/polyfills/browser-hrtime.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasi/lib/polyfills/buffer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/polyfills/buffer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n// Return our buffer depending on browser or node\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*ROLLUP_REPLACE_BROWSER\n// @ts-ignore\nimport { Buffer } from \"buffer-es6\";\nROLLUP_REPLACE_BROWSER*/\nvar isomorphicBuffer = Buffer;\nexports.default = isomorphicBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/polyfills/buffer.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasi/lib/polyfills/dataview.js":
/*!*************************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/polyfills/dataview.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// A very simple workaround for Big int. Works in conjunction with our custom\n// BigInt workaround at ./bigint.ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bigint_1 = __webpack_require__(/*! ./bigint */ \"./node_modules/@wasmer/wasi/lib/polyfills/bigint.js\");\nvar exportedDataView = DataView;\nif (!exportedDataView.prototype.setBigUint64) {\n    // Taken from https://gist.github.com/graup/815c9ac65c2bac8a56391f0ca23636fc\n    exportedDataView.prototype.setBigUint64 = function (byteOffset, value, littleEndian) {\n        var lowWord;\n        var highWord;\n        if (value < Math.pow(2, 32)) {\n            lowWord = Number(value);\n            highWord = 0;\n        }\n        else {\n            var bigNumberAsBinaryStr = value.toString(2);\n            // Convert the above binary str to 64 bit (actually 52 bit will work) by padding zeros in the left\n            var bigNumberAsBinaryStr2 = \"\";\n            for (var i = 0; i < 64 - bigNumberAsBinaryStr.length; i++) {\n                bigNumberAsBinaryStr2 += \"0\";\n            }\n            bigNumberAsBinaryStr2 += bigNumberAsBinaryStr;\n            highWord = parseInt(bigNumberAsBinaryStr2.substring(0, 32), 2);\n            lowWord = parseInt(bigNumberAsBinaryStr2.substring(32), 2);\n        }\n        this.setUint32(byteOffset + (littleEndian ? 0 : 4), lowWord, littleEndian);\n        this.setUint32(byteOffset + (littleEndian ? 4 : 0), highWord, littleEndian);\n    };\n    exportedDataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n        var lowWord = this.getUint32(byteOffset + (littleEndian ? 0 : 4), littleEndian);\n        var highWord = this.getUint32(byteOffset + (littleEndian ? 4 : 0), littleEndian);\n        var lowWordAsBinaryStr = lowWord.toString(2);\n        var highWordAsBinaryStr = highWord.toString(2);\n        // Convert the above binary str to 64 bit (actually 52 bit will work) by padding zeros in the left\n        var lowWordAsBinaryStrPadded = \"\";\n        for (var i = 0; i < 32 - lowWordAsBinaryStr.length; i++) {\n            lowWordAsBinaryStrPadded += \"0\";\n        }\n        lowWordAsBinaryStrPadded += lowWordAsBinaryStr;\n        return bigint_1.BigIntPolyfill(\"0b\" + highWordAsBinaryStr + lowWordAsBinaryStrPadded);\n    };\n}\nexports.DataViewPolyfill = exportedDataView;\n\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/polyfills/dataview.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasi/lib/polyfills/hrtime.bigint.js":
/*!******************************************************************!*\
  !*** ./node_modules/@wasmer/wasi/lib/polyfills/hrtime.bigint.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Simply polyfill for hrtime\n// https://nodejs.org/api/process.html#process_process_hrtime_time\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar NS_PER_SEC = 1e9;\nvar getBigIntHrtime = function (nativeHrtime) {\n    return function (time) {\n        var diff = nativeHrtime(time);\n        // Return the time\n        return (diff[0] * NS_PER_SEC + diff[1]);\n    };\n};\nexports.default = getBigIntHrtime;\n\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasi/lib/polyfills/hrtime.bigint.js?");

/***/ }),

/***/ "./node_modules/@wasmer/wasmfs/lib/index.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/@wasmer/wasmfs/lib/index.esm.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WasmFs = void 0;\n/*\n *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n**************************************************************************** https://mths.be/punycode v1.4.1 by @mathias */\nfunction ba(a, b, c, d) { return new (c || (c = Promise))(function (e, f) { function g(a) { try {\n    k(d.next(a));\n}\ncatch (n) {\n    f(n);\n} } function h(a) { try {\n    k(d[\"throw\"](a));\n}\ncatch (n) {\n    f(n);\n} } function k(a) { a.done ? e(a.value) : (new c(function (b) { b(a.value); })).then(g, h); } k((d = d.apply(a, b || [])).next()); }); }\nfunction ca(a, b) {\n    function c(a) { return function (b) { return d([a, b]); }; }\n    function d(c) {\n        if (f)\n            throw new TypeError(\"Generator is already executing.\");\n        for (; e;)\n            try {\n                if (f = 1, g && (h = c[0] & 2 ? g[\"return\"] : c[0] ? g[\"throw\"] || ((h = g[\"return\"]) && h.call(g), 0) : g.next) && !(h = h.call(g, c[1])).done)\n                    return h;\n                if (g = 0, h)\n                    c = [c[0] & 2, h.value];\n                switch (c[0]) {\n                    case 0:\n                    case 1:\n                        h = c;\n                        break;\n                    case 4: return e.label++, { value: c[1], done: !1 };\n                    case 5:\n                        e.label++;\n                        g = c[1];\n                        c = [0];\n                        continue;\n                    case 7:\n                        c = e.ops.pop();\n                        e.trys.pop();\n                        continue;\n                    default:\n                        if (!(h = e.trys, h = 0 < h.length &&\n                            h[h.length - 1]) && (6 === c[0] || 2 === c[0])) {\n                            e = 0;\n                            continue;\n                        }\n                        if (3 === c[0] && (!h || c[1] > h[0] && c[1] < h[3]))\n                            e.label = c[1];\n                        else if (6 === c[0] && e.label < h[1])\n                            e.label = h[1], h = c;\n                        else if (h && e.label < h[2])\n                            e.label = h[2], e.ops.push(c);\n                        else {\n                            h[2] && e.ops.pop();\n                            e.trys.pop();\n                            continue;\n                        }\n                }\n                c = b.call(a, e);\n            }\n            catch (n) {\n                c = [6, n], g = 0;\n            }\n            finally {\n                f = h = 0;\n            }\n        if (c[0] & 5)\n            throw c[1];\n        return { value: c[0] ? c[1] : void 0, done: !0 };\n    }\n    var e = { label: 0, sent: function () { if (h[0] & 1)\n            throw h[1]; return h[1]; }, trys: [], ops: [] }, f, g, h, k;\n    return k = { next: c(0), \"throw\": c(1), \"return\": c(2) }, \"function\" ===\n        typeof Symbol && (k[Symbol.iterator] = function () { return this; }), k;\n}\nfunction da(a) { var b = \"function\" === typeof Symbol && a[Symbol.iterator], c = 0; return b ? b.call(a) : { next: function () { a && c >= a.length && (a = void 0); return { value: a && a[c++], done: !a }; } }; }\nfunction ea(a, b) { var c = \"function\" === typeof Symbol && a[Symbol.iterator]; if (!c)\n    return a; a = c.call(a); var d, e = []; try {\n    for (; (void 0 === b || 0 < b--) && !(d = a.next()).done;)\n        e.push(d.value);\n}\ncatch (g) {\n    var f = { error: g };\n}\nfinally {\n    try {\n        d && !d.done && (c = a[\"return\"]) && c.call(a);\n    }\n    finally {\n        if (f)\n            throw f.error;\n    }\n} return e; }\nfunction ia() { for (var a = [], b = 0; b < arguments.length; b++)\n    a = a.concat(ea(arguments[b])); return a; }\nvar l = \"undefined\" !== typeof globalThis ? globalThis : \"undefined\" !== typeof window ? window : \"undefined\" !== typeof global ? global : \"undefined\" !== typeof self ? self : {};\nfunction t(a) { return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, \"default\") ? a[\"default\"] : a; }\nfunction u(a, b) { return b = { exports: {} }, a(b, b.exports), b.exports; }\nvar w = u(function (a, b) {\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    b.constants = { O_RDONLY: 0, O_WRONLY: 1, O_RDWR: 2, S_IFMT: 61440, S_IFREG: 32768, S_IFDIR: 16384, S_IFCHR: 8192, S_IFBLK: 24576, S_IFIFO: 4096, S_IFLNK: 40960, S_IFSOCK: 49152, O_CREAT: 64, O_EXCL: 128, O_NOCTTY: 256, O_TRUNC: 512, O_APPEND: 1024, O_DIRECTORY: 65536, O_NOATIME: 262144, O_NOFOLLOW: 131072, O_SYNC: 1052672, O_DIRECT: 16384, O_NONBLOCK: 2048, S_IRWXU: 448, S_IRUSR: 256, S_IWUSR: 128, S_IXUSR: 64, S_IRWXG: 56, S_IRGRP: 32, S_IWGRP: 16, S_IXGRP: 8, S_IRWXO: 7, S_IROTH: 4, S_IWOTH: 2,\n        S_IXOTH: 1, F_OK: 0, R_OK: 4, W_OK: 2, X_OK: 1, UV_FS_SYMLINK_DIR: 1, UV_FS_SYMLINK_JUNCTION: 2, UV_FS_COPYFILE_EXCL: 1, UV_FS_COPYFILE_FICLONE: 2, UV_FS_COPYFILE_FICLONE_FORCE: 4, COPYFILE_EXCL: 1, COPYFILE_FICLONE: 2, COPYFILE_FICLONE_FORCE: 4 };\n});\nt(w);\nvar ja = u(function (a, b) { b.default = \"function\" === typeof BigInt ? BigInt : function () { throw Error(\"BigInt is not supported in this environment.\"); }; }), ka = u(function (a, b) {\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    var c = w.constants.S_IFMT, d = w.constants.S_IFDIR, e = w.constants.S_IFREG, f = w.constants.S_IFBLK, g = w.constants.S_IFCHR, h = w.constants.S_IFLNK, k = w.constants.S_IFIFO, p = w.constants.S_IFSOCK;\n    a = function () {\n        function a() { }\n        a.build = function (b, c) {\n            void 0 === c && (c = !1);\n            var d = new a, e = b.gid, f = b.atime, g = b.mtime, h = b.ctime;\n            c = c ? ja.default : function (a) { return a; };\n            d.uid = c(b.uid);\n            d.gid = c(e);\n            d.rdev = c(0);\n            d.blksize = c(4096);\n            d.ino = c(b.ino);\n            d.size = c(b.getSize());\n            d.blocks = c(1);\n            d.atime = f;\n            d.mtime = g;\n            d.ctime = h;\n            d.birthtime = h;\n            d.atimeMs = c(f.getTime());\n            d.mtimeMs = c(g.getTime());\n            e = c(h.getTime());\n            d.ctimeMs = e;\n            d.birthtimeMs = e;\n            d.dev = c(0);\n            d.mode = c(b.mode);\n            d.nlink = c(b.nlink);\n            return d;\n        };\n        a.prototype._checkModeProperty = function (a) { return (Number(this.mode) & c) === a; };\n        a.prototype.isDirectory = function () { return this._checkModeProperty(d); };\n        a.prototype.isFile =\n            function () { return this._checkModeProperty(e); };\n        a.prototype.isBlockDevice = function () { return this._checkModeProperty(f); };\n        a.prototype.isCharacterDevice = function () { return this._checkModeProperty(g); };\n        a.prototype.isSymbolicLink = function () { return this._checkModeProperty(h); };\n        a.prototype.isFIFO = function () { return this._checkModeProperty(k); };\n        a.prototype.isSocket = function () { return this._checkModeProperty(p); };\n        return a;\n    }();\n    b.Stats = a;\n    b.default = a;\n});\nt(ka);\nvar la = \"undefined\" !== typeof global ? global : \"undefined\" !== typeof self ? self : \"undefined\" !== typeof window ? window : {}, x = [], y = [], ma = \"undefined\" !== typeof Uint8Array ? Uint8Array : Array, oa = !1;\nfunction pa() { oa = !0; for (var a = 0; 64 > a; ++a)\n    x[a] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[a], y[\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charCodeAt(a)] = a; y[45] = 62; y[95] = 63; }\nfunction qa(a, b, c) { for (var d = [], e = b; e < c; e += 3)\n    b = (a[e] << 16) + (a[e + 1] << 8) + a[e + 2], d.push(x[b >> 18 & 63] + x[b >> 12 & 63] + x[b >> 6 & 63] + x[b & 63]); return d.join(\"\"); }\nfunction ra(a) { oa || pa(); for (var b = a.length, c = b % 3, d = \"\", e = [], f = 0, g = b - c; f < g; f += 16383)\n    e.push(qa(a, f, f + 16383 > g ? g : f + 16383)); 1 === c ? (a = a[b - 1], d += x[a >> 2], d += x[a << 4 & 63], d += \"==\") : 2 === c && (a = (a[b - 2] << 8) + a[b - 1], d += x[a >> 10], d += x[a >> 4 & 63], d += x[a << 2 & 63], d += \"=\"); e.push(d); return e.join(\"\"); }\nfunction sa(a, b, c, d, e) { var f = 8 * e - d - 1; var g = (1 << f) - 1, h = g >> 1, k = -7; e = c ? e - 1 : 0; var p = c ? -1 : 1, n = a[b + e]; e += p; c = n & (1 << -k) - 1; n >>= -k; for (k += f; 0 < k; c = 256 * c + a[b + e], e += p, k -= 8)\n    ; f = c & (1 << -k) - 1; c >>= -k; for (k += d; 0 < k; f = 256 * f + a[b + e], e += p, k -= 8)\n    ; if (0 === c)\n    c = 1 - h;\nelse {\n    if (c === g)\n        return f ? NaN : Infinity * (n ? -1 : 1);\n    f += Math.pow(2, d);\n    c -= h;\n} return (n ? -1 : 1) * f * Math.pow(2, c - d); }\nfunction ta(a, b, c, d, e, f) {\n    var g, h = 8 * f - e - 1, k = (1 << h) - 1, p = k >> 1, n = 23 === e ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    f = d ? 0 : f - 1;\n    var q = d ? 1 : -1, B = 0 > b || 0 === b && 0 > 1 / b ? 1 : 0;\n    b = Math.abs(b);\n    isNaN(b) || Infinity === b ? (b = isNaN(b) ? 1 : 0, d = k) : (d = Math.floor(Math.log(b) / Math.LN2), 1 > b * (g = Math.pow(2, -d)) && (d--, g *= 2), b = 1 <= d + p ? b + n / g : b + n * Math.pow(2, 1 - p), 2 <= b * g && (d++, g /= 2), d + p >= k ? (b = 0, d = k) : 1 <= d + p ? (b = (b * g - 1) * Math.pow(2, e), d += p) : (b = b * Math.pow(2, p - 1) * Math.pow(2, e), d = 0));\n    for (; 8 <= e; a[c + f] = b & 255, f += q, b /= 256, e -= 8)\n        ;\n    d = d << e | b;\n    for (h += e; 0 < h; a[c + f] = d & 255,\n        f += q, d /= 256, h -= 8)\n        ;\n    a[c + f - q] |= 128 * B;\n}\nvar wa = {}.toString, ya = Array.isArray || function (a) { return \"[object Array]\" == wa.call(a); };\nz.TYPED_ARRAY_SUPPORT = void 0 !== la.TYPED_ARRAY_SUPPORT ? la.TYPED_ARRAY_SUPPORT : !0;\nvar za = z.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;\nfunction Aa(a, b) { if ((z.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823) < b)\n    throw new RangeError(\"Invalid typed array length\"); z.TYPED_ARRAY_SUPPORT ? (a = new Uint8Array(b), a.__proto__ = z.prototype) : (null === a && (a = new z(b)), a.length = b); return a; }\nfunction z(a, b, c) { if (!(z.TYPED_ARRAY_SUPPORT || this instanceof z))\n    return new z(a, b, c); if (\"number\" === typeof a) {\n    if (\"string\" === typeof b)\n        throw Error(\"If encoding is specified then the first argument must be a string\");\n    return Ba(this, a);\n} return Ca(this, a, b, c); }\nz.poolSize = 8192;\nz._augment = function (a) { a.__proto__ = z.prototype; return a; };\nfunction Ca(a, b, c, d) {\n    if (\"number\" === typeof b)\n        throw new TypeError('\"value\" argument must not be a number');\n    if (\"undefined\" !== typeof ArrayBuffer && b instanceof ArrayBuffer) {\n        b.byteLength;\n        if (0 > c || b.byteLength < c)\n            throw new RangeError(\"'offset' is out of bounds\");\n        if (b.byteLength < c + (d || 0))\n            throw new RangeError(\"'length' is out of bounds\");\n        b = void 0 === c && void 0 === d ? new Uint8Array(b) : void 0 === d ? new Uint8Array(b, c) : new Uint8Array(b, c, d);\n        z.TYPED_ARRAY_SUPPORT ? (a = b, a.__proto__ = z.prototype) : a = Da(a, b);\n        return a;\n    }\n    if (\"string\" ===\n        typeof b) {\n        d = a;\n        a = c;\n        if (\"string\" !== typeof a || \"\" === a)\n            a = \"utf8\";\n        if (!z.isEncoding(a))\n            throw new TypeError('\"encoding\" must be a valid string encoding');\n        c = Ea(b, a) | 0;\n        d = Aa(d, c);\n        b = d.write(b, a);\n        b !== c && (d = d.slice(0, b));\n        return d;\n    }\n    return Fa(a, b);\n}\nz.from = function (a, b, c) { return Ca(null, a, b, c); };\nz.TYPED_ARRAY_SUPPORT && (z.prototype.__proto__ = Uint8Array.prototype, z.__proto__ = Uint8Array);\nfunction Ga(a) { if (\"number\" !== typeof a)\n    throw new TypeError('\"size\" argument must be a number'); if (0 > a)\n    throw new RangeError('\"size\" argument must not be negative'); }\nz.alloc = function (a, b, c) { Ga(a); a = 0 >= a ? Aa(null, a) : void 0 !== b ? \"string\" === typeof c ? Aa(null, a).fill(b, c) : Aa(null, a).fill(b) : Aa(null, a); return a; };\nfunction Ba(a, b) { Ga(b); a = Aa(a, 0 > b ? 0 : Ma(b) | 0); if (!z.TYPED_ARRAY_SUPPORT)\n    for (var c = 0; c < b; ++c)\n        a[c] = 0; return a; }\nz.allocUnsafe = function (a) { return Ba(null, a); };\nz.allocUnsafeSlow = function (a) { return Ba(null, a); };\nfunction Da(a, b) { var c = 0 > b.length ? 0 : Ma(b.length) | 0; a = Aa(a, c); for (var d = 0; d < c; d += 1)\n    a[d] = b[d] & 255; return a; }\nfunction Fa(a, b) { if (A(b)) {\n    var c = Ma(b.length) | 0;\n    a = Aa(a, c);\n    if (0 === a.length)\n        return a;\n    b.copy(a, 0, 0, c);\n    return a;\n} if (b) {\n    if (\"undefined\" !== typeof ArrayBuffer && b.buffer instanceof ArrayBuffer || \"length\" in b)\n        return (c = \"number\" !== typeof b.length) || (c = b.length, c = c !== c), c ? Aa(a, 0) : Da(a, b);\n    if (\"Buffer\" === b.type && ya(b.data))\n        return Da(a, b.data);\n} throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\"); }\nfunction Ma(a) { if (a >= (z.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823))\n    throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + (z.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823).toString(16) + \" bytes\"); return a | 0; }\nz.isBuffer = Na;\nfunction A(a) { return !(null == a || !a._isBuffer); }\nz.compare = function (a, b) { if (!A(a) || !A(b))\n    throw new TypeError(\"Arguments must be Buffers\"); if (a === b)\n    return 0; for (var c = a.length, d = b.length, e = 0, f = Math.min(c, d); e < f; ++e)\n    if (a[e] !== b[e]) {\n        c = a[e];\n        d = b[e];\n        break;\n    } return c < d ? -1 : d < c ? 1 : 0; };\nz.isEncoding = function (a) { switch (String(a).toLowerCase()) {\n    case \"hex\":\n    case \"utf8\":\n    case \"utf-8\":\n    case \"ascii\":\n    case \"latin1\":\n    case \"binary\":\n    case \"base64\":\n    case \"ucs2\":\n    case \"ucs-2\":\n    case \"utf16le\":\n    case \"utf-16le\": return !0;\n    default: return !1;\n} };\nz.concat = function (a, b) { if (!ya(a))\n    throw new TypeError('\"list\" argument must be an Array of Buffers'); if (0 === a.length)\n    return z.alloc(0); var c; if (void 0 === b)\n    for (c = b = 0; c < a.length; ++c)\n        b += a[c].length; b = z.allocUnsafe(b); var d = 0; for (c = 0; c < a.length; ++c) {\n    var e = a[c];\n    if (!A(e))\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    e.copy(b, d);\n    d += e.length;\n} return b; };\nfunction Ea(a, b) {\n    if (A(a))\n        return a.length;\n    if (\"undefined\" !== typeof ArrayBuffer && \"function\" === typeof ArrayBuffer.isView && (ArrayBuffer.isView(a) || a instanceof ArrayBuffer))\n        return a.byteLength;\n    \"string\" !== typeof a && (a = \"\" + a);\n    var c = a.length;\n    if (0 === c)\n        return 0;\n    for (var d = !1;;)\n        switch (b) {\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\": return c;\n            case \"utf8\":\n            case \"utf-8\":\n            case void 0: return Oa(a).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\": return 2 * c;\n            case \"hex\": return c >>> 1;\n            case \"base64\": return Pa(a).length;\n            default:\n                if (d)\n                    return Oa(a).length;\n                b = (\"\" + b).toLowerCase();\n                d = !0;\n        }\n}\nz.byteLength = Ea;\nfunction Qa(a, b, c) {\n    var d = !1;\n    if (void 0 === b || 0 > b)\n        b = 0;\n    if (b > this.length)\n        return \"\";\n    if (void 0 === c || c > this.length)\n        c = this.length;\n    if (0 >= c)\n        return \"\";\n    c >>>= 0;\n    b >>>= 0;\n    if (c <= b)\n        return \"\";\n    for (a || (a = \"utf8\");;)\n        switch (a) {\n            case \"hex\":\n                a = b;\n                b = c;\n                c = this.length;\n                if (!a || 0 > a)\n                    a = 0;\n                if (!b || 0 > b || b > c)\n                    b = c;\n                d = \"\";\n                for (c = a; c < b; ++c)\n                    a = d, d = this[c], d = 16 > d ? \"0\" + d.toString(16) : d.toString(16), d = a + d;\n                return d;\n            case \"utf8\":\n            case \"utf-8\": return Ra(this, b, c);\n            case \"ascii\":\n                a = \"\";\n                for (c = Math.min(this.length, c); b < c; ++b)\n                    a += String.fromCharCode(this[b] & 127);\n                return a;\n            case \"latin1\":\n            case \"binary\":\n                a = \"\";\n                for (c = Math.min(this.length, c); b < c; ++b)\n                    a += String.fromCharCode(this[b]);\n                return a;\n            case \"base64\": return b = 0 === b && c === this.length ? ra(this) : ra(this.slice(b, c)), b;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                b = this.slice(b, c);\n                c = \"\";\n                for (a = 0; a < b.length; a += 2)\n                    c += String.fromCharCode(b[a] + 256 * b[a + 1]);\n                return c;\n            default:\n                if (d)\n                    throw new TypeError(\"Unknown encoding: \" + a);\n                a = (a + \"\").toLowerCase();\n                d = !0;\n        }\n}\nz.prototype._isBuffer = !0;\nfunction Sa(a, b, c) { var d = a[b]; a[b] = a[c]; a[c] = d; }\nz.prototype.swap16 = function () { var a = this.length; if (0 !== a % 2)\n    throw new RangeError(\"Buffer size must be a multiple of 16-bits\"); for (var b = 0; b < a; b += 2)\n    Sa(this, b, b + 1); return this; };\nz.prototype.swap32 = function () { var a = this.length; if (0 !== a % 4)\n    throw new RangeError(\"Buffer size must be a multiple of 32-bits\"); for (var b = 0; b < a; b += 4)\n    Sa(this, b, b + 3), Sa(this, b + 1, b + 2); return this; };\nz.prototype.swap64 = function () { var a = this.length; if (0 !== a % 8)\n    throw new RangeError(\"Buffer size must be a multiple of 64-bits\"); for (var b = 0; b < a; b += 8)\n    Sa(this, b, b + 7), Sa(this, b + 1, b + 6), Sa(this, b + 2, b + 5), Sa(this, b + 3, b + 4); return this; };\nz.prototype.toString = function () { var a = this.length | 0; return 0 === a ? \"\" : 0 === arguments.length ? Ra(this, 0, a) : Qa.apply(this, arguments); };\nz.prototype.equals = function (a) { if (!A(a))\n    throw new TypeError(\"Argument must be a Buffer\"); return this === a ? !0 : 0 === z.compare(this, a); };\nz.prototype.inspect = function () { var a = \"\"; 0 < this.length && (a = this.toString(\"hex\", 0, 50).match(/.{2}/g).join(\" \"), 50 < this.length && (a += \" ... \")); return \"<Buffer \" + a + \">\"; };\nz.prototype.compare = function (a, b, c, d, e) {\n    if (!A(a))\n        throw new TypeError(\"Argument must be a Buffer\");\n    void 0 === b && (b = 0);\n    void 0 === c && (c = a ? a.length : 0);\n    void 0 === d && (d = 0);\n    void 0 === e && (e = this.length);\n    if (0 > b || c > a.length || 0 > d || e > this.length)\n        throw new RangeError(\"out of range index\");\n    if (d >= e && b >= c)\n        return 0;\n    if (d >= e)\n        return -1;\n    if (b >= c)\n        return 1;\n    b >>>= 0;\n    c >>>= 0;\n    d >>>= 0;\n    e >>>= 0;\n    if (this === a)\n        return 0;\n    var f = e - d, g = c - b, h = Math.min(f, g);\n    d = this.slice(d, e);\n    a = a.slice(b, c);\n    for (b = 0; b < h; ++b)\n        if (d[b] !== a[b]) {\n            f = d[b];\n            g = a[b];\n            break;\n        }\n    return f <\n        g ? -1 : g < f ? 1 : 0;\n};\nfunction Ta(a, b, c, d, e) {\n    if (0 === a.length)\n        return -1;\n    \"string\" === typeof c ? (d = c, c = 0) : 2147483647 < c ? c = 2147483647 : -2147483648 > c && (c = -2147483648);\n    c = +c;\n    isNaN(c) && (c = e ? 0 : a.length - 1);\n    0 > c && (c = a.length + c);\n    if (c >= a.length) {\n        if (e)\n            return -1;\n        c = a.length - 1;\n    }\n    else if (0 > c)\n        if (e)\n            c = 0;\n        else\n            return -1;\n    \"string\" === typeof b && (b = z.from(b, d));\n    if (A(b))\n        return 0 === b.length ? -1 : Ua(a, b, c, d, e);\n    if (\"number\" === typeof b)\n        return b &= 255, z.TYPED_ARRAY_SUPPORT && \"function\" === typeof Uint8Array.prototype.indexOf ? e ? Uint8Array.prototype.indexOf.call(a, b, c) :\n            Uint8Array.prototype.lastIndexOf.call(a, b, c) : Ua(a, [b], c, d, e);\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction Ua(a, b, c, d, e) { function f(a, b) { return 1 === g ? a[b] : a.readUInt16BE(b * g); } var g = 1, h = a.length, k = b.length; if (void 0 !== d && (d = String(d).toLowerCase(), \"ucs2\" === d || \"ucs-2\" === d || \"utf16le\" === d || \"utf-16le\" === d)) {\n    if (2 > a.length || 2 > b.length)\n        return -1;\n    g = 2;\n    h /= 2;\n    k /= 2;\n    c /= 2;\n} if (e)\n    for (d = -1; c < h; c++)\n        if (f(a, c) === f(b, -1 === d ? 0 : c - d)) {\n            if (-1 === d && (d = c), c - d + 1 === k)\n                return d * g;\n        }\n        else\n            -1 !== d && (c -= c - d), d = -1;\nelse\n    for (c + k > h && (c = h - k); 0 <= c; c--) {\n        h = !0;\n        for (d = 0; d < k; d++)\n            if (f(a, c + d) !== f(b, d)) {\n                h = !1;\n                break;\n            }\n        if (h)\n            return c;\n    } return -1; }\nz.prototype.includes = function (a, b, c) { return -1 !== this.indexOf(a, b, c); };\nz.prototype.indexOf = function (a, b, c) { return Ta(this, a, b, c, !0); };\nz.prototype.lastIndexOf = function (a, b, c) { return Ta(this, a, b, c, !1); };\nz.prototype.write = function (a, b, c, d) {\n    if (void 0 === b)\n        d = \"utf8\", c = this.length, b = 0;\n    else if (void 0 === c && \"string\" === typeof b)\n        d = b, c = this.length, b = 0;\n    else if (isFinite(b))\n        b |= 0, isFinite(c) ? (c |= 0, void 0 === d && (d = \"utf8\")) : (d = c, c = void 0);\n    else\n        throw Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    var e = this.length - b;\n    if (void 0 === c || c > e)\n        c = e;\n    if (0 < a.length && (0 > c || 0 > b) || b > this.length)\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    d || (d = \"utf8\");\n    for (e = !1;;)\n        switch (d) {\n            case \"hex\":\n                a: {\n                    b =\n                        Number(b) || 0;\n                    d = this.length - b;\n                    c ? (c = Number(c), c > d && (c = d)) : c = d;\n                    d = a.length;\n                    if (0 !== d % 2)\n                        throw new TypeError(\"Invalid hex string\");\n                    c > d / 2 && (c = d / 2);\n                    for (d = 0; d < c; ++d) {\n                        e = parseInt(a.substr(2 * d, 2), 16);\n                        if (isNaN(e)) {\n                            a = d;\n                            break a;\n                        }\n                        this[b + d] = e;\n                    }\n                    a = d;\n                }\n                return a;\n            case \"utf8\":\n            case \"utf-8\": return Va(Oa(a, this.length - b), this, b, c);\n            case \"ascii\": return Va(Wa(a), this, b, c);\n            case \"latin1\":\n            case \"binary\": return Va(Wa(a), this, b, c);\n            case \"base64\": return Va(Pa(a), this, b, c);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                d = a;\n                e = this.length -\n                    b;\n                for (var f = [], g = 0; g < d.length && !(0 > (e -= 2)); ++g) {\n                    var h = d.charCodeAt(g);\n                    a = h >> 8;\n                    h %= 256;\n                    f.push(h);\n                    f.push(a);\n                }\n                return Va(f, this, b, c);\n            default:\n                if (e)\n                    throw new TypeError(\"Unknown encoding: \" + d);\n                d = (\"\" + d).toLowerCase();\n                e = !0;\n        }\n};\nz.prototype.toJSON = function () { return { type: \"Buffer\", data: Array.prototype.slice.call(this._arr || this, 0) }; };\nfunction Ra(a, b, c) {\n    c = Math.min(a.length, c);\n    for (var d = []; b < c;) {\n        var e = a[b], f = null, g = 239 < e ? 4 : 223 < e ? 3 : 191 < e ? 2 : 1;\n        if (b + g <= c)\n            switch (g) {\n                case 1:\n                    128 > e && (f = e);\n                    break;\n                case 2:\n                    var h = a[b + 1];\n                    128 === (h & 192) && (e = (e & 31) << 6 | h & 63, 127 < e && (f = e));\n                    break;\n                case 3:\n                    h = a[b + 1];\n                    var k = a[b + 2];\n                    128 === (h & 192) && 128 === (k & 192) && (e = (e & 15) << 12 | (h & 63) << 6 | k & 63, 2047 < e && (55296 > e || 57343 < e) && (f = e));\n                    break;\n                case 4:\n                    h = a[b + 1];\n                    k = a[b + 2];\n                    var p = a[b + 3];\n                    128 === (h & 192) && 128 === (k & 192) && 128 === (p & 192) && (e = (e & 15) << 18 | (h & 63) << 12 | (k & 63) << 6 | p & 63, 65535 < e && 1114112 > e && (f =\n                        e));\n            }\n        null === f ? (f = 65533, g = 1) : 65535 < f && (f -= 65536, d.push(f >>> 10 & 1023 | 55296), f = 56320 | f & 1023);\n        d.push(f);\n        b += g;\n    }\n    a = d.length;\n    if (a <= ab)\n        d = String.fromCharCode.apply(String, d);\n    else {\n        c = \"\";\n        for (b = 0; b < a;)\n            c += String.fromCharCode.apply(String, d.slice(b, b += ab));\n        d = c;\n    }\n    return d;\n}\nvar ab = 4096;\nz.prototype.slice = function (a, b) { var c = this.length; a = ~~a; b = void 0 === b ? c : ~~b; 0 > a ? (a += c, 0 > a && (a = 0)) : a > c && (a = c); 0 > b ? (b += c, 0 > b && (b = 0)) : b > c && (b = c); b < a && (b = a); if (z.TYPED_ARRAY_SUPPORT)\n    b = this.subarray(a, b), b.__proto__ = z.prototype;\nelse {\n    c = b - a;\n    b = new z(c, void 0);\n    for (var d = 0; d < c; ++d)\n        b[d] = this[d + a];\n} return b; };\nfunction C(a, b, c) { if (0 !== a % 1 || 0 > a)\n    throw new RangeError(\"offset is not uint\"); if (a + b > c)\n    throw new RangeError(\"Trying to access beyond buffer length\"); }\nz.prototype.readUIntLE = function (a, b, c) { a |= 0; b |= 0; c || C(a, b, this.length); c = this[a]; for (var d = 1, e = 0; ++e < b && (d *= 256);)\n    c += this[a + e] * d; return c; };\nz.prototype.readUIntBE = function (a, b, c) { a |= 0; b |= 0; c || C(a, b, this.length); c = this[a + --b]; for (var d = 1; 0 < b && (d *= 256);)\n    c += this[a + --b] * d; return c; };\nz.prototype.readUInt8 = function (a, b) { b || C(a, 1, this.length); return this[a]; };\nz.prototype.readUInt16LE = function (a, b) { b || C(a, 2, this.length); return this[a] | this[a + 1] << 8; };\nz.prototype.readUInt16BE = function (a, b) { b || C(a, 2, this.length); return this[a] << 8 | this[a + 1]; };\nz.prototype.readUInt32LE = function (a, b) { b || C(a, 4, this.length); return (this[a] | this[a + 1] << 8 | this[a + 2] << 16) + 16777216 * this[a + 3]; };\nz.prototype.readUInt32BE = function (a, b) { b || C(a, 4, this.length); return 16777216 * this[a] + (this[a + 1] << 16 | this[a + 2] << 8 | this[a + 3]); };\nz.prototype.readIntLE = function (a, b, c) { a |= 0; b |= 0; c || C(a, b, this.length); c = this[a]; for (var d = 1, e = 0; ++e < b && (d *= 256);)\n    c += this[a + e] * d; c >= 128 * d && (c -= Math.pow(2, 8 * b)); return c; };\nz.prototype.readIntBE = function (a, b, c) { a |= 0; b |= 0; c || C(a, b, this.length); c = b; for (var d = 1, e = this[a + --c]; 0 < c && (d *= 256);)\n    e += this[a + --c] * d; e >= 128 * d && (e -= Math.pow(2, 8 * b)); return e; };\nz.prototype.readInt8 = function (a, b) { b || C(a, 1, this.length); return this[a] & 128 ? -1 * (255 - this[a] + 1) : this[a]; };\nz.prototype.readInt16LE = function (a, b) { b || C(a, 2, this.length); a = this[a] | this[a + 1] << 8; return a & 32768 ? a | 4294901760 : a; };\nz.prototype.readInt16BE = function (a, b) { b || C(a, 2, this.length); a = this[a + 1] | this[a] << 8; return a & 32768 ? a | 4294901760 : a; };\nz.prototype.readInt32LE = function (a, b) { b || C(a, 4, this.length); return this[a] | this[a + 1] << 8 | this[a + 2] << 16 | this[a + 3] << 24; };\nz.prototype.readInt32BE = function (a, b) { b || C(a, 4, this.length); return this[a] << 24 | this[a + 1] << 16 | this[a + 2] << 8 | this[a + 3]; };\nz.prototype.readFloatLE = function (a, b) { b || C(a, 4, this.length); return sa(this, a, !0, 23, 4); };\nz.prototype.readFloatBE = function (a, b) { b || C(a, 4, this.length); return sa(this, a, !1, 23, 4); };\nz.prototype.readDoubleLE = function (a, b) { b || C(a, 8, this.length); return sa(this, a, !0, 52, 8); };\nz.prototype.readDoubleBE = function (a, b) { b || C(a, 8, this.length); return sa(this, a, !1, 52, 8); };\nfunction E(a, b, c, d, e, f) { if (!A(a))\n    throw new TypeError('\"buffer\" argument must be a Buffer instance'); if (b > e || b < f)\n    throw new RangeError('\"value\" argument is out of bounds'); if (c + d > a.length)\n    throw new RangeError(\"Index out of range\"); }\nz.prototype.writeUIntLE = function (a, b, c, d) { a = +a; b |= 0; c |= 0; d || E(this, a, b, c, Math.pow(2, 8 * c) - 1, 0); d = 1; var e = 0; for (this[b] = a & 255; ++e < c && (d *= 256);)\n    this[b + e] = a / d & 255; return b + c; };\nz.prototype.writeUIntBE = function (a, b, c, d) { a = +a; b |= 0; c |= 0; d || E(this, a, b, c, Math.pow(2, 8 * c) - 1, 0); d = c - 1; var e = 1; for (this[b + d] = a & 255; 0 <= --d && (e *= 256);)\n    this[b + d] = a / e & 255; return b + c; };\nz.prototype.writeUInt8 = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 1, 255, 0); z.TYPED_ARRAY_SUPPORT || (a = Math.floor(a)); this[b] = a & 255; return b + 1; };\nfunction bb(a, b, c, d) { 0 > b && (b = 65535 + b + 1); for (var e = 0, f = Math.min(a.length - c, 2); e < f; ++e)\n    a[c + e] = (b & 255 << 8 * (d ? e : 1 - e)) >>> 8 * (d ? e : 1 - e); }\nz.prototype.writeUInt16LE = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 2, 65535, 0); z.TYPED_ARRAY_SUPPORT ? (this[b] = a & 255, this[b + 1] = a >>> 8) : bb(this, a, b, !0); return b + 2; };\nz.prototype.writeUInt16BE = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 2, 65535, 0); z.TYPED_ARRAY_SUPPORT ? (this[b] = a >>> 8, this[b + 1] = a & 255) : bb(this, a, b, !1); return b + 2; };\nfunction cb(a, b, c, d) { 0 > b && (b = 4294967295 + b + 1); for (var e = 0, f = Math.min(a.length - c, 4); e < f; ++e)\n    a[c + e] = b >>> 8 * (d ? e : 3 - e) & 255; }\nz.prototype.writeUInt32LE = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 4, 4294967295, 0); z.TYPED_ARRAY_SUPPORT ? (this[b + 3] = a >>> 24, this[b + 2] = a >>> 16, this[b + 1] = a >>> 8, this[b] = a & 255) : cb(this, a, b, !0); return b + 4; };\nz.prototype.writeUInt32BE = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 4, 4294967295, 0); z.TYPED_ARRAY_SUPPORT ? (this[b] = a >>> 24, this[b + 1] = a >>> 16, this[b + 2] = a >>> 8, this[b + 3] = a & 255) : cb(this, a, b, !1); return b + 4; };\nz.prototype.writeIntLE = function (a, b, c, d) { a = +a; b |= 0; d || (d = Math.pow(2, 8 * c - 1), E(this, a, b, c, d - 1, -d)); d = 0; var e = 1, f = 0; for (this[b] = a & 255; ++d < c && (e *= 256);)\n    0 > a && 0 === f && 0 !== this[b + d - 1] && (f = 1), this[b + d] = (a / e >> 0) - f & 255; return b + c; };\nz.prototype.writeIntBE = function (a, b, c, d) { a = +a; b |= 0; d || (d = Math.pow(2, 8 * c - 1), E(this, a, b, c, d - 1, -d)); d = c - 1; var e = 1, f = 0; for (this[b + d] = a & 255; 0 <= --d && (e *= 256);)\n    0 > a && 0 === f && 0 !== this[b + d + 1] && (f = 1), this[b + d] = (a / e >> 0) - f & 255; return b + c; };\nz.prototype.writeInt8 = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 1, 127, -128); z.TYPED_ARRAY_SUPPORT || (a = Math.floor(a)); 0 > a && (a = 255 + a + 1); this[b] = a & 255; return b + 1; };\nz.prototype.writeInt16LE = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 2, 32767, -32768); z.TYPED_ARRAY_SUPPORT ? (this[b] = a & 255, this[b + 1] = a >>> 8) : bb(this, a, b, !0); return b + 2; };\nz.prototype.writeInt16BE = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 2, 32767, -32768); z.TYPED_ARRAY_SUPPORT ? (this[b] = a >>> 8, this[b + 1] = a & 255) : bb(this, a, b, !1); return b + 2; };\nz.prototype.writeInt32LE = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 4, 2147483647, -2147483648); z.TYPED_ARRAY_SUPPORT ? (this[b] = a & 255, this[b + 1] = a >>> 8, this[b + 2] = a >>> 16, this[b + 3] = a >>> 24) : cb(this, a, b, !0); return b + 4; };\nz.prototype.writeInt32BE = function (a, b, c) { a = +a; b |= 0; c || E(this, a, b, 4, 2147483647, -2147483648); 0 > a && (a = 4294967295 + a + 1); z.TYPED_ARRAY_SUPPORT ? (this[b] = a >>> 24, this[b + 1] = a >>> 16, this[b + 2] = a >>> 8, this[b + 3] = a & 255) : cb(this, a, b, !1); return b + 4; };\nfunction db(a, b, c, d) { if (c + d > a.length)\n    throw new RangeError(\"Index out of range\"); if (0 > c)\n    throw new RangeError(\"Index out of range\"); }\nz.prototype.writeFloatLE = function (a, b, c) { c || db(this, a, b, 4); ta(this, a, b, !0, 23, 4); return b + 4; };\nz.prototype.writeFloatBE = function (a, b, c) { c || db(this, a, b, 4); ta(this, a, b, !1, 23, 4); return b + 4; };\nz.prototype.writeDoubleLE = function (a, b, c) { c || db(this, a, b, 8); ta(this, a, b, !0, 52, 8); return b + 8; };\nz.prototype.writeDoubleBE = function (a, b, c) { c || db(this, a, b, 8); ta(this, a, b, !1, 52, 8); return b + 8; };\nz.prototype.copy = function (a, b, c, d) {\n    c || (c = 0);\n    d || 0 === d || (d = this.length);\n    b >= a.length && (b = a.length);\n    b || (b = 0);\n    0 < d && d < c && (d = c);\n    if (d === c || 0 === a.length || 0 === this.length)\n        return 0;\n    if (0 > b)\n        throw new RangeError(\"targetStart out of bounds\");\n    if (0 > c || c >= this.length)\n        throw new RangeError(\"sourceStart out of bounds\");\n    if (0 > d)\n        throw new RangeError(\"sourceEnd out of bounds\");\n    d > this.length && (d = this.length);\n    a.length - b < d - c && (d = a.length - b + c);\n    var e = d - c;\n    if (this === a && c < b && b < d)\n        for (d = e - 1; 0 <= d; --d)\n            a[d + b] = this[d + c];\n    else if (1E3 > e ||\n        !z.TYPED_ARRAY_SUPPORT)\n        for (d = 0; d < e; ++d)\n            a[d + b] = this[d + c];\n    else\n        Uint8Array.prototype.set.call(a, this.subarray(c, c + e), b);\n    return e;\n};\nz.prototype.fill = function (a, b, c, d) {\n    if (\"string\" === typeof a) {\n        \"string\" === typeof b ? (d = b, b = 0, c = this.length) : \"string\" === typeof c && (d = c, c = this.length);\n        if (1 === a.length) {\n            var e = a.charCodeAt(0);\n            256 > e && (a = e);\n        }\n        if (void 0 !== d && \"string\" !== typeof d)\n            throw new TypeError(\"encoding must be a string\");\n        if (\"string\" === typeof d && !z.isEncoding(d))\n            throw new TypeError(\"Unknown encoding: \" + d);\n    }\n    else\n        \"number\" === typeof a && (a &= 255);\n    if (0 > b || this.length < b || this.length < c)\n        throw new RangeError(\"Out of range index\");\n    if (c <= b)\n        return this;\n    b >>>=\n        0;\n    c = void 0 === c ? this.length : c >>> 0;\n    a || (a = 0);\n    if (\"number\" === typeof a)\n        for (d = b; d < c; ++d)\n            this[d] = a;\n    else\n        for (a = A(a) ? a : Oa((new z(a, d)).toString()), e = a.length, d = 0; d < c - b; ++d)\n            this[d + b] = a[d % e];\n    return this;\n};\nvar eb = /[^+\\/0-9A-Za-z-_]/g;\nfunction Oa(a, b) {\n    b = b || Infinity;\n    for (var c, d = a.length, e = null, f = [], g = 0; g < d; ++g) {\n        c = a.charCodeAt(g);\n        if (55295 < c && 57344 > c) {\n            if (!e) {\n                if (56319 < c) {\n                    -1 < (b -= 3) && f.push(239, 191, 189);\n                    continue;\n                }\n                else if (g + 1 === d) {\n                    -1 < (b -= 3) && f.push(239, 191, 189);\n                    continue;\n                }\n                e = c;\n                continue;\n            }\n            if (56320 > c) {\n                -1 < (b -= 3) && f.push(239, 191, 189);\n                e = c;\n                continue;\n            }\n            c = (e - 55296 << 10 | c - 56320) + 65536;\n        }\n        else\n            e && -1 < (b -= 3) && f.push(239, 191, 189);\n        e = null;\n        if (128 > c) {\n            if (0 > --b)\n                break;\n            f.push(c);\n        }\n        else if (2048 > c) {\n            if (0 > (b -= 2))\n                break;\n            f.push(c >> 6 | 192, c & 63 | 128);\n        }\n        else if (65536 > c) {\n            if (0 > (b -= 3))\n                break;\n            f.push(c >> 12 | 224, c >> 6 & 63 | 128, c & 63 | 128);\n        }\n        else if (1114112 > c) {\n            if (0 > (b -= 4))\n                break;\n            f.push(c >> 18 | 240, c >> 12 & 63 | 128, c >> 6 & 63 | 128, c & 63 | 128);\n        }\n        else\n            throw Error(\"Invalid code point\");\n    }\n    return f;\n}\nfunction Wa(a) { for (var b = [], c = 0; c < a.length; ++c)\n    b.push(a.charCodeAt(c) & 255); return b; }\nfunction Pa(a) {\n    a = (a.trim ? a.trim() : a.replace(/^\\s+|\\s+$/g, \"\")).replace(eb, \"\");\n    if (2 > a.length)\n        a = \"\";\n    else\n        for (; 0 !== a.length % 4;)\n            a += \"=\";\n    oa || pa();\n    var b = a.length;\n    if (0 < b % 4)\n        throw Error(\"Invalid string. Length must be a multiple of 4\");\n    var c = \"=\" === a[b - 2] ? 2 : \"=\" === a[b - 1] ? 1 : 0;\n    var d = new ma(3 * b / 4 - c);\n    var e = 0 < c ? b - 4 : b;\n    var f = 0;\n    for (b = 0; b < e; b += 4) {\n        var g = y[a.charCodeAt(b)] << 18 | y[a.charCodeAt(b + 1)] << 12 | y[a.charCodeAt(b + 2)] << 6 | y[a.charCodeAt(b + 3)];\n        d[f++] = g >> 16 & 255;\n        d[f++] = g >> 8 & 255;\n        d[f++] = g & 255;\n    }\n    2 === c ? (g = y[a.charCodeAt(b)] << 2 |\n        y[a.charCodeAt(b + 1)] >> 4, d[f++] = g & 255) : 1 === c && (g = y[a.charCodeAt(b)] << 10 | y[a.charCodeAt(b + 1)] << 4 | y[a.charCodeAt(b + 2)] >> 2, d[f++] = g >> 8 & 255, d[f++] = g & 255);\n    return d;\n}\nfunction Va(a, b, c, d) { for (var e = 0; e < d && !(e + c >= b.length || e >= a.length); ++e)\n    b[e + c] = a[e]; return e; }\nfunction Na(a) { return null != a && (!!a._isBuffer || fb(a) || \"function\" === typeof a.readFloatLE && \"function\" === typeof a.slice && fb(a.slice(0, 0))); }\nfunction fb(a) { return !!a.constructor && \"function\" === typeof a.constructor.isBuffer && a.constructor.isBuffer(a); }\nvar gb = Object.freeze({ __proto__: null, INSPECT_MAX_BYTES: 50, kMaxLength: za, Buffer: z, SlowBuffer: function (a) { +a != a && (a = 0); return z.alloc(+a); }, isBuffer: Na }), F = u(function (a, b) {\n    function c(a) { for (var b = [], c = 1; c < arguments.length; c++)\n        b[c - 1] = arguments[c]; return new (gb.Buffer.bind.apply(gb.Buffer, d([void 0, a], b))); }\n    var d = l && l.__spreadArrays || function () {\n        for (var a = 0, b = 0, c = arguments.length; b < c; b++)\n            a += arguments[b].length;\n        a = Array(a);\n        var d = 0;\n        for (b = 0; b < c; b++)\n            for (var k = arguments[b], p = 0, n = k.length; p < n; p++, d++)\n                a[d] = k[p];\n        return a;\n    };\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    b.Buffer = gb.Buffer;\n    b.bufferAllocUnsafe = gb.Buffer.allocUnsafe || c;\n    b.bufferFrom = gb.Buffer.from || c;\n});\nt(F);\nfunction hb() { throw Error(\"setTimeout has not been defined\"); }\nfunction ib() { throw Error(\"clearTimeout has not been defined\"); }\nvar jb = hb, kb = ib;\n\"function\" === typeof la.setTimeout && (jb = setTimeout);\n\"function\" === typeof la.clearTimeout && (kb = clearTimeout);\nfunction pb(a) { if (jb === setTimeout)\n    return setTimeout(a, 0); if ((jb === hb || !jb) && setTimeout)\n    return jb = setTimeout, setTimeout(a, 0); try {\n    return jb(a, 0);\n}\ncatch (b) {\n    try {\n        return jb.call(null, a, 0);\n    }\n    catch (c) {\n        return jb.call(this, a, 0);\n    }\n} }\nfunction rb(a) { if (kb === clearTimeout)\n    return clearTimeout(a); if ((kb === ib || !kb) && clearTimeout)\n    return kb = clearTimeout, clearTimeout(a); try {\n    return kb(a);\n}\ncatch (b) {\n    try {\n        return kb.call(null, a);\n    }\n    catch (c) {\n        return kb.call(this, a);\n    }\n} }\nvar sb = [], tb = !1, ub, vb = -1;\nfunction wb() { tb && ub && (tb = !1, ub.length ? sb = ub.concat(sb) : vb = -1, sb.length && xb()); }\nfunction xb() { if (!tb) {\n    var a = pb(wb);\n    tb = !0;\n    for (var b = sb.length; b;) {\n        ub = sb;\n        for (sb = []; ++vb < b;)\n            ub && ub[vb].run();\n        vb = -1;\n        b = sb.length;\n    }\n    ub = null;\n    tb = !1;\n    rb(a);\n} }\nfunction G(a) { var b = Array(arguments.length - 1); if (1 < arguments.length)\n    for (var c = 1; c < arguments.length; c++)\n        b[c - 1] = arguments[c]; sb.push(new yb(a, b)); 1 !== sb.length || tb || pb(xb); }\nfunction yb(a, b) { this.fun = a; this.array = b; }\nyb.prototype.run = function () { this.fun.apply(null, this.array); };\nfunction zb() { }\nvar performance = la.performance || {}, Ab = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () { return (new Date).getTime(); }, Bb = new Date, Cb = { nextTick: G, title: \"browser\", browser: !0, env: {}, argv: [], version: \"\", versions: {}, on: zb, addListener: zb, once: zb, off: zb, removeListener: zb, removeAllListeners: zb, emit: zb, binding: function () { throw Error(\"process.binding is not supported\"); }, cwd: function () { return \"/\"; }, chdir: function () { throw Error(\"process.chdir is not supported\"); },\n    umask: function () { return 0; }, hrtime: function (a) { var b = .001 * Ab.call(performance), c = Math.floor(b); b = Math.floor(b % 1 * 1E9); a && (c -= a[0], b -= a[1], 0 > b && (c--, b += 1E9)); return [c, b]; }, platform: \"browser\", release: {}, config: {}, uptime: function () { return (new Date - Bb) / 1E3; } }, Db = \"function\" === typeof Object.create ? function (a, b) { a.super_ = b; a.prototype = Object.create(b.prototype, { constructor: { value: a, enumerable: !1, writable: !0, configurable: !0 } }); } : function (a, b) {\n    function c() { }\n    a.super_ = b;\n    c.prototype = b.prototype;\n    a.prototype = new c;\n    a.prototype.constructor = a;\n}, Eb = /%[sdj%]/g;\nfunction Fb(a) { if (!Gb(a)) {\n    for (var b = [], c = 0; c < arguments.length; c++)\n        b.push(H(arguments[c]));\n    return b.join(\" \");\n} c = 1; var d = arguments, e = d.length; b = String(a).replace(Eb, function (a) { if (\"%%\" === a)\n    return \"%\"; if (c >= e)\n    return a; switch (a) {\n    case \"%s\": return String(d[c++]);\n    case \"%d\": return Number(d[c++]);\n    case \"%j\": try {\n        return JSON.stringify(d[c++]);\n    }\n    catch (h) {\n        return \"[Circular]\";\n    }\n    default: return a;\n} }); for (var f = d[c]; c < e; f = d[++c])\n    b = null !== f && Hb(f) ? b + (\" \" + H(f)) : b + (\" \" + f); return b; }\nfunction Ib(a, b) { if (Jb(la.process))\n    return function () { return Ib(a, b).apply(this, arguments); }; if (!0 === Cb.noDeprecation)\n    return a; var c = !1; return function () { if (!c) {\n    if (Cb.throwDeprecation)\n        throw Error(b);\n    Cb.traceDeprecation ? console.trace(b) : console.error(b);\n    c = !0;\n} return a.apply(this, arguments); }; }\nvar Kb = {}, Lb;\nfunction Mb(a) { Jb(Lb) && (Lb = Cb.env.NODE_DEBUG || \"\"); a = a.toUpperCase(); Kb[a] || ((new RegExp(\"\\\\b\" + a + \"\\\\b\", \"i\")).test(Lb) ? Kb[a] = function () { var b = Fb.apply(null, arguments); console.error(\"%s %d: %s\", a, 0, b); } : Kb[a] = function () { }); return Kb[a]; }\nfunction H(a, b) { var c = { seen: [], stylize: Nb }; 3 <= arguments.length && (c.depth = arguments[2]); 4 <= arguments.length && (c.colors = arguments[3]); Ob(b) ? c.showHidden = b : b && Pb(c, b); Jb(c.showHidden) && (c.showHidden = !1); Jb(c.depth) && (c.depth = 2); Jb(c.colors) && (c.colors = !1); Jb(c.customInspect) && (c.customInspect = !0); c.colors && (c.stylize = Qb); return Rb(c, a, c.depth); }\nH.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };\nH.styles = { special: \"cyan\", number: \"yellow\", \"boolean\": \"yellow\", undefined: \"grey\", \"null\": \"bold\", string: \"green\", date: \"magenta\", regexp: \"red\" };\nfunction Qb(a, b) { return (b = H.styles[b]) ? \"\\u001b[\" + H.colors[b][0] + \"m\" + a + \"\\u001b[\" + H.colors[b][1] + \"m\" : a; }\nfunction Nb(a) { return a; }\nfunction Sb(a) { var b = {}; a.forEach(function (a) { b[a] = !0; }); return b; }\nfunction Rb(a, b, c) {\n    if (a.customInspect && b && Tb(b.inspect) && b.inspect !== H && (!b.constructor || b.constructor.prototype !== b)) {\n        var d = b.inspect(c, a);\n        Gb(d) || (d = Rb(a, d, c));\n        return d;\n    }\n    if (d = Ub(a, b))\n        return d;\n    var e = Object.keys(b), f = Sb(e);\n    a.showHidden && (e = Object.getOwnPropertyNames(b));\n    if (Vb(b) && (0 <= e.indexOf(\"message\") || 0 <= e.indexOf(\"description\")))\n        return Zb(b);\n    if (0 === e.length) {\n        if (Tb(b))\n            return a.stylize(\"[Function\" + (b.name ? \": \" + b.name : \"\") + \"]\", \"special\");\n        if (ac(b))\n            return a.stylize(RegExp.prototype.toString.call(b), \"regexp\");\n        if (bc(b))\n            return a.stylize(Date.prototype.toString.call(b), \"date\");\n        if (Vb(b))\n            return Zb(b);\n    }\n    d = \"\";\n    var g = !1, h = [\"{\", \"}\"];\n    cc(b) && (g = !0, h = [\"[\", \"]\"]);\n    Tb(b) && (d = \" [Function\" + (b.name ? \": \" + b.name : \"\") + \"]\");\n    ac(b) && (d = \" \" + RegExp.prototype.toString.call(b));\n    bc(b) && (d = \" \" + Date.prototype.toUTCString.call(b));\n    Vb(b) && (d = \" \" + Zb(b));\n    if (0 === e.length && (!g || 0 == b.length))\n        return h[0] + d + h[1];\n    if (0 > c)\n        return ac(b) ? a.stylize(RegExp.prototype.toString.call(b), \"regexp\") : a.stylize(\"[Object]\", \"special\");\n    a.seen.push(b);\n    e = g ?\n        dc(a, b, c, f, e) : e.map(function (d) { return ec(a, b, c, f, d, g); });\n    a.seen.pop();\n    return fc(e, d, h);\n}\nfunction Ub(a, b) { if (Jb(b))\n    return a.stylize(\"undefined\", \"undefined\"); if (Gb(b))\n    return b = \"'\" + JSON.stringify(b).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\", a.stylize(b, \"string\"); if (gc(b))\n    return a.stylize(\"\" + b, \"number\"); if (Ob(b))\n    return a.stylize(\"\" + b, \"boolean\"); if (null === b)\n    return a.stylize(\"null\", \"null\"); }\nfunction Zb(a) { return \"[\" + Error.prototype.toString.call(a) + \"]\"; }\nfunction dc(a, b, c, d, e) { for (var f = [], g = 0, h = b.length; g < h; ++g)\n    Object.prototype.hasOwnProperty.call(b, String(g)) ? f.push(ec(a, b, c, d, String(g), !0)) : f.push(\"\"); e.forEach(function (e) { e.match(/^\\d+$/) || f.push(ec(a, b, c, d, e, !0)); }); return f; }\nfunction ec(a, b, c, d, e, f) {\n    var g, h;\n    b = Object.getOwnPropertyDescriptor(b, e) || { value: b[e] };\n    b.get ? h = b.set ? a.stylize(\"[Getter/Setter]\", \"special\") : a.stylize(\"[Getter]\", \"special\") : b.set && (h = a.stylize(\"[Setter]\", \"special\"));\n    Object.prototype.hasOwnProperty.call(d, e) || (g = \"[\" + e + \"]\");\n    h || (0 > a.seen.indexOf(b.value) ? (h = null === c ? Rb(a, b.value, null) : Rb(a, b.value, c - 1), -1 < h.indexOf(\"\\n\") && (h = f ? h.split(\"\\n\").map(function (a) { return \"  \" + a; }).join(\"\\n\").substr(2) : \"\\n\" + h.split(\"\\n\").map(function (a) { return \"   \" + a; }).join(\"\\n\"))) :\n        h = a.stylize(\"[Circular]\", \"special\"));\n    if (Jb(g)) {\n        if (f && e.match(/^\\d+$/))\n            return h;\n        g = JSON.stringify(\"\" + e);\n        g.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/) ? (g = g.substr(1, g.length - 2), g = a.stylize(g, \"name\")) : (g = g.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\"), g = a.stylize(g, \"string\"));\n    }\n    return g + \": \" + h;\n}\nfunction fc(a, b, c) { return 60 < a.reduce(function (a, b) { b.indexOf(\"\\n\"); return a + b.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1; }, 0) ? c[0] + (\"\" === b ? \"\" : b + \"\\n \") + \" \" + a.join(\",\\n  \") + \" \" + c[1] : c[0] + b + \" \" + a.join(\", \") + \" \" + c[1]; }\nfunction cc(a) { return Array.isArray(a); }\nfunction Ob(a) { return \"boolean\" === typeof a; }\nfunction gc(a) { return \"number\" === typeof a; }\nfunction Gb(a) { return \"string\" === typeof a; }\nfunction Jb(a) { return void 0 === a; }\nfunction ac(a) { return Hb(a) && \"[object RegExp]\" === Object.prototype.toString.call(a); }\nfunction Hb(a) { return \"object\" === typeof a && null !== a; }\nfunction bc(a) { return Hb(a) && \"[object Date]\" === Object.prototype.toString.call(a); }\nfunction Vb(a) { return Hb(a) && (\"[object Error]\" === Object.prototype.toString.call(a) || a instanceof Error); }\nfunction Tb(a) { return \"function\" === typeof a; }\nfunction hc(a) { return null === a || \"boolean\" === typeof a || \"number\" === typeof a || \"string\" === typeof a || \"symbol\" === typeof a || \"undefined\" === typeof a; }\nfunction ic(a) { return 10 > a ? \"0\" + a.toString(10) : a.toString(10); }\nvar jc = \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \");\nfunction kc() { var a = new Date, b = [ic(a.getHours()), ic(a.getMinutes()), ic(a.getSeconds())].join(\":\"); return [a.getDate(), jc[a.getMonth()], b].join(\" \"); }\nfunction Pb(a, b) { if (!b || !Hb(b))\n    return a; for (var c = Object.keys(b), d = c.length; d--;)\n    a[c[d]] = b[c[d]]; return a; }\nvar lc = { inherits: Db, _extend: Pb, log: function () { console.log(\"%s - %s\", kc(), Fb.apply(null, arguments)); }, isBuffer: function (a) { return Na(a); }, isPrimitive: hc, isFunction: Tb, isError: Vb, isDate: bc, isObject: Hb, isRegExp: ac, isUndefined: Jb, isSymbol: function (a) { return \"symbol\" === typeof a; }, isString: Gb, isNumber: gc, isNullOrUndefined: function (a) { return null == a; }, isNull: function (a) { return null === a; }, isBoolean: Ob, isArray: cc, inspect: H, deprecate: Ib, format: Fb, debuglog: Mb };\nfunction mc(a, b) { if (a === b)\n    return 0; for (var c = a.length, d = b.length, e = 0, f = Math.min(c, d); e < f; ++e)\n    if (a[e] !== b[e]) {\n        c = a[e];\n        d = b[e];\n        break;\n    } return c < d ? -1 : d < c ? 1 : 0; }\nvar nc = Object.prototype.hasOwnProperty, oc = Object.keys || function (a) { var b = [], c; for (c in a)\n    nc.call(a, c) && b.push(c); return b; }, pc = Array.prototype.slice, qc;\nfunction rc() { return \"undefined\" !== typeof qc ? qc : qc = function () { return \"foo\" === function () { }.name; }(); }\nfunction sc(a) { return Na(a) || \"function\" !== typeof la.ArrayBuffer ? !1 : \"function\" === typeof ArrayBuffer.isView ? ArrayBuffer.isView(a) : a ? a instanceof DataView || a.buffer && a.buffer instanceof ArrayBuffer ? !0 : !1 : !1; }\nfunction I(a, b) { a || J(a, !0, b, \"==\", tc); }\nvar uc = /\\s*function\\s+([^\\(\\s]*)\\s*/;\nfunction vc(a) { if (Tb(a))\n    return rc() ? a.name : (a = a.toString().match(uc)) && a[1]; }\nI.AssertionError = wc;\nfunction wc(a) { this.name = \"AssertionError\"; this.actual = a.actual; this.expected = a.expected; this.operator = a.operator; a.message ? (this.message = a.message, this.generatedMessage = !1) : (this.message = xc(yc(this.actual), 128) + \" \" + this.operator + \" \" + xc(yc(this.expected), 128), this.generatedMessage = !0); var b = a.stackStartFunction || J; Error.captureStackTrace ? Error.captureStackTrace(this, b) : (a = Error(), a.stack && (a = a.stack, b = vc(b), b = a.indexOf(\"\\n\" + b), 0 <= b && (b = a.indexOf(\"\\n\", b + 1), a = a.substring(b + 1)), this.stack = a)); }\nDb(wc, Error);\nfunction xc(a, b) { return \"string\" === typeof a ? a.length < b ? a : a.slice(0, b) : a; }\nfunction yc(a) { if (rc() || !Tb(a))\n    return H(a); a = vc(a); return \"[Function\" + (a ? \": \" + a : \"\") + \"]\"; }\nfunction J(a, b, c, d, e) { throw new wc({ message: c, actual: a, expected: b, operator: d, stackStartFunction: e }); }\nI.fail = J;\nfunction tc(a, b) { a || J(a, !0, b, \"==\", tc); }\nI.ok = tc;\nI.equal = zc;\nfunction zc(a, b, c) { a != b && J(a, b, c, \"==\", zc); }\nI.notEqual = Ac;\nfunction Ac(a, b, c) { a == b && J(a, b, c, \"!=\", Ac); }\nI.deepEqual = Bc;\nfunction Bc(a, b, c) { Cc(a, b, !1) || J(a, b, c, \"deepEqual\", Bc); }\nI.deepStrictEqual = Dc;\nfunction Dc(a, b, c) { Cc(a, b, !0) || J(a, b, c, \"deepStrictEqual\", Dc); }\nfunction Cc(a, b, c, d) {\n    if (a === b)\n        return !0;\n    if (Na(a) && Na(b))\n        return 0 === mc(a, b);\n    if (bc(a) && bc(b))\n        return a.getTime() === b.getTime();\n    if (ac(a) && ac(b))\n        return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n    if (null !== a && \"object\" === typeof a || null !== b && \"object\" === typeof b) {\n        if (!sc(a) || !sc(b) || Object.prototype.toString.call(a) !== Object.prototype.toString.call(b) || a instanceof Float32Array || a instanceof Float64Array) {\n            if (Na(a) !== Na(b))\n                return !1;\n            d = d || { actual: [], expected: [] };\n            var e = d.actual.indexOf(a);\n            if (-1 !== e && e === d.expected.indexOf(b))\n                return !0;\n            d.actual.push(a);\n            d.expected.push(b);\n            return Ec(a, b, c, d);\n        }\n        return 0 === mc(new Uint8Array(a.buffer), new Uint8Array(b.buffer));\n    }\n    return c ? a === b : a == b;\n}\nfunction Fc(a) { return \"[object Arguments]\" == Object.prototype.toString.call(a); }\nfunction Ec(a, b, c, d) { if (null === a || void 0 === a || null === b || void 0 === b)\n    return !1; if (hc(a) || hc(b))\n    return a === b; if (c && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return !1; var e = Fc(a), f = Fc(b); if (e && !f || !e && f)\n    return !1; if (e)\n    return a = pc.call(a), b = pc.call(b), Cc(a, b, c); e = oc(a); var g = oc(b); if (e.length !== g.length)\n    return !1; e.sort(); g.sort(); for (f = e.length - 1; 0 <= f; f--)\n    if (e[f] !== g[f])\n        return !1; for (f = e.length - 1; 0 <= f; f--)\n    if (g = e[f], !Cc(a[g], b[g], c, d))\n        return !1; return !0; }\nI.notDeepEqual = Gc;\nfunction Gc(a, b, c) { Cc(a, b, !1) && J(a, b, c, \"notDeepEqual\", Gc); }\nI.notDeepStrictEqual = Hc;\nfunction Hc(a, b, c) { Cc(a, b, !0) && J(a, b, c, \"notDeepStrictEqual\", Hc); }\nI.strictEqual = Ic;\nfunction Ic(a, b, c) { a !== b && J(a, b, c, \"===\", Ic); }\nI.notStrictEqual = Jc;\nfunction Jc(a, b, c) { a === b && J(a, b, c, \"!==\", Jc); }\nfunction Kc(a, b) { if (!a || !b)\n    return !1; if (\"[object RegExp]\" == Object.prototype.toString.call(b))\n    return b.test(a); try {\n    if (a instanceof b)\n        return !0;\n}\ncatch (c) { } return Error.isPrototypeOf(b) ? !1 : !0 === b.call({}, a); }\nfunction Lc(a, b, c, d) { if (\"function\" !== typeof b)\n    throw new TypeError('\"block\" argument must be a function'); \"string\" === typeof c && (d = c, c = null); try {\n    b();\n}\ncatch (h) {\n    var e = h;\n} b = e; d = (c && c.name ? \" (\" + c.name + \").\" : \".\") + (d ? \" \" + d : \".\"); a && !b && J(b, c, \"Missing expected exception\" + d); e = \"string\" === typeof d; var f = !a && Vb(b), g = !a && b && !c; (f && e && Kc(b, c) || g) && J(b, c, \"Got unwanted exception\" + d); if (a && b && c && !Kc(b, c) || !a && b)\n    throw b; }\nI.throws = Mc;\nfunction Mc(a, b, c) { Lc(!0, a, b, c); }\nI.doesNotThrow = Nc;\nfunction Nc(a, b, c) { Lc(!1, a, b, c); }\nI.ifError = Oc;\nfunction Oc(a) { if (a)\n    throw a; }\nvar Pc = u(function (a, b) {\n    function c(a) { return function (a) { function b(b) { for (var c = [], e = 1; e < arguments.length; e++)\n        c[e - 1] = arguments[e]; c = a.call(this, d(b, c)) || this; c.code = b; c[h] = b; c.name = a.prototype.name + \" [\" + c[h] + \"]\"; return c; } g(b, a); return b; }(a); }\n    function d(a, b) { I.strictEqual(typeof a, \"string\"); var c = k[a]; I(c, \"An invalid error message key was used: \" + a + \".\"); if (\"function\" === typeof c)\n        a = c;\n    else {\n        a = lc.format;\n        if (void 0 === b || 0 === b.length)\n            return c;\n        b.unshift(c);\n    } return String(a.apply(null, b)); }\n    function e(a, b) {\n        k[a] =\n            \"function\" === typeof b ? b : String(b);\n    }\n    function f(a, b) { I(a, \"expected is required\"); I(\"string\" === typeof b, \"thing is required\"); if (Array.isArray(a)) {\n        var c = a.length;\n        I(0 < c, \"At least one expected value needs to be specified\");\n        a = a.map(function (a) { return String(a); });\n        return 2 < c ? \"one of \" + b + \" \" + a.slice(0, c - 1).join(\", \") + \", or \" + a[c - 1] : 2 === c ? \"one of \" + b + \" \" + a[0] + \" or \" + a[1] : \"of \" + b + \" \" + a[0];\n    } return \"of \" + b + \" \" + String(a); }\n    var g = l && l.__extends || function () {\n        function a(b, c) {\n            a = Object.setPrototypeOf || { __proto__: [] } instanceof\n                Array && function (a, b) { a.__proto__ = b; } || function (a, b) { for (var c in b)\n                b.hasOwnProperty(c) && (a[c] = b[c]); };\n            return a(b, c);\n        }\n        return function (b, c) { function d() { this.constructor = b; } a(b, c); b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d); };\n    }();\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    var h = \"undefined\" === typeof Symbol ? \"_kCode\" : Symbol(\"code\"), k = {};\n    a = function (a) {\n        function c(c) {\n            if (\"object\" !== typeof c || null === c)\n                throw new b.TypeError(\"ERR_INVALID_ARG_TYPE\", \"options\", \"object\");\n            var d = c.message ?\n                a.call(this, c.message) || this : a.call(this, lc.inspect(c.actual).slice(0, 128) + \" \" + (c.operator + \" \" + lc.inspect(c.expected).slice(0, 128))) || this;\n            d.generatedMessage = !c.message;\n            d.name = \"AssertionError [ERR_ASSERTION]\";\n            d.code = \"ERR_ASSERTION\";\n            d.actual = c.actual;\n            d.expected = c.expected;\n            d.operator = c.operator;\n            b.Error.captureStackTrace(d, c.stackStartFunction);\n            return d;\n        }\n        g(c, a);\n        return c;\n    }(l.Error);\n    b.AssertionError = a;\n    b.message = d;\n    b.E = e;\n    b.Error = c(l.Error);\n    b.TypeError = c(l.TypeError);\n    b.RangeError = c(l.RangeError);\n    e(\"ERR_ARG_NOT_ITERABLE\", \"%s must be iterable\");\n    e(\"ERR_ASSERTION\", \"%s\");\n    e(\"ERR_BUFFER_OUT_OF_BOUNDS\", function (a, b) { return b ? \"Attempt to write outside buffer bounds\" : '\"' + a + '\" is outside of buffer bounds'; });\n    e(\"ERR_CHILD_CLOSED_BEFORE_REPLY\", \"Child closed before reply received\");\n    e(\"ERR_CONSOLE_WRITABLE_STREAM\", \"Console expects a writable stream instance for %s\");\n    e(\"ERR_CPU_USAGE\", \"Unable to obtain cpu usage %s\");\n    e(\"ERR_DNS_SET_SERVERS_FAILED\", function (a, b) { return 'c-ares failed to set servers: \"' + a + '\" [' + b + \"]\"; });\n    e(\"ERR_FALSY_VALUE_REJECTION\", \"Promise was rejected with falsy value\");\n    e(\"ERR_ENCODING_NOT_SUPPORTED\", function (a) { return 'The \"' + a + '\" encoding is not supported'; });\n    e(\"ERR_ENCODING_INVALID_ENCODED_DATA\", function (a) { return \"The encoded data was not valid for encoding \" + a; });\n    e(\"ERR_HTTP_HEADERS_SENT\", \"Cannot render headers after they are sent to the client\");\n    e(\"ERR_HTTP_INVALID_STATUS_CODE\", \"Invalid status code: %s\");\n    e(\"ERR_HTTP_TRAILER_INVALID\", \"Trailers are invalid with this transfer encoding\");\n    e(\"ERR_INDEX_OUT_OF_RANGE\", \"Index out of range\");\n    e(\"ERR_INVALID_ARG_TYPE\", function (a, b, c) { I(a, \"name is required\"); if (b.includes(\"not \")) {\n        var d = \"must not be\";\n        b = b.split(\"not \")[1];\n    }\n    else\n        d = \"must be\"; if (Array.isArray(a))\n        d = \"The \" + a.map(function (a) { return '\"' + a + '\"'; }).join(\", \") + \" arguments \" + d + \" \" + f(b, \"type\");\n    else if (a.includes(\" argument\"))\n        d = \"The \" + a + \" \" + d + \" \" + f(b, \"type\");\n    else {\n        var e = a.includes(\".\") ? \"property\" : \"argument\";\n        d = 'The \"' + a + '\" ' + e + \" \" + d + \" \" + f(b, \"type\");\n    } 3 <= arguments.length && (d += \". Received type \" + (null !== c ? typeof c : \"null\")); return d; });\n    e(\"ERR_INVALID_ARRAY_LENGTH\", function (a, b, c) { I.strictEqual(typeof c, \"number\"); return 'The array \"' + a + '\" (length ' + c + \") must be of length \" + b + \".\"; });\n    e(\"ERR_INVALID_BUFFER_SIZE\", \"Buffer size must be a multiple of %s\");\n    e(\"ERR_INVALID_CALLBACK\", \"Callback must be a function\");\n    e(\"ERR_INVALID_CHAR\", \"Invalid character in %s\");\n    e(\"ERR_INVALID_CURSOR_POS\", \"Cannot set cursor row without setting its column\");\n    e(\"ERR_INVALID_FD\", '\"fd\" must be a positive integer: %s');\n    e(\"ERR_INVALID_FILE_URL_HOST\", 'File URL host must be \"localhost\" or empty on %s');\n    e(\"ERR_INVALID_FILE_URL_PATH\", \"File URL path %s\");\n    e(\"ERR_INVALID_HANDLE_TYPE\", \"This handle type cannot be sent\");\n    e(\"ERR_INVALID_IP_ADDRESS\", \"Invalid IP address: %s\");\n    e(\"ERR_INVALID_OPT_VALUE\", function (a, b) { return 'The value \"' + String(b) + '\" is invalid for option \"' + a + '\"'; });\n    e(\"ERR_INVALID_OPT_VALUE_ENCODING\", function (a) { return 'The value \"' + String(a) + '\" is invalid for option \"encoding\"'; });\n    e(\"ERR_INVALID_REPL_EVAL_CONFIG\", 'Cannot specify both \"breakEvalOnSigint\" and \"eval\" for REPL');\n    e(\"ERR_INVALID_SYNC_FORK_INPUT\", \"Asynchronous forks do not support Buffer, Uint8Array or string input: %s\");\n    e(\"ERR_INVALID_THIS\", 'Value of \"this\" must be of type %s');\n    e(\"ERR_INVALID_TUPLE\", \"%s must be an iterable %s tuple\");\n    e(\"ERR_INVALID_URL\", \"Invalid URL: %s\");\n    e(\"ERR_INVALID_URL_SCHEME\", function (a) { return \"The URL must be \" + f(a, \"scheme\"); });\n    e(\"ERR_IPC_CHANNEL_CLOSED\", \"Channel closed\");\n    e(\"ERR_IPC_DISCONNECTED\", \"IPC channel is already disconnected\");\n    e(\"ERR_IPC_ONE_PIPE\", \"Child process can have only one IPC pipe\");\n    e(\"ERR_IPC_SYNC_FORK\", \"IPC cannot be used with synchronous forks\");\n    e(\"ERR_MISSING_ARGS\", function () { for (var a = [], b = 0; b < arguments.length; b++)\n        a[b] = arguments[b]; I(0 < a.length, \"At least one arg needs to be specified\"); b = \"The \"; var c = a.length; a = a.map(function (a) { return '\"' + a + '\"'; }); switch (c) {\n        case 1:\n            b += a[0] + \" argument\";\n            break;\n        case 2:\n            b += a[0] + \" and \" + a[1] + \" arguments\";\n            break;\n        default: b += a.slice(0, c - 1).join(\", \"), b += \", and \" + a[c - 1] + \" arguments\";\n    } return b + \" must be specified\"; });\n    e(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\");\n    e(\"ERR_NAPI_CONS_FUNCTION\", \"Constructor must be a function\");\n    e(\"ERR_NAPI_CONS_PROTOTYPE_OBJECT\", \"Constructor.prototype must be an object\");\n    e(\"ERR_NO_CRYPTO\", \"Node.js is not compiled with OpenSSL crypto support\");\n    e(\"ERR_NO_LONGER_SUPPORTED\", \"%s is no longer supported\");\n    e(\"ERR_PARSE_HISTORY_DATA\", \"Could not parse history data in %s\");\n    e(\"ERR_SOCKET_ALREADY_BOUND\", \"Socket is already bound\");\n    e(\"ERR_SOCKET_BAD_PORT\", \"Port should be > 0 and < 65536\");\n    e(\"ERR_SOCKET_BAD_TYPE\", \"Bad socket type specified. Valid types are: udp4, udp6\");\n    e(\"ERR_SOCKET_CANNOT_SEND\", \"Unable to send data\");\n    e(\"ERR_SOCKET_CLOSED\", \"Socket is closed\");\n    e(\"ERR_SOCKET_DGRAM_NOT_RUNNING\", \"Not running\");\n    e(\"ERR_STDERR_CLOSE\", \"process.stderr cannot be closed\");\n    e(\"ERR_STDOUT_CLOSE\", \"process.stdout cannot be closed\");\n    e(\"ERR_STREAM_WRAP\", \"Stream has StringDecoder set or is in objectMode\");\n    e(\"ERR_TLS_CERT_ALTNAME_INVALID\", \"Hostname/IP does not match certificate's altnames: %s\");\n    e(\"ERR_TLS_DH_PARAM_SIZE\", function (a) { return \"DH parameter size \" + a + \" is less than 2048\"; });\n    e(\"ERR_TLS_HANDSHAKE_TIMEOUT\", \"TLS handshake timeout\");\n    e(\"ERR_TLS_RENEGOTIATION_FAILED\", \"Failed to renegotiate\");\n    e(\"ERR_TLS_REQUIRED_SERVER_NAME\", '\"servername\" is required parameter for Server.addContext');\n    e(\"ERR_TLS_SESSION_ATTACK\", \"TSL session renegotiation attack detected\");\n    e(\"ERR_TRANSFORM_ALREADY_TRANSFORMING\", \"Calling transform done when still transforming\");\n    e(\"ERR_TRANSFORM_WITH_LENGTH_0\", \"Calling transform done when writableState.length != 0\");\n    e(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\");\n    e(\"ERR_UNKNOWN_SIGNAL\", \"Unknown signal: %s\");\n    e(\"ERR_UNKNOWN_STDIN_TYPE\", \"Unknown stdin file type\");\n    e(\"ERR_UNKNOWN_STREAM_TYPE\", \"Unknown stream file type\");\n    e(\"ERR_V8BREAKITERATOR\", \"Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl\");\n});\nt(Pc);\nvar K = u(function (a, b) { Object.defineProperty(b, \"__esModule\", { value: !0 }); b.ENCODING_UTF8 = \"utf8\"; b.assertEncoding = function (a) { if (a && !F.Buffer.isEncoding(a))\n    throw new Pc.TypeError(\"ERR_INVALID_OPT_VALUE_ENCODING\", a); }; b.strToEncoding = function (a, d) { return d && d !== b.ENCODING_UTF8 ? \"buffer\" === d ? new F.Buffer(a) : (new F.Buffer(a)).toString(d) : a; }; });\nt(K);\nvar Qc = u(function (a, b) {\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    var c = w.constants.S_IFMT, d = w.constants.S_IFDIR, e = w.constants.S_IFREG, f = w.constants.S_IFBLK, g = w.constants.S_IFCHR, h = w.constants.S_IFLNK, k = w.constants.S_IFIFO, p = w.constants.S_IFSOCK;\n    a = function () {\n        function a() { this.name = \"\"; this.mode = 0; }\n        a.build = function (b, c) { var d = new a, e = b.getNode().mode; d.name = K.strToEncoding(b.getName(), c); d.mode = e; return d; };\n        a.prototype._checkModeProperty = function (a) { return (this.mode & c) === a; };\n        a.prototype.isDirectory =\n            function () { return this._checkModeProperty(d); };\n        a.prototype.isFile = function () { return this._checkModeProperty(e); };\n        a.prototype.isBlockDevice = function () { return this._checkModeProperty(f); };\n        a.prototype.isCharacterDevice = function () { return this._checkModeProperty(g); };\n        a.prototype.isSymbolicLink = function () { return this._checkModeProperty(h); };\n        a.prototype.isFIFO = function () { return this._checkModeProperty(k); };\n        a.prototype.isSocket = function () { return this._checkModeProperty(p); };\n        return a;\n    }();\n    b.Dirent = a;\n    b.default = a;\n});\nt(Qc);\nfunction Rc(a, b) { for (var c = 0, d = a.length - 1; 0 <= d; d--) {\n    var e = a[d];\n    \".\" === e ? a.splice(d, 1) : \"..\" === e ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--);\n} if (b)\n    for (; c--; c)\n        a.unshift(\"..\"); return a; }\nvar Sc = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nfunction Tc() { for (var a = \"\", b = !1, c = arguments.length - 1; -1 <= c && !b; c--) {\n    var d = 0 <= c ? arguments[c] : \"/\";\n    if (\"string\" !== typeof d)\n        throw new TypeError(\"Arguments to path.resolve must be strings\");\n    d && (a = d + \"/\" + a, b = \"/\" === d.charAt(0));\n} a = Rc(Uc(a.split(\"/\"), function (a) { return !!a; }), !b).join(\"/\"); return (b ? \"/\" : \"\") + a || \".\"; }\nfunction Vc(a) { var b = Wc(a), c = \"/\" === Xc(a, -1); (a = Rc(Uc(a.split(\"/\"), function (a) { return !!a; }), !b).join(\"/\")) || b || (a = \".\"); a && c && (a += \"/\"); return (b ? \"/\" : \"\") + a; }\nfunction Wc(a) { return \"/\" === a.charAt(0); }\nfunction Yc(a, b) { function c(a) { for (var b = 0; b < a.length && \"\" === a[b]; b++)\n    ; for (var c = a.length - 1; 0 <= c && \"\" === a[c]; c--)\n    ; return b > c ? [] : a.slice(b, c - b + 1); } a = Tc(a).substr(1); b = Tc(b).substr(1); a = c(a.split(\"/\")); b = c(b.split(\"/\")); for (var d = Math.min(a.length, b.length), e = d, f = 0; f < d; f++)\n    if (a[f] !== b[f]) {\n        e = f;\n        break;\n    } d = []; for (f = e; f < a.length; f++)\n    d.push(\"..\"); d = d.concat(b.slice(e)); return d.join(\"/\"); }\nvar Zc = { extname: function (a) { return Sc.exec(a).slice(1)[3]; }, basename: function (a, b) { a = Sc.exec(a).slice(1)[2]; b && a.substr(-1 * b.length) === b && (a = a.substr(0, a.length - b.length)); return a; }, dirname: function (a) { var b = Sc.exec(a).slice(1); a = b[0]; b = b[1]; if (!a && !b)\n        return \".\"; b && (b = b.substr(0, b.length - 1)); return a + b; }, sep: \"/\", delimiter: \":\", relative: Yc, join: function () {\n        var a = Array.prototype.slice.call(arguments, 0);\n        return Vc(Uc(a, function (a) {\n            if (\"string\" !== typeof a)\n                throw new TypeError(\"Arguments to path.join must be strings\");\n            return a;\n        }).join(\"/\"));\n    }, isAbsolute: Wc, normalize: Vc, resolve: Tc };\nfunction Uc(a, b) { if (a.filter)\n    return a.filter(b); for (var c = [], d = 0; d < a.length; d++)\n    b(a[d], d, a) && c.push(a[d]); return c; }\nvar Xc = \"b\" === \"ab\".substr(-1) ? function (a, b, c) { return a.substr(b, c); } : function (a, b, c) { 0 > b && (b = a.length + b); return a.substr(b, c); }, $c = u(function (a, b) { Object.defineProperty(b, \"__esModule\", { value: !0 }); a = \"function\" === typeof setImmediate ? setImmediate.bind(l) : setTimeout.bind(l); b.default = a; });\nt($c);\nvar L = u(function (a, b) { function c() { var a = Cb || {}; a.getuid || (a.getuid = function () { return 0; }); a.getgid || (a.getgid = function () { return 0; }); a.cwd || (a.cwd = function () { return \"/\"; }); a.nextTick || (a.nextTick = $c.default); a.emitWarning || (a.emitWarning = function (a, b) { console.warn(\"\" + b + (b ? \": \" : \"\") + a); }); a.env || (a.env = {}); return a; } Object.defineProperty(b, \"__esModule\", { value: !0 }); b.createProcess = c; b.default = c(); });\nt(L);\nfunction ad() { }\nad.prototype = Object.create(null);\nfunction O() { O.init.call(this); }\nO.EventEmitter = O;\nO.usingDomains = !1;\nO.prototype.domain = void 0;\nO.prototype._events = void 0;\nO.prototype._maxListeners = void 0;\nO.defaultMaxListeners = 10;\nO.init = function () { this.domain = null; this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new ad, this._eventsCount = 0); this._maxListeners = this._maxListeners || void 0; };\nO.prototype.setMaxListeners = function (a) { if (\"number\" !== typeof a || 0 > a || isNaN(a))\n    throw new TypeError('\"n\" argument must be a positive number'); this._maxListeners = a; return this; };\nO.prototype.getMaxListeners = function () { return void 0 === this._maxListeners ? O.defaultMaxListeners : this._maxListeners; };\nO.prototype.emit = function (a) {\n    var b, c;\n    var d = \"error\" === a;\n    if (b = this._events)\n        d = d && null == b.error;\n    else if (!d)\n        return !1;\n    var e = this.domain;\n    if (d) {\n        b = arguments[1];\n        if (e)\n            b || (b = Error('Uncaught, unspecified \"error\" event')), b.domainEmitter = this, b.domain = e, b.domainThrown = !1, e.emit(\"error\", b);\n        else {\n            if (b instanceof Error)\n                throw b;\n            e = Error('Uncaught, unspecified \"error\" event. (' + b + \")\");\n            e.context = b;\n            throw e;\n        }\n        return !1;\n    }\n    e = b[a];\n    if (!e)\n        return !1;\n    b = \"function\" === typeof e;\n    var f = arguments.length;\n    switch (f) {\n        case 1:\n            if (b)\n                e.call(this);\n            else\n                for (b = e.length, e = bd(e, b), d = 0; d < b; ++d)\n                    e[d].call(this);\n            break;\n        case 2:\n            d = arguments[1];\n            if (b)\n                e.call(this, d);\n            else\n                for (b = e.length, e = bd(e, b), f = 0; f < b; ++f)\n                    e[f].call(this, d);\n            break;\n        case 3:\n            d = arguments[1];\n            f = arguments[2];\n            if (b)\n                e.call(this, d, f);\n            else\n                for (b = e.length, e = bd(e, b), c = 0; c < b; ++c)\n                    e[c].call(this, d, f);\n            break;\n        case 4:\n            d = arguments[1];\n            f = arguments[2];\n            c = arguments[3];\n            if (b)\n                e.call(this, d, f, c);\n            else {\n                b = e.length;\n                e = bd(e, b);\n                for (var g = 0; g < b; ++g)\n                    e[g].call(this, d, f, c);\n            }\n            break;\n        default:\n            d = Array(f - 1);\n            for (c = 1; c < f; c++)\n                d[c - 1] = arguments[c];\n            if (b)\n                e.apply(this, d);\n            else\n                for (b = e.length, e = bd(e, b), f = 0; f < b; ++f)\n                    e[f].apply(this, d);\n    }\n    return !0;\n};\nfunction cd(a, b, c, d) {\n    var e;\n    if (\"function\" !== typeof c)\n        throw new TypeError('\"listener\" argument must be a function');\n    if (e = a._events) {\n        e.newListener && (a.emit(\"newListener\", b, c.listener ? c.listener : c), e = a._events);\n        var f = e[b];\n    }\n    else\n        e = a._events = new ad, a._eventsCount = 0;\n    f ? (\"function\" === typeof f ? f = e[b] = d ? [c, f] : [f, c] : d ? f.unshift(c) : f.push(c), f.warned || (c = void 0 === a._maxListeners ? O.defaultMaxListeners : a._maxListeners) && 0 < c && f.length > c && (f.warned = !0, c = Error(\"Possible EventEmitter memory leak detected. \" + f.length +\n        \" \" + b + \" listeners added. Use emitter.setMaxListeners() to increase limit\"), c.name = \"MaxListenersExceededWarning\", c.emitter = a, c.type = b, c.count = f.length, \"function\" === typeof console.warn ? console.warn(c) : console.log(c))) : (e[b] = c, ++a._eventsCount);\n    return a;\n}\nO.prototype.addListener = function (a, b) { return cd(this, a, b, !1); };\nO.prototype.on = O.prototype.addListener;\nO.prototype.prependListener = function (a, b) { return cd(this, a, b, !0); };\nfunction dd(a, b, c) { function d() { a.removeListener(b, d); e || (e = !0, c.apply(a, arguments)); } var e = !1; d.listener = c; return d; }\nO.prototype.once = function (a, b) { if (\"function\" !== typeof b)\n    throw new TypeError('\"listener\" argument must be a function'); this.on(a, dd(this, a, b)); return this; };\nO.prototype.prependOnceListener = function (a, b) { if (\"function\" !== typeof b)\n    throw new TypeError('\"listener\" argument must be a function'); this.prependListener(a, dd(this, a, b)); return this; };\nO.prototype.removeListener = function (a, b) {\n    var c;\n    if (\"function\" !== typeof b)\n        throw new TypeError('\"listener\" argument must be a function');\n    var d = this._events;\n    if (!d)\n        return this;\n    var e = d[a];\n    if (!e)\n        return this;\n    if (e === b || e.listener && e.listener === b)\n        0 === --this._eventsCount ? this._events = new ad : (delete d[a], d.removeListener && this.emit(\"removeListener\", a, e.listener || b));\n    else if (\"function\" !== typeof e) {\n        var f = -1;\n        for (c = e.length; 0 < c--;)\n            if (e[c] === b || e[c].listener && e[c].listener === b) {\n                var g = e[c].listener;\n                f = c;\n                break;\n            }\n        if (0 >\n            f)\n            return this;\n        if (1 === e.length) {\n            e[0] = void 0;\n            if (0 === --this._eventsCount)\n                return this._events = new ad, this;\n            delete d[a];\n        }\n        else {\n            c = f + 1;\n            for (var h = e.length; c < h; f += 1, c += 1)\n                e[f] = e[c];\n            e.pop();\n        }\n        d.removeListener && this.emit(\"removeListener\", a, g || b);\n    }\n    return this;\n};\nO.prototype.removeAllListeners = function (a) {\n    var b = this._events;\n    if (!b)\n        return this;\n    if (!b.removeListener)\n        return 0 === arguments.length ? (this._events = new ad, this._eventsCount = 0) : b[a] && (0 === --this._eventsCount ? this._events = new ad : delete b[a]), this;\n    if (0 === arguments.length) {\n        b = Object.keys(b);\n        for (var c = 0, d; c < b.length; ++c)\n            d = b[c], \"removeListener\" !== d && this.removeAllListeners(d);\n        this.removeAllListeners(\"removeListener\");\n        this._events = new ad;\n        this._eventsCount = 0;\n        return this;\n    }\n    b = b[a];\n    if (\"function\" === typeof b)\n        this.removeListener(a, b);\n    else if (b) {\n        do\n            this.removeListener(a, b[b.length - 1]);\n        while (b[0]);\n    }\n    return this;\n};\nO.prototype.listeners = function (a) { var b = this._events; if (b)\n    if (a = b[a])\n        if (\"function\" === typeof a)\n            a = [a.listener || a];\n        else {\n            b = Array(a.length);\n            for (var c = 0; c < b.length; ++c)\n                b[c] = a[c].listener || a[c];\n            a = b;\n        }\n    else\n        a = [];\nelse\n    a = []; return a; };\nO.listenerCount = function (a, b) { return \"function\" === typeof a.listenerCount ? a.listenerCount(b) : ed.call(a, b); };\nO.prototype.listenerCount = ed;\nfunction ed(a) { var b = this._events; if (b) {\n    a = b[a];\n    if (\"function\" === typeof a)\n        return 1;\n    if (a)\n        return a.length;\n} return 0; }\nO.prototype.eventNames = function () { return 0 < this._eventsCount ? Reflect.ownKeys(this._events) : []; };\nfunction bd(a, b) { for (var c = Array(b); b--;)\n    c[b] = a[b]; return c; }\nvar fd = u(function (a, b) {\n    var c = l && l.__extends || function () { function a(b, c) { a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (a, b) { a.__proto__ = b; } || function (a, b) { for (var c in b)\n        b.hasOwnProperty(c) && (a[c] = b[c]); }; return a(b, c); } return function (b, c) { function d() { this.constructor = b; } a(b, c); b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d); }; }();\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    var d = w.constants.S_IFMT, e = w.constants.S_IFDIR, f = w.constants.S_IFREG, g = w.constants.S_IFLNK, h = w.constants.O_APPEND;\n    b.SEP = \"/\";\n    a = function (a) {\n        function b(b, c) { void 0 === c && (c = 438); var d = a.call(this) || this; d.uid = L.default.getuid(); d.gid = L.default.getgid(); d.atime = new Date; d.mtime = new Date; d.ctime = new Date; d.perm = 438; d.mode = f; d.nlink = 1; d.perm = c; d.mode |= c; d.ino = b; return d; }\n        c(b, a);\n        b.prototype.getString = function (a) { void 0 === a && (a = \"utf8\"); return this.getBuffer().toString(a); };\n        b.prototype.setString = function (a) { this.buf = F.bufferFrom(a, \"utf8\"); this.touch(); };\n        b.prototype.getBuffer = function () {\n            this.buf || this.setBuffer(F.bufferAllocUnsafe(0));\n            return F.bufferFrom(this.buf);\n        };\n        b.prototype.setBuffer = function (a) { this.buf = F.bufferFrom(a); this.touch(); };\n        b.prototype.getSize = function () { return this.buf ? this.buf.length : 0; };\n        b.prototype.setModeProperty = function (a) { this.mode = this.mode & ~d | a; };\n        b.prototype.setIsFile = function () { this.setModeProperty(f); };\n        b.prototype.setIsDirectory = function () { this.setModeProperty(e); };\n        b.prototype.setIsSymlink = function () { this.setModeProperty(g); };\n        b.prototype.isFile = function () { return (this.mode & d) === f; };\n        b.prototype.isDirectory = function () {\n            return (this.mode &\n                d) === e;\n        };\n        b.prototype.isSymlink = function () { return (this.mode & d) === g; };\n        b.prototype.makeSymlink = function (a) { this.symlink = a; this.setIsSymlink(); };\n        b.prototype.write = function (a, b, c, d) { void 0 === b && (b = 0); void 0 === c && (c = a.length); void 0 === d && (d = 0); this.buf || (this.buf = F.bufferAllocUnsafe(0)); if (d + c > this.buf.length) {\n            var e = F.bufferAllocUnsafe(d + c);\n            this.buf.copy(e, 0, 0, this.buf.length);\n            this.buf = e;\n        } a.copy(this.buf, d, b, b + c); this.touch(); return c; };\n        b.prototype.read = function (a, b, c, d) {\n            void 0 === b && (b = 0);\n            void 0 === c && (c = a.byteLength);\n            void 0 === d && (d = 0);\n            this.buf || (this.buf = F.bufferAllocUnsafe(0));\n            c > a.byteLength && (c = a.byteLength);\n            c + d > this.buf.length && (c = this.buf.length - d);\n            this.buf.copy(a, b, d, d + c);\n            return c;\n        };\n        b.prototype.truncate = function (a) { void 0 === a && (a = 0); if (a)\n            if (this.buf || (this.buf = F.bufferAllocUnsafe(0)), a <= this.buf.length)\n                this.buf = this.buf.slice(0, a);\n            else {\n                var b = F.bufferAllocUnsafe(0);\n                this.buf.copy(b);\n                b.fill(0, a);\n            }\n        else\n            this.buf = F.bufferAllocUnsafe(0); this.touch(); };\n        b.prototype.chmod = function (a) {\n            this.perm = a;\n            this.mode = this.mode & -512 |\n                a;\n            this.touch();\n        };\n        b.prototype.chown = function (a, b) { this.uid = a; this.gid = b; this.touch(); };\n        b.prototype.touch = function () { this.mtime = new Date; this.emit(\"change\", this); };\n        b.prototype.canRead = function (a, b) { void 0 === a && (a = L.default.getuid()); void 0 === b && (b = L.default.getgid()); return this.perm & 4 || b === this.gid && this.perm & 32 || a === this.uid && this.perm & 256 ? !0 : !1; };\n        b.prototype.canWrite = function (a, b) {\n            void 0 === a && (a = L.default.getuid());\n            void 0 === b && (b = L.default.getgid());\n            return this.perm & 2 || b === this.gid && this.perm & 16 || a ===\n                this.uid && this.perm & 128 ? !0 : !1;\n        };\n        b.prototype.del = function () { this.emit(\"delete\", this); };\n        b.prototype.toJSON = function () { return { ino: this.ino, uid: this.uid, gid: this.gid, atime: this.atime.getTime(), mtime: this.mtime.getTime(), ctime: this.ctime.getTime(), perm: this.perm, mode: this.mode, nlink: this.nlink, symlink: this.symlink, data: this.getString() }; };\n        return b;\n    }(O.EventEmitter);\n    b.Node = a;\n    a = function (a) {\n        function d(b, c, d) {\n            var e = a.call(this) || this;\n            e.children = {};\n            e.steps = [];\n            e.ino = 0;\n            e.length = 0;\n            e.vol = b;\n            e.parent = c;\n            e.steps = c ? c.steps.concat([d]) :\n                [d];\n            return e;\n        }\n        c(d, a);\n        d.prototype.setNode = function (a) { this.node = a; this.ino = a.ino; };\n        d.prototype.getNode = function () { return this.node; };\n        d.prototype.createChild = function (a, b) { void 0 === b && (b = this.vol.createNode()); var c = new d(this.vol, this, a); c.setNode(b); b.isDirectory(); this.setChild(a, c); return c; };\n        d.prototype.setChild = function (a, b) { void 0 === b && (b = new d(this.vol, this, a)); this.children[a] = b; b.parent = this; this.length++; this.emit(\"child:add\", b, this); return b; };\n        d.prototype.deleteChild = function (a) {\n            delete this.children[a.getName()];\n            this.length--;\n            this.emit(\"child:delete\", a, this);\n        };\n        d.prototype.getChild = function (a) { if (Object.hasOwnProperty.call(this.children, a))\n            return this.children[a]; };\n        d.prototype.getPath = function () { return this.steps.join(b.SEP); };\n        d.prototype.getName = function () { return this.steps[this.steps.length - 1]; };\n        d.prototype.walk = function (a, b, c) { void 0 === b && (b = a.length); void 0 === c && (c = 0); if (c >= a.length || c >= b)\n            return this; var d = this.getChild(a[c]); return d ? d.walk(a, b, c + 1) : null; };\n        d.prototype.toJSON = function () {\n            return { steps: this.steps,\n                ino: this.ino, children: Object.keys(this.children) };\n        };\n        return d;\n    }(O.EventEmitter);\n    b.Link = a;\n    a = function () {\n        function a(a, b, c, d) { this.position = 0; this.link = a; this.node = b; this.flags = c; this.fd = d; }\n        a.prototype.getString = function () { return this.node.getString(); };\n        a.prototype.setString = function (a) { this.node.setString(a); };\n        a.prototype.getBuffer = function () { return this.node.getBuffer(); };\n        a.prototype.setBuffer = function (a) { this.node.setBuffer(a); };\n        a.prototype.getSize = function () { return this.node.getSize(); };\n        a.prototype.truncate =\n            function (a) { this.node.truncate(a); };\n        a.prototype.seekTo = function (a) { this.position = a; };\n        a.prototype.stats = function () { return ka.default.build(this.node); };\n        a.prototype.write = function (a, b, c, d) { void 0 === b && (b = 0); void 0 === c && (c = a.length); \"number\" !== typeof d && (d = this.position); this.flags & h && (d = this.getSize()); a = this.node.write(a, b, c, d); this.position = d + a; return a; };\n        a.prototype.read = function (a, b, c, d) {\n            void 0 === b && (b = 0);\n            void 0 === c && (c = a.byteLength);\n            \"number\" !== typeof d && (d = this.position);\n            a = this.node.read(a, b, c, d);\n            this.position = d + a;\n            return a;\n        };\n        a.prototype.chmod = function (a) { this.node.chmod(a); };\n        a.prototype.chown = function (a, b) { this.node.chown(a, b); };\n        return a;\n    }();\n    b.File = a;\n});\nt(fd);\nvar gd = fd.Node, hd = u(function (a, b) { Object.defineProperty(b, \"__esModule\", { value: !0 }); b.default = function (a, b, e) { var c = setTimeout.apply(null, arguments); c && \"object\" === typeof c && \"function\" === typeof c.unref && c.unref(); return c; }; });\nt(hd);\nfunction id() { this.tail = this.head = null; this.length = 0; }\nid.prototype.push = function (a) { a = { data: a, next: null }; 0 < this.length ? this.tail.next = a : this.head = a; this.tail = a; ++this.length; };\nid.prototype.unshift = function (a) { a = { data: a, next: this.head }; 0 === this.length && (this.tail = a); this.head = a; ++this.length; };\nid.prototype.shift = function () { if (0 !== this.length) {\n    var a = this.head.data;\n    this.head = 1 === this.length ? this.tail = null : this.head.next;\n    --this.length;\n    return a;\n} };\nid.prototype.clear = function () { this.head = this.tail = null; this.length = 0; };\nid.prototype.join = function (a) { if (0 === this.length)\n    return \"\"; for (var b = this.head, c = \"\" + b.data; b = b.next;)\n    c += a + b.data; return c; };\nid.prototype.concat = function (a) { if (0 === this.length)\n    return z.alloc(0); if (1 === this.length)\n    return this.head.data; a = z.allocUnsafe(a >>> 0); for (var b = this.head, c = 0; b;)\n    b.data.copy(a, c), c += b.data.length, b = b.next; return a; };\nvar jd = z.isEncoding || function (a) { switch (a && a.toLowerCase()) {\n    case \"hex\":\n    case \"utf8\":\n    case \"utf-8\":\n    case \"ascii\":\n    case \"binary\":\n    case \"base64\":\n    case \"ucs2\":\n    case \"ucs-2\":\n    case \"utf16le\":\n    case \"utf-16le\":\n    case \"raw\": return !0;\n    default: return !1;\n} };\nfunction kd(a) { this.encoding = (a || \"utf8\").toLowerCase().replace(/[-_]/, \"\"); if (a && !jd(a))\n    throw Error(\"Unknown encoding: \" + a); switch (this.encoding) {\n    case \"utf8\":\n        this.surrogateSize = 3;\n        break;\n    case \"ucs2\":\n    case \"utf16le\":\n        this.surrogateSize = 2;\n        this.detectIncompleteChar = ld;\n        break;\n    case \"base64\":\n        this.surrogateSize = 3;\n        this.detectIncompleteChar = md;\n        break;\n    default:\n        this.write = nd;\n        return;\n} this.charBuffer = new z(6); this.charLength = this.charReceived = 0; }\nkd.prototype.write = function (a) {\n    for (var b = \"\"; this.charLength;) {\n        b = a.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : a.length;\n        a.copy(this.charBuffer, this.charReceived, 0, b);\n        this.charReceived += b;\n        if (this.charReceived < this.charLength)\n            return \"\";\n        a = a.slice(b, a.length);\n        b = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n        var c = b.charCodeAt(b.length - 1);\n        if (55296 <= c && 56319 >= c)\n            this.charLength += this.surrogateSize, b = \"\";\n        else {\n            this.charReceived = this.charLength = 0;\n            if (0 === a.length)\n                return b;\n            break;\n        }\n    }\n    this.detectIncompleteChar(a);\n    var d = a.length;\n    this.charLength && (a.copy(this.charBuffer, 0, a.length - this.charReceived, d), d -= this.charReceived);\n    b += a.toString(this.encoding, 0, d);\n    d = b.length - 1;\n    c = b.charCodeAt(d);\n    return 55296 <= c && 56319 >= c ? (c = this.surrogateSize, this.charLength += c, this.charReceived += c, this.charBuffer.copy(this.charBuffer, c, 0, c), a.copy(this.charBuffer, 0, 0, c), b.substring(0, d)) : b;\n};\nkd.prototype.detectIncompleteChar = function (a) { for (var b = 3 <= a.length ? 3 : a.length; 0 < b; b--) {\n    var c = a[a.length - b];\n    if (1 == b && 6 == c >> 5) {\n        this.charLength = 2;\n        break;\n    }\n    if (2 >= b && 14 == c >> 4) {\n        this.charLength = 3;\n        break;\n    }\n    if (3 >= b && 30 == c >> 3) {\n        this.charLength = 4;\n        break;\n    }\n} this.charReceived = b; };\nkd.prototype.end = function (a) { var b = \"\"; a && a.length && (b = this.write(a)); this.charReceived && (a = this.encoding, b += this.charBuffer.slice(0, this.charReceived).toString(a)); return b; };\nfunction nd(a) { return a.toString(this.encoding); }\nfunction ld(a) { this.charLength = (this.charReceived = a.length % 2) ? 2 : 0; }\nfunction md(a) { this.charLength = (this.charReceived = a.length % 3) ? 3 : 0; }\nP.ReadableState = od;\nvar Q = Mb(\"stream\");\nDb(P, O);\nfunction pd(a, b, c) { if (\"function\" === typeof a.prependListener)\n    return a.prependListener(b, c); if (a._events && a._events[b])\n    Array.isArray(a._events[b]) ? a._events[b].unshift(c) : a._events[b] = [c, a._events[b]];\nelse\n    a.on(b, c); }\nfunction od(a, b) {\n    a = a || {};\n    this.objectMode = !!a.objectMode;\n    b instanceof V && (this.objectMode = this.objectMode || !!a.readableObjectMode);\n    b = a.highWaterMark;\n    var c = this.objectMode ? 16 : 16384;\n    this.highWaterMark = b || 0 === b ? b : c;\n    this.highWaterMark = ~~this.highWaterMark;\n    this.buffer = new id;\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.reading = this.endEmitted = this.ended = !1;\n    this.sync = !0;\n    this.resumeScheduled = this.readableListening = this.emittedReadable = this.needReadable = !1;\n    this.defaultEncoding = a.defaultEncoding ||\n        \"utf8\";\n    this.ranOut = !1;\n    this.awaitDrain = 0;\n    this.readingMore = !1;\n    this.encoding = this.decoder = null;\n    a.encoding && (this.decoder = new kd(a.encoding), this.encoding = a.encoding);\n}\nfunction P(a) { if (!(this instanceof P))\n    return new P(a); this._readableState = new od(a, this); this.readable = !0; a && \"function\" === typeof a.read && (this._read = a.read); O.call(this); }\nP.prototype.push = function (a, b) { var c = this._readableState; c.objectMode || \"string\" !== typeof a || (b = b || c.defaultEncoding, b !== c.encoding && (a = z.from(a, b), b = \"\")); return qd(this, c, a, b, !1); };\nP.prototype.unshift = function (a) { return qd(this, this._readableState, a, \"\", !0); };\nP.prototype.isPaused = function () { return !1 === this._readableState.flowing; };\nfunction qd(a, b, c, d, e) {\n    var f = c;\n    var g = null;\n    Na(f) || \"string\" === typeof f || null === f || void 0 === f || b.objectMode || (g = new TypeError(\"Invalid non-string/buffer chunk\"));\n    if (f = g)\n        a.emit(\"error\", f);\n    else if (null === c)\n        b.reading = !1, b.ended || (b.decoder && (c = b.decoder.end()) && c.length && (b.buffer.push(c), b.length += b.objectMode ? 1 : c.length), b.ended = !0, rd(a));\n    else if (b.objectMode || c && 0 < c.length)\n        if (b.ended && !e)\n            a.emit(\"error\", Error(\"stream.push() after EOF\"));\n        else if (b.endEmitted && e)\n            a.emit(\"error\", Error(\"stream.unshift() after end event\"));\n        else {\n            if (b.decoder && !e && !d) {\n                c = b.decoder.write(c);\n                var h = !b.objectMode && 0 === c.length;\n            }\n            e || (b.reading = !1);\n            h || (b.flowing && 0 === b.length && !b.sync ? (a.emit(\"data\", c), a.read(0)) : (b.length += b.objectMode ? 1 : c.length, e ? b.buffer.unshift(c) : b.buffer.push(c), b.needReadable && rd(a)));\n            b.readingMore || (b.readingMore = !0, G(sd, a, b));\n        }\n    else\n        e || (b.reading = !1);\n    return !b.ended && (b.needReadable || b.length < b.highWaterMark || 0 === b.length);\n}\nP.prototype.setEncoding = function (a) { this._readableState.decoder = new kd(a); this._readableState.encoding = a; return this; };\nfunction td(a, b) { if (0 >= a || 0 === b.length && b.ended)\n    return 0; if (b.objectMode)\n    return 1; if (a !== a)\n    return b.flowing && b.length ? b.buffer.head.data.length : b.length; if (a > b.highWaterMark) {\n    var c = a;\n    8388608 <= c ? c = 8388608 : (c--, c |= c >>> 1, c |= c >>> 2, c |= c >>> 4, c |= c >>> 8, c |= c >>> 16, c++);\n    b.highWaterMark = c;\n} return a <= b.length ? a : b.ended ? b.length : (b.needReadable = !0, 0); }\nP.prototype.read = function (a) {\n    Q(\"read\", a);\n    a = parseInt(a, 10);\n    var b = this._readableState, c = a;\n    0 !== a && (b.emittedReadable = !1);\n    if (0 === a && b.needReadable && (b.length >= b.highWaterMark || b.ended))\n        return Q(\"read: emitReadable\", b.length, b.ended), 0 === b.length && b.ended ? Jd(this) : rd(this), null;\n    a = td(a, b);\n    if (0 === a && b.ended)\n        return 0 === b.length && Jd(this), null;\n    var d = b.needReadable;\n    Q(\"need readable\", d);\n    if (0 === b.length || b.length - a < b.highWaterMark)\n        d = !0, Q(\"length less than watermark\", d);\n    b.ended || b.reading ? Q(\"reading or ended\", !1) : d && (Q(\"do read\"), b.reading = !0, b.sync = !0, 0 === b.length && (b.needReadable = !0), this._read(b.highWaterMark), b.sync = !1, b.reading || (a = td(c, b)));\n    d = 0 < a ? Kd(a, b) : null;\n    null === d ? (b.needReadable = !0, a = 0) : b.length -= a;\n    0 === b.length && (b.ended || (b.needReadable = !0), c !== a && b.ended && Jd(this));\n    null !== d && this.emit(\"data\", d);\n    return d;\n};\nfunction rd(a) { var b = a._readableState; b.needReadable = !1; b.emittedReadable || (Q(\"emitReadable\", b.flowing), b.emittedReadable = !0, b.sync ? G(Ld, a) : Ld(a)); }\nfunction Ld(a) { Q(\"emit readable\"); a.emit(\"readable\"); Md(a); }\nfunction sd(a, b) { for (var c = b.length; !b.reading && !b.flowing && !b.ended && b.length < b.highWaterMark && (Q(\"maybeReadMore read 0\"), a.read(0), c !== b.length);)\n    c = b.length; b.readingMore = !1; }\nP.prototype._read = function () { this.emit(\"error\", Error(\"not implemented\")); };\nP.prototype.pipe = function (a, b) {\n    function c(a) { Q(\"onunpipe\"); a === n && e(); }\n    function d() { Q(\"onend\"); a.end(); }\n    function e() { Q(\"cleanup\"); a.removeListener(\"close\", h); a.removeListener(\"finish\", k); a.removeListener(\"drain\", B); a.removeListener(\"error\", g); a.removeListener(\"unpipe\", c); n.removeListener(\"end\", d); n.removeListener(\"end\", e); n.removeListener(\"data\", f); m = !0; !q.awaitDrain || a._writableState && !a._writableState.needDrain || B(); }\n    function f(b) {\n        Q(\"ondata\");\n        v = !1;\n        !1 !== a.write(b) || v || ((1 === q.pipesCount && q.pipes ===\n            a || 1 < q.pipesCount && -1 !== Nd(q.pipes, a)) && !m && (Q(\"false write response, pause\", n._readableState.awaitDrain), n._readableState.awaitDrain++, v = !0), n.pause());\n    }\n    function g(b) { Q(\"onerror\", b); p(); a.removeListener(\"error\", g); 0 === a.listeners(\"error\").length && a.emit(\"error\", b); }\n    function h() { a.removeListener(\"finish\", k); p(); }\n    function k() { Q(\"onfinish\"); a.removeListener(\"close\", h); p(); }\n    function p() { Q(\"unpipe\"); n.unpipe(a); }\n    var n = this, q = this._readableState;\n    switch (q.pipesCount) {\n        case 0:\n            q.pipes = a;\n            break;\n        case 1:\n            q.pipes = [q.pipes,\n                a];\n            break;\n        default: q.pipes.push(a);\n    }\n    q.pipesCount += 1;\n    Q(\"pipe count=%d opts=%j\", q.pipesCount, b);\n    b = b && !1 === b.end ? e : d;\n    if (q.endEmitted)\n        G(b);\n    else\n        n.once(\"end\", b);\n    a.on(\"unpipe\", c);\n    var B = Od(n);\n    a.on(\"drain\", B);\n    var m = !1, v = !1;\n    n.on(\"data\", f);\n    pd(a, \"error\", g);\n    a.once(\"close\", h);\n    a.once(\"finish\", k);\n    a.emit(\"pipe\", n);\n    q.flowing || (Q(\"pipe resume\"), n.resume());\n    return a;\n};\nfunction Od(a) { return function () { var b = a._readableState; Q(\"pipeOnDrain\", b.awaitDrain); b.awaitDrain && b.awaitDrain--; 0 === b.awaitDrain && a.listeners(\"data\").length && (b.flowing = !0, Md(a)); }; }\nP.prototype.unpipe = function (a) { var b = this._readableState; if (0 === b.pipesCount)\n    return this; if (1 === b.pipesCount) {\n    if (a && a !== b.pipes)\n        return this;\n    a || (a = b.pipes);\n    b.pipes = null;\n    b.pipesCount = 0;\n    b.flowing = !1;\n    a && a.emit(\"unpipe\", this);\n    return this;\n} if (!a) {\n    a = b.pipes;\n    var c = b.pipesCount;\n    b.pipes = null;\n    b.pipesCount = 0;\n    b.flowing = !1;\n    for (b = 0; b < c; b++)\n        a[b].emit(\"unpipe\", this);\n    return this;\n} c = Nd(b.pipes, a); if (-1 === c)\n    return this; b.pipes.splice(c, 1); --b.pipesCount; 1 === b.pipesCount && (b.pipes = b.pipes[0]); a.emit(\"unpipe\", this); return this; };\nP.prototype.on = function (a, b) { b = O.prototype.on.call(this, a, b); \"data\" === a ? !1 !== this._readableState.flowing && this.resume() : \"readable\" === a && (a = this._readableState, a.endEmitted || a.readableListening || (a.readableListening = a.needReadable = !0, a.emittedReadable = !1, a.reading ? a.length && rd(this) : G(Pd, this))); return b; };\nP.prototype.addListener = P.prototype.on;\nfunction Pd(a) { Q(\"readable nexttick read 0\"); a.read(0); }\nP.prototype.resume = function () { var a = this._readableState; a.flowing || (Q(\"resume\"), a.flowing = !0, a.resumeScheduled || (a.resumeScheduled = !0, G(Qd, this, a))); return this; };\nfunction Qd(a, b) { b.reading || (Q(\"resume read 0\"), a.read(0)); b.resumeScheduled = !1; b.awaitDrain = 0; a.emit(\"resume\"); Md(a); b.flowing && !b.reading && a.read(0); }\nP.prototype.pause = function () { Q(\"call pause flowing=%j\", this._readableState.flowing); !1 !== this._readableState.flowing && (Q(\"pause\"), this._readableState.flowing = !1, this.emit(\"pause\")); return this; };\nfunction Md(a) { var b = a._readableState; for (Q(\"flow\", b.flowing); b.flowing && null !== a.read();)\n    ; }\nP.prototype.wrap = function (a) {\n    var b = this._readableState, c = !1, d = this;\n    a.on(\"end\", function () { Q(\"wrapped end\"); if (b.decoder && !b.ended) {\n        var a = b.decoder.end();\n        a && a.length && d.push(a);\n    } d.push(null); });\n    a.on(\"data\", function (e) { Q(\"wrapped data\"); b.decoder && (e = b.decoder.write(e)); b.objectMode && (null === e || void 0 === e) || !(b.objectMode || e && e.length) || d.push(e) || (c = !0, a.pause()); });\n    for (var e in a)\n        void 0 === this[e] && \"function\" === typeof a[e] && (this[e] = function (b) { return function () { return a[b].apply(a, arguments); }; }(e));\n    Rd([\"error\",\n        \"close\", \"destroy\", \"pause\", \"resume\"], function (b) { a.on(b, d.emit.bind(d, b)); });\n    d._read = function (b) { Q(\"wrapped _read\", b); c && (c = !1, a.resume()); };\n    return d;\n};\nP._fromList = Kd;\nfunction Kd(a, b) {\n    if (0 === b.length)\n        return null;\n    if (b.objectMode)\n        var c = b.buffer.shift();\n    else if (!a || a >= b.length)\n        c = b.decoder ? b.buffer.join(\"\") : 1 === b.buffer.length ? b.buffer.head.data : b.buffer.concat(b.length), b.buffer.clear();\n    else {\n        c = b.buffer;\n        b = b.decoder;\n        if (a < c.head.data.length)\n            b = c.head.data.slice(0, a), c.head.data = c.head.data.slice(a);\n        else {\n            if (a === c.head.data.length)\n                c = c.shift();\n            else if (b) {\n                b = c.head;\n                var d = 1, e = b.data;\n                for (a -= e.length; b = b.next;) {\n                    var f = b.data, g = a > f.length ? f.length : a;\n                    e = g === f.length ? e + f : e + f.slice(0, a);\n                    a -= g;\n                    if (0 === a) {\n                        g === f.length ? (++d, c.head = b.next ? b.next : c.tail = null) : (c.head = b, b.data = f.slice(g));\n                        break;\n                    }\n                    ++d;\n                }\n                c.length -= d;\n                c = e;\n            }\n            else {\n                b = z.allocUnsafe(a);\n                d = c.head;\n                e = 1;\n                d.data.copy(b);\n                for (a -= d.data.length; d = d.next;) {\n                    f = d.data;\n                    g = a > f.length ? f.length : a;\n                    f.copy(b, b.length - a, 0, g);\n                    a -= g;\n                    if (0 === a) {\n                        g === f.length ? (++e, c.head = d.next ? d.next : c.tail = null) : (c.head = d, d.data = f.slice(g));\n                        break;\n                    }\n                    ++e;\n                }\n                c.length -= e;\n                c = b;\n            }\n            b = c;\n        }\n        c = b;\n    }\n    return c;\n}\nfunction Jd(a) { var b = a._readableState; if (0 < b.length)\n    throw Error('\"endReadable()\" called on non-empty stream'); b.endEmitted || (b.ended = !0, G(Sd, b, a)); }\nfunction Sd(a, b) { a.endEmitted || 0 !== a.length || (a.endEmitted = !0, b.readable = !1, b.emit(\"end\")); }\nfunction Rd(a, b) { for (var c = 0, d = a.length; c < d; c++)\n    b(a[c], c); }\nfunction Nd(a, b) { for (var c = 0, d = a.length; c < d; c++)\n    if (a[c] === b)\n        return c; return -1; }\nW.WritableState = Td;\nDb(W, O);\nfunction Ud() { }\nfunction Vd(a, b, c) { this.chunk = a; this.encoding = b; this.callback = c; this.next = null; }\nfunction Td(a, b) {\n    Object.defineProperty(this, \"buffer\", { get: Ib(function () { return this.getBuffer(); }, \"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\") });\n    a = a || {};\n    this.objectMode = !!a.objectMode;\n    b instanceof V && (this.objectMode = this.objectMode || !!a.writableObjectMode);\n    var c = a.highWaterMark, d = this.objectMode ? 16 : 16384;\n    this.highWaterMark = c || 0 === c ? c : d;\n    this.highWaterMark = ~~this.highWaterMark;\n    this.finished = this.ended = this.ending = this.needDrain = !1;\n    this.decodeStrings = !1 !== a.decodeStrings;\n    this.defaultEncoding = a.defaultEncoding || \"utf8\";\n    this.length = 0;\n    this.writing = !1;\n    this.corked = 0;\n    this.sync = !0;\n    this.bufferProcessing = !1;\n    this.onwrite = function (a) { var c = b._writableState, d = c.sync, e = c.writecb; c.writing = !1; c.writecb = null; c.length -= c.writelen; c.writelen = 0; a ? (--c.pendingcb, d ? G(e, a) : e(a), b._writableState.errorEmitted = !0, b.emit(\"error\", a)) : ((a = Wd(c)) || c.corked || c.bufferProcessing || !c.bufferedRequest || Xd(b, c), d ? G(Yd, b, c, a, e) : Yd(b, c, a, e)); };\n    this.writecb = null;\n    this.writelen = 0;\n    this.lastBufferedRequest =\n        this.bufferedRequest = null;\n    this.pendingcb = 0;\n    this.errorEmitted = this.prefinished = !1;\n    this.bufferedRequestCount = 0;\n    this.corkedRequestsFree = new Zd(this);\n}\nTd.prototype.getBuffer = function () { for (var a = this.bufferedRequest, b = []; a;)\n    b.push(a), a = a.next; return b; };\nfunction W(a) { if (!(this instanceof W || this instanceof V))\n    return new W(a); this._writableState = new Td(a, this); this.writable = !0; a && (\"function\" === typeof a.write && (this._write = a.write), \"function\" === typeof a.writev && (this._writev = a.writev)); O.call(this); }\nW.prototype.pipe = function () { this.emit(\"error\", Error(\"Cannot pipe, not readable\")); };\nW.prototype.write = function (a, b, c) {\n    var d = this._writableState, e = !1;\n    \"function\" === typeof b && (c = b, b = null);\n    z.isBuffer(a) ? b = \"buffer\" : b || (b = d.defaultEncoding);\n    \"function\" !== typeof c && (c = Ud);\n    if (d.ended)\n        d = c, a = Error(\"write after end\"), this.emit(\"error\", a), G(d, a);\n    else {\n        var f = c, g = !0, h = !1;\n        null === a ? h = new TypeError(\"May not write null values to stream\") : z.isBuffer(a) || \"string\" === typeof a || void 0 === a || d.objectMode || (h = new TypeError(\"Invalid non-string/buffer chunk\"));\n        h && (this.emit(\"error\", h), G(f, h), g = !1);\n        g && (d.pendingcb++,\n            e = b, d.objectMode || !1 === d.decodeStrings || \"string\" !== typeof a || (a = z.from(a, e)), z.isBuffer(a) && (e = \"buffer\"), f = d.objectMode ? 1 : a.length, d.length += f, b = d.length < d.highWaterMark, b || (d.needDrain = !0), d.writing || d.corked ? (f = d.lastBufferedRequest, d.lastBufferedRequest = new Vd(a, e, c), f ? f.next = d.lastBufferedRequest : d.bufferedRequest = d.lastBufferedRequest, d.bufferedRequestCount += 1) : $d(this, d, !1, f, a, e, c), e = b);\n    }\n    return e;\n};\nW.prototype.cork = function () { this._writableState.corked++; };\nW.prototype.uncork = function () { var a = this._writableState; a.corked && (a.corked--, a.writing || a.corked || a.finished || a.bufferProcessing || !a.bufferedRequest || Xd(this, a)); };\nW.prototype.setDefaultEncoding = function (a) { \"string\" === typeof a && (a = a.toLowerCase()); if (!(-1 < \"hex utf8 utf-8 ascii binary base64 ucs2 ucs-2 utf16le utf-16le raw\".split(\" \").indexOf((a + \"\").toLowerCase())))\n    throw new TypeError(\"Unknown encoding: \" + a); this._writableState.defaultEncoding = a; return this; };\nfunction $d(a, b, c, d, e, f, g) { b.writelen = d; b.writecb = g; b.writing = !0; b.sync = !0; c ? a._writev(e, b.onwrite) : a._write(e, f, b.onwrite); b.sync = !1; }\nfunction Yd(a, b, c, d) { !c && 0 === b.length && b.needDrain && (b.needDrain = !1, a.emit(\"drain\")); b.pendingcb--; d(); ae(a, b); }\nfunction Xd(a, b) {\n    b.bufferProcessing = !0;\n    var c = b.bufferedRequest;\n    if (a._writev && c && c.next) {\n        var d = Array(b.bufferedRequestCount), e = b.corkedRequestsFree;\n        e.entry = c;\n        for (var f = 0; c;)\n            d[f] = c, c = c.next, f += 1;\n        $d(a, b, !0, b.length, d, \"\", e.finish);\n        b.pendingcb++;\n        b.lastBufferedRequest = null;\n        e.next ? (b.corkedRequestsFree = e.next, e.next = null) : b.corkedRequestsFree = new Zd(b);\n    }\n    else {\n        for (; c && (d = c.chunk, $d(a, b, !1, b.objectMode ? 1 : d.length, d, c.encoding, c.callback), c = c.next, !b.writing);)\n            ;\n        null === c && (b.lastBufferedRequest = null);\n    }\n    b.bufferedRequestCount =\n        0;\n    b.bufferedRequest = c;\n    b.bufferProcessing = !1;\n}\nW.prototype._write = function (a, b, c) { c(Error(\"not implemented\")); };\nW.prototype._writev = null;\nW.prototype.end = function (a, b, c) { var d = this._writableState; \"function\" === typeof a ? (c = a, b = a = null) : \"function\" === typeof b && (c = b, b = null); null !== a && void 0 !== a && this.write(a, b); d.corked && (d.corked = 1, this.uncork()); if (!d.ending && !d.finished) {\n    a = c;\n    d.ending = !0;\n    ae(this, d);\n    if (a)\n        if (d.finished)\n            G(a);\n        else\n            this.once(\"finish\", a);\n    d.ended = !0;\n    this.writable = !1;\n} };\nfunction Wd(a) { return a.ending && 0 === a.length && null === a.bufferedRequest && !a.finished && !a.writing; }\nfunction ae(a, b) { var c = Wd(b); c && (0 === b.pendingcb ? (b.prefinished || (b.prefinished = !0, a.emit(\"prefinish\")), b.finished = !0, a.emit(\"finish\")) : b.prefinished || (b.prefinished = !0, a.emit(\"prefinish\"))); return c; }\nfunction Zd(a) { var b = this; this.entry = this.next = null; this.finish = function (c) { var d = b.entry; for (b.entry = null; d;) {\n    var e = d.callback;\n    a.pendingcb--;\n    e(c);\n    d = d.next;\n} a.corkedRequestsFree ? a.corkedRequestsFree.next = b : a.corkedRequestsFree = b; }; }\nDb(V, P);\nfor (var be = Object.keys(W.prototype), ce = 0; ce < be.length; ce++) {\n    var de = be[ce];\n    V.prototype[de] || (V.prototype[de] = W.prototype[de]);\n}\nfunction V(a) { if (!(this instanceof V))\n    return new V(a); P.call(this, a); W.call(this, a); a && !1 === a.readable && (this.readable = !1); a && !1 === a.writable && (this.writable = !1); this.allowHalfOpen = !0; a && !1 === a.allowHalfOpen && (this.allowHalfOpen = !1); this.once(\"end\", ee); }\nfunction ee() { this.allowHalfOpen || this._writableState.ended || G(fe, this); }\nfunction fe(a) { a.end(); }\nDb(X, V);\nfunction ge(a) { this.afterTransform = function (b, c) { var d = a._transformState; d.transforming = !1; var e = d.writecb; e ? (d.writechunk = null, d.writecb = null, null !== c && void 0 !== c && a.push(c), e(b), b = a._readableState, b.reading = !1, (b.needReadable || b.length < b.highWaterMark) && a._read(b.highWaterMark), b = void 0) : b = a.emit(\"error\", Error(\"no writecb in Transform class\")); return b; }; this.transforming = this.needTransform = !1; this.writeencoding = this.writechunk = this.writecb = null; }\nfunction X(a) { if (!(this instanceof X))\n    return new X(a); V.call(this, a); this._transformState = new ge(this); var b = this; this._readableState.needReadable = !0; this._readableState.sync = !1; a && (\"function\" === typeof a.transform && (this._transform = a.transform), \"function\" === typeof a.flush && (this._flush = a.flush)); this.once(\"prefinish\", function () { \"function\" === typeof this._flush ? this._flush(function (a) { he(b, a); }) : he(b); }); }\nX.prototype.push = function (a, b) { this._transformState.needTransform = !1; return V.prototype.push.call(this, a, b); };\nX.prototype._transform = function () { throw Error(\"Not implemented\"); };\nX.prototype._write = function (a, b, c) { var d = this._transformState; d.writecb = c; d.writechunk = a; d.writeencoding = b; d.transforming || (a = this._readableState, (d.needTransform || a.needReadable || a.length < a.highWaterMark) && this._read(a.highWaterMark)); };\nX.prototype._read = function () { var a = this._transformState; null !== a.writechunk && a.writecb && !a.transforming ? (a.transforming = !0, this._transform(a.writechunk, a.writeencoding, a.afterTransform)) : a.needTransform = !0; };\nfunction he(a, b) { if (b)\n    return a.emit(\"error\", b); b = a._transformState; if (a._writableState.length)\n    throw Error(\"Calling transform done when ws.length != 0\"); if (b.transforming)\n    throw Error(\"Calling transform done when still transforming\"); return a.push(null); }\nDb(ie, X);\nfunction ie(a) { if (!(this instanceof ie))\n    return new ie(a); X.call(this, a); }\nie.prototype._transform = function (a, b, c) { c(null, a); };\nDb(Y, O);\nY.Readable = P;\nY.Writable = W;\nY.Duplex = V;\nY.Transform = X;\nY.PassThrough = ie;\nY.Stream = Y;\nfunction Y() { O.call(this); }\nY.prototype.pipe = function (a, b) {\n    function c(b) { a.writable && !1 === a.write(b) && k.pause && k.pause(); }\n    function d() { k.readable && k.resume && k.resume(); }\n    function e() { p || (p = !0, a.end()); }\n    function f() { p || (p = !0, \"function\" === typeof a.destroy && a.destroy()); }\n    function g(a) { h(); if (0 === O.listenerCount(this, \"error\"))\n        throw a; }\n    function h() {\n        k.removeListener(\"data\", c);\n        a.removeListener(\"drain\", d);\n        k.removeListener(\"end\", e);\n        k.removeListener(\"close\", f);\n        k.removeListener(\"error\", g);\n        a.removeListener(\"error\", g);\n        k.removeListener(\"end\", h);\n        k.removeListener(\"close\", h);\n        a.removeListener(\"close\", h);\n    }\n    var k = this;\n    k.on(\"data\", c);\n    a.on(\"drain\", d);\n    a._isStdio || b && !1 === b.end || (k.on(\"end\", e), k.on(\"close\", f));\n    var p = !1;\n    k.on(\"error\", g);\n    a.on(\"error\", g);\n    k.on(\"end\", h);\n    k.on(\"close\", h);\n    a.on(\"close\", h);\n    a.emit(\"pipe\", k);\n    return a;\n};\nvar je = Array.prototype.slice, le = { extend: function ke(a, b) { for (var d in b)\n        a[d] = b[d]; return 3 > arguments.length ? a : ke.apply(null, [a].concat(je.call(arguments, 2))); } }, me = u(function (a, b) {\n    function c(a, b, c) { void 0 === c && (c = function (a) { return a; }); return function () { for (var e = [], f = 0; f < arguments.length; f++)\n        e[f] = arguments[f]; return new Promise(function (f, g) { a[b].bind(a).apply(void 0, d(e, [function (a, b) { return a ? g(a) : f(c(b)); }])); }); }; }\n    var d = l && l.__spreadArrays || function () {\n        for (var a = 0, b = 0, c = arguments.length; b < c; b++)\n            a +=\n                arguments[b].length;\n        a = Array(a);\n        var d = 0;\n        for (b = 0; b < c; b++)\n            for (var e = arguments[b], n = 0, q = e.length; n < q; n++, d++)\n                a[d] = e[n];\n        return a;\n    };\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    var e = function () {\n        function a(a, b) { this.vol = a; this.fd = b; }\n        a.prototype.appendFile = function (a, b) { return c(this.vol, \"appendFile\")(this.fd, a, b); };\n        a.prototype.chmod = function (a) { return c(this.vol, \"fchmod\")(this.fd, a); };\n        a.prototype.chown = function (a, b) { return c(this.vol, \"fchown\")(this.fd, a, b); };\n        a.prototype.close = function () {\n            return c(this.vol, \"close\")(this.fd);\n        };\n        a.prototype.datasync = function () { return c(this.vol, \"fdatasync\")(this.fd); };\n        a.prototype.read = function (a, b, d, e) { return c(this.vol, \"read\", function (b) { return { bytesRead: b, buffer: a }; })(this.fd, a, b, d, e); };\n        a.prototype.readFile = function (a) { return c(this.vol, \"readFile\")(this.fd, a); };\n        a.prototype.stat = function (a) { return c(this.vol, \"fstat\")(this.fd, a); };\n        a.prototype.sync = function () { return c(this.vol, \"fsync\")(this.fd); };\n        a.prototype.truncate = function (a) { return c(this.vol, \"ftruncate\")(this.fd, a); };\n        a.prototype.utimes =\n            function (a, b) { return c(this.vol, \"futimes\")(this.fd, a, b); };\n        a.prototype.write = function (a, b, d, e) { return c(this.vol, \"write\", function (b) { return { bytesWritten: b, buffer: a }; })(this.fd, a, b, d, e); };\n        a.prototype.writeFile = function (a, b) { return c(this.vol, \"writeFile\")(this.fd, a, b); };\n        return a;\n    }();\n    b.FileHandle = e;\n    b.default = function (a) {\n        return \"undefined\" === typeof Promise ? null : { FileHandle: e, access: function (b, d) { return c(a, \"access\")(b, d); }, appendFile: function (b, d, f) { return c(a, \"appendFile\")(b instanceof e ? b.fd : b, d, f); }, chmod: function (b, d) { return c(a, \"chmod\")(b, d); }, chown: function (b, d, e) { return c(a, \"chown\")(b, d, e); }, copyFile: function (b, d, e) { return c(a, \"copyFile\")(b, d, e); }, lchmod: function (b, d) { return c(a, \"lchmod\")(b, d); }, lchown: function (b, d, e) { return c(a, \"lchown\")(b, d, e); }, link: function (b, d) { return c(a, \"link\")(b, d); }, lstat: function (b, d) { return c(a, \"lstat\")(b, d); }, mkdir: function (b, d) { return c(a, \"mkdir\")(b, d); }, mkdtemp: function (b, d) { return c(a, \"mkdtemp\")(b, d); }, open: function (b, d, f) { return c(a, \"open\", function (b) { return new e(a, b); })(b, d, f); }, readdir: function (b, d) { return c(a, \"readdir\")(b, d); }, readFile: function (b, d) { return c(a, \"readFile\")(b instanceof e ? b.fd : b, d); }, readlink: function (b, d) { return c(a, \"readlink\")(b, d); }, realpath: function (b, d) { return c(a, \"realpath\")(b, d); }, rename: function (b, d) { return c(a, \"rename\")(b, d); }, rmdir: function (b) { return c(a, \"rmdir\")(b); }, stat: function (b, d) { return c(a, \"stat\")(b, d); }, symlink: function (b, d, e) { return c(a, \"symlink\")(b, d, e); }, truncate: function (b, d) { return c(a, \"truncate\")(b, d); }, unlink: function (b) { return c(a, \"unlink\")(b); }, utimes: function (b, d, e) { return c(a, \"utimes\")(b, d, e); }, writeFile: function (b, d, f) { return c(a, \"writeFile\")(b instanceof e ? b.fd : b, d, f); } };\n    };\n});\nt(me);\nvar ne = /[^\\x20-\\x7E]/, oe = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, pe = { overflow: \"Overflow: input needs wider integers to process\", \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\", \"invalid-input\": \"Invalid input\" }, qe = Math.floor, re = String.fromCharCode;\nfunction se(a, b) { var c = a.split(\"@\"), d = \"\"; 1 < c.length && (d = c[0] + \"@\", a = c[1]); a = a.replace(oe, \".\"); a = a.split(\".\"); c = a.length; for (var e = []; c--;)\n    e[c] = b(a[c]); b = e.join(\".\"); return d + b; }\nfunction te(a, b) { return a + 22 + 75 * (26 > a) - ((0 != b) << 5); }\nfunction ue(a) {\n    return se(a, function (a) {\n        if (ne.test(a)) {\n            var b;\n            var d = [];\n            var e = [];\n            var f = 0;\n            for (b = a.length; f < b;) {\n                var g = a.charCodeAt(f++);\n                if (55296 <= g && 56319 >= g && f < b) {\n                    var h = a.charCodeAt(f++);\n                    56320 == (h & 64512) ? e.push(((g & 1023) << 10) + (h & 1023) + 65536) : (e.push(g), f--);\n                }\n                else\n                    e.push(g);\n            }\n            a = e;\n            h = a.length;\n            e = 128;\n            var k = 0;\n            var p = 72;\n            for (g = 0; g < h; ++g) {\n                var n = a[g];\n                128 > n && d.push(re(n));\n            }\n            for ((f = b = d.length) && d.push(\"-\"); f < h;) {\n                var q = 2147483647;\n                for (g = 0; g < h; ++g)\n                    n = a[g], n >= e && n < q && (q = n);\n                var B = f + 1;\n                if (q - e > qe((2147483647 - k) / B))\n                    throw new RangeError(pe.overflow);\n                k += (q - e) * B;\n                e = q;\n                for (g = 0; g < h; ++g) {\n                    n = a[g];\n                    if (n < e && 2147483647 < ++k)\n                        throw new RangeError(pe.overflow);\n                    if (n == e) {\n                        var m = k;\n                        for (q = 36;; q += 36) {\n                            n = q <= p ? 1 : q >= p + 26 ? 26 : q - p;\n                            if (m < n)\n                                break;\n                            var v = m - n;\n                            m = 36 - n;\n                            d.push(re(te(n + v % m, 0)));\n                            m = qe(v / m);\n                        }\n                        d.push(re(te(m, 0)));\n                        p = B;\n                        q = 0;\n                        k = f == b ? qe(k / 700) : k >> 1;\n                        for (k += qe(k / p); 455 < k; q += 36)\n                            k = qe(k / 35);\n                        p = qe(q + 36 * k / (k + 38));\n                        k = 0;\n                        ++f;\n                    }\n                }\n                ++k;\n                ++e;\n            }\n            d = \"xn--\" + d.join(\"\");\n        }\n        else\n            d = a;\n        return d;\n    });\n}\nvar ve = Array.isArray || function (a) { return \"[object Array]\" === Object.prototype.toString.call(a); };\nfunction we(a) { switch (typeof a) {\n    case \"string\": return a;\n    case \"boolean\": return a ? \"true\" : \"false\";\n    case \"number\": return isFinite(a) ? a : \"\";\n    default: return \"\";\n} }\nfunction xe(a, b, c, d) { b = b || \"&\"; c = c || \"=\"; null === a && (a = void 0); return \"object\" === typeof a ? ye(ze(a), function (d) { var e = encodeURIComponent(we(d)) + c; return ve(a[d]) ? ye(a[d], function (a) { return e + encodeURIComponent(we(a)); }).join(b) : e + encodeURIComponent(we(a[d])); }).join(b) : d ? encodeURIComponent(we(d)) + c + encodeURIComponent(we(a)) : \"\"; }\nfunction ye(a, b) { if (a.map)\n    return a.map(b); for (var c = [], d = 0; d < a.length; d++)\n    c.push(b(a[d], d)); return c; }\nvar ze = Object.keys || function (a) { var b = [], c; for (c in a)\n    Object.prototype.hasOwnProperty.call(a, c) && b.push(c); return b; };\nfunction Ae(a, b, c, d) { c = c || \"=\"; var e = {}; if (\"string\" !== typeof a || 0 === a.length)\n    return e; var f = /\\+/g; a = a.split(b || \"&\"); b = 1E3; d && \"number\" === typeof d.maxKeys && (b = d.maxKeys); d = a.length; 0 < b && d > b && (d = b); for (b = 0; b < d; ++b) {\n    var g = a[b].replace(f, \"%20\"), h = g.indexOf(c);\n    if (0 <= h) {\n        var k = g.substr(0, h);\n        g = g.substr(h + 1);\n    }\n    else\n        k = g, g = \"\";\n    k = decodeURIComponent(k);\n    g = decodeURIComponent(g);\n    Object.prototype.hasOwnProperty.call(e, k) ? ve(e[k]) ? e[k].push(g) : e[k] = [e[k], g] : e[k] = g;\n} return e; }\nvar Fe = { parse: Be, resolve: Ce, resolveObject: De, format: Ee, Url: Z };\nfunction Z() { this.href = this.path = this.pathname = this.query = this.search = this.hash = this.hostname = this.port = this.host = this.auth = this.slashes = this.protocol = null; }\nvar Ge = /^([a-z0-9.+-]+:)/i, He = /:[0-9]*$/, Ie = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/, Je = \"{}|\\\\^`\".split(\"\").concat('<>\"` \\r\\n\\t'.split(\"\")), Ke = [\"'\"].concat(Je), Le = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(Ke), Me = [\"/\", \"?\", \"#\"], Ne = 255, Oe = /^[+a-z0-9A-Z_-]{0,63}$/, Pe = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Qe = { javascript: !0, \"javascript:\": !0 }, Re = { javascript: !0, \"javascript:\": !0 }, Se = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, \"http:\": !0, \"https:\": !0, \"ftp:\": !0, \"gopher:\": !0, \"file:\": !0 };\nfunction Be(a, b, c) { if (a && Hb(a) && a instanceof Z)\n    return a; var d = new Z; d.parse(a, b, c); return d; }\nZ.prototype.parse = function (a, b, c) { return Te(this, a, b, c); };\nfunction Te(a, b, c, d) {\n    if (!Gb(b))\n        throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof b);\n    var e = b.indexOf(\"?\");\n    e = -1 !== e && e < b.indexOf(\"#\") ? \"?\" : \"#\";\n    b = b.split(e);\n    b[0] = b[0].replace(/\\\\/g, \"/\");\n    b = b.join(e);\n    e = b.trim();\n    if (!d && 1 === b.split(\"#\").length && (b = Ie.exec(e)))\n        return a.path = e, a.href = e, a.pathname = b[1], b[2] ? (a.search = b[2], a.query = c ? Ae(a.search.substr(1)) : a.search.substr(1)) : c && (a.search = \"\", a.query = {}), a;\n    if (b = Ge.exec(e)) {\n        b = b[0];\n        var f = b.toLowerCase();\n        a.protocol = f;\n        e = e.substr(b.length);\n    }\n    if (d || b ||\n        e.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n        var g = \"//\" === e.substr(0, 2);\n        !g || b && Re[b] || (e = e.substr(2), a.slashes = !0);\n    }\n    if (!Re[b] && (g || b && !Se[b])) {\n        b = -1;\n        for (d = 0; d < Me.length; d++)\n            g = e.indexOf(Me[d]), -1 !== g && (-1 === b || g < b) && (b = g);\n        g = -1 === b ? e.lastIndexOf(\"@\") : e.lastIndexOf(\"@\", b);\n        -1 !== g && (d = e.slice(0, g), e = e.slice(g + 1), a.auth = decodeURIComponent(d));\n        b = -1;\n        for (d = 0; d < Le.length; d++)\n            g = e.indexOf(Le[d]), -1 !== g && (-1 === b || g < b) && (b = g);\n        -1 === b && (b = e.length);\n        a.host = e.slice(0, b);\n        e = e.slice(b);\n        Ue(a);\n        a.hostname = a.hostname || \"\";\n        g = \"[\" === a.hostname[0] &&\n            \"]\" === a.hostname[a.hostname.length - 1];\n        if (!g) {\n            var h = a.hostname.split(/\\./);\n            d = 0;\n            for (b = h.length; d < b; d++) {\n                var k = h[d];\n                if (k && !k.match(Oe)) {\n                    for (var p = \"\", n = 0, q = k.length; n < q; n++)\n                        p = 127 < k.charCodeAt(n) ? p + \"x\" : p + k[n];\n                    if (!p.match(Oe)) {\n                        b = h.slice(0, d);\n                        d = h.slice(d + 1);\n                        if (k = k.match(Pe))\n                            b.push(k[1]), d.unshift(k[2]);\n                        d.length && (e = \"/\" + d.join(\".\") + e);\n                        a.hostname = b.join(\".\");\n                        break;\n                    }\n                }\n            }\n        }\n        a.hostname = a.hostname.length > Ne ? \"\" : a.hostname.toLowerCase();\n        g || (a.hostname = ue(a.hostname));\n        d = a.port ? \":\" + a.port : \"\";\n        a.host = (a.hostname || \"\") + d;\n        a.href += a.host;\n        g && (a.hostname = a.hostname.substr(1, a.hostname.length - 2), \"/\" !== e[0] && (e = \"/\" + e));\n    }\n    if (!Qe[f])\n        for (d = 0, b = Ke.length; d < b; d++)\n            g = Ke[d], -1 !== e.indexOf(g) && (k = encodeURIComponent(g), k === g && (k = escape(g)), e = e.split(g).join(k));\n    d = e.indexOf(\"#\");\n    -1 !== d && (a.hash = e.substr(d), e = e.slice(0, d));\n    d = e.indexOf(\"?\");\n    -1 !== d ? (a.search = e.substr(d), a.query = e.substr(d + 1), c && (a.query = Ae(a.query)), e = e.slice(0, d)) : c && (a.search = \"\", a.query = {});\n    e && (a.pathname = e);\n    Se[f] && a.hostname && !a.pathname && (a.pathname = \"/\");\n    if (a.pathname ||\n        a.search)\n        d = a.pathname || \"\", a.path = d + (a.search || \"\");\n    a.href = Ve(a);\n    return a;\n}\nfunction Ee(a) { Gb(a) && (a = Te({}, a)); return Ve(a); }\nfunction Ve(a) {\n    var b = a.auth || \"\";\n    b && (b = encodeURIComponent(b), b = b.replace(/%3A/i, \":\"), b += \"@\");\n    var c = a.protocol || \"\", d = a.pathname || \"\", e = a.hash || \"\", f = !1, g = \"\";\n    a.host ? f = b + a.host : a.hostname && (f = b + (-1 === a.hostname.indexOf(\":\") ? a.hostname : \"[\" + this.hostname + \"]\"), a.port && (f += \":\" + a.port));\n    a.query && Hb(a.query) && Object.keys(a.query).length && (g = xe(a.query));\n    b = a.search || g && \"?\" + g || \"\";\n    c && \":\" !== c.substr(-1) && (c += \":\");\n    a.slashes || (!c || Se[c]) && !1 !== f ? (f = \"//\" + (f || \"\"), d && \"/\" !== d.charAt(0) && (d = \"/\" + d)) : f || (f = \"\");\n    e && \"#\" !== e.charAt(0) &&\n        (e = \"#\" + e);\n    b && \"?\" !== b.charAt(0) && (b = \"?\" + b);\n    d = d.replace(/[?#]/g, function (a) { return encodeURIComponent(a); });\n    b = b.replace(\"#\", \"%23\");\n    return c + f + d + b + e;\n}\nZ.prototype.format = function () { return Ve(this); };\nfunction Ce(a, b) { return Be(a, !1, !0).resolve(b); }\nZ.prototype.resolve = function (a) { return this.resolveObject(Be(a, !1, !0)).format(); };\nfunction De(a, b) { return a ? Be(a, !1, !0).resolveObject(b) : b; }\nZ.prototype.resolveObject = function (a) {\n    if (Gb(a)) {\n        var b = new Z;\n        b.parse(a, !1, !0);\n        a = b;\n    }\n    b = new Z;\n    for (var c = Object.keys(this), d = 0; d < c.length; d++) {\n        var e = c[d];\n        b[e] = this[e];\n    }\n    b.hash = a.hash;\n    if (\"\" === a.href)\n        return b.href = b.format(), b;\n    if (a.slashes && !a.protocol) {\n        c = Object.keys(a);\n        for (d = 0; d < c.length; d++)\n            e = c[d], \"protocol\" !== e && (b[e] = a[e]);\n        Se[b.protocol] && b.hostname && !b.pathname && (b.path = b.pathname = \"/\");\n        b.href = b.format();\n        return b;\n    }\n    var f;\n    if (a.protocol && a.protocol !== b.protocol) {\n        if (!Se[a.protocol]) {\n            c = Object.keys(a);\n            for (d = 0; d <\n                c.length; d++)\n                e = c[d], b[e] = a[e];\n            b.href = b.format();\n            return b;\n        }\n        b.protocol = a.protocol;\n        if (a.host || Re[a.protocol])\n            b.pathname = a.pathname;\n        else {\n            for (f = (a.pathname || \"\").split(\"/\"); f.length && !(a.host = f.shift());)\n                ;\n            a.host || (a.host = \"\");\n            a.hostname || (a.hostname = \"\");\n            \"\" !== f[0] && f.unshift(\"\");\n            2 > f.length && f.unshift(\"\");\n            b.pathname = f.join(\"/\");\n        }\n        b.search = a.search;\n        b.query = a.query;\n        b.host = a.host || \"\";\n        b.auth = a.auth;\n        b.hostname = a.hostname || a.host;\n        b.port = a.port;\n        if (b.pathname || b.search)\n            b.path = (b.pathname || \"\") + (b.search || \"\");\n        b.slashes =\n            b.slashes || a.slashes;\n        b.href = b.format();\n        return b;\n    }\n    c = b.pathname && \"/\" === b.pathname.charAt(0);\n    var g = a.host || a.pathname && \"/\" === a.pathname.charAt(0), h = c = g || c || b.host && a.pathname;\n    d = b.pathname && b.pathname.split(\"/\") || [];\n    e = b.protocol && !Se[b.protocol];\n    f = a.pathname && a.pathname.split(\"/\") || [];\n    e && (b.hostname = \"\", b.port = null, b.host && (\"\" === d[0] ? d[0] = b.host : d.unshift(b.host)), b.host = \"\", a.protocol && (a.hostname = null, a.port = null, a.host && (\"\" === f[0] ? f[0] = a.host : f.unshift(a.host)), a.host = null), c = c && (\"\" === f[0] || \"\" === d[0]));\n    if (g)\n        b.host = a.host || \"\" === a.host ? a.host : b.host, b.hostname = a.hostname || \"\" === a.hostname ? a.hostname : b.hostname, b.search = a.search, b.query = a.query, d = f;\n    else if (f.length)\n        d || (d = []), d.pop(), d = d.concat(f), b.search = a.search, b.query = a.query;\n    else if (null != a.search) {\n        e && (b.hostname = b.host = d.shift(), e = b.host && 0 < b.host.indexOf(\"@\") ? b.host.split(\"@\") : !1) && (b.auth = e.shift(), b.host = b.hostname = e.shift());\n        b.search = a.search;\n        b.query = a.query;\n        if (null !== b.pathname || null !== b.search)\n            b.path = (b.pathname ? b.pathname : \"\") + (b.search ?\n                b.search : \"\");\n        b.href = b.format();\n        return b;\n    }\n    if (!d.length)\n        return b.pathname = null, b.path = b.search ? \"/\" + b.search : null, b.href = b.format(), b;\n    g = d.slice(-1)[0];\n    f = (b.host || a.host || 1 < d.length) && (\".\" === g || \"..\" === g) || \"\" === g;\n    for (var k = 0, p = d.length; 0 <= p; p--)\n        g = d[p], \".\" === g ? d.splice(p, 1) : \"..\" === g ? (d.splice(p, 1), k++) : k && (d.splice(p, 1), k--);\n    if (!c && !h)\n        for (; k--; k)\n            d.unshift(\"..\");\n    !c || \"\" === d[0] || d[0] && \"/\" === d[0].charAt(0) || d.unshift(\"\");\n    f && \"/\" !== d.join(\"/\").substr(-1) && d.push(\"\");\n    h = \"\" === d[0] || d[0] && \"/\" === d[0].charAt(0);\n    e &&\n        (b.hostname = b.host = h ? \"\" : d.length ? d.shift() : \"\", e = b.host && 0 < b.host.indexOf(\"@\") ? b.host.split(\"@\") : !1) && (b.auth = e.shift(), b.host = b.hostname = e.shift());\n    (c = c || b.host && d.length) && !h && d.unshift(\"\");\n    d.length ? b.pathname = d.join(\"/\") : (b.pathname = null, b.path = null);\n    if (null !== b.pathname || null !== b.search)\n        b.path = (b.pathname ? b.pathname : \"\") + (b.search ? b.search : \"\");\n    b.auth = a.auth || b.auth;\n    b.slashes = b.slashes || a.slashes;\n    b.href = b.format();\n    return b;\n};\nZ.prototype.parseHost = function () { return Ue(this); };\nfunction Ue(a) { var b = a.host, c = He.exec(b); c && (c = c[0], \":\" !== c && (a.port = c.substr(1)), b = b.substr(0, b.length - c.length)); b && (a.hostname = b); }\nvar We = u(function (a, b) {\n    function c(a, b) { a = a[b]; return 0 < b && (\"/\" === a || e && \"\\\\\" === a); }\n    function d(a) { var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : !0; if (e) {\n        var d = a;\n        if (\"string\" !== typeof d)\n            throw new TypeError(\"expected a string\");\n        d = d.replace(/[\\\\\\/]+/g, \"/\");\n        if (!1 !== b)\n            if (b = d, d = b.length - 1, 2 > d)\n                d = b;\n            else {\n                for (; c(b, d);)\n                    d--;\n                d = b.substr(0, d + 1);\n            }\n        return d.replace(/^([a-zA-Z]+:|\\.\\/)/, \"\");\n    } return a; }\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    b.unixify = d;\n    b.correctPath = function (a) {\n        return d(a.replace(/^\\\\\\\\\\?\\\\.:\\\\/, \"\\\\\"));\n    };\n    var e = \"win32\" === Cb.platform;\n});\nt(We);\nvar Xe = u(function (a, b) {\n    function c(a, b) { void 0 === b && (b = L.default.cwd()); return cf(b, a); }\n    function d(a, b) { return \"function\" === typeof a ? [e(), a] : [e(a), q(b)]; }\n    function e(a) { void 0 === a && (a = {}); return aa({}, df, a); }\n    function f(a) { return \"number\" === typeof a ? aa({}, ud, { mode: a }) : aa({}, ud, a); }\n    function g(a, b, c, d) {\n        void 0 === b && (b = \"\");\n        void 0 === c && (c = \"\");\n        void 0 === d && (d = \"\");\n        var e = \"\";\n        c && (e = \" '\" + c + \"'\");\n        d && (e += \" -> '\" + d + \"'\");\n        switch (a) {\n            case \"ENOENT\": return \"ENOENT: no such file or directory, \" + b + e;\n            case \"EBADF\": return \"EBADF: bad file descriptor, \" +\n                b + e;\n            case \"EINVAL\": return \"EINVAL: invalid argument, \" + b + e;\n            case \"EPERM\": return \"EPERM: operation not permitted, \" + b + e;\n            case \"EPROTO\": return \"EPROTO: protocol error, \" + b + e;\n            case \"EEXIST\": return \"EEXIST: file already exists, \" + b + e;\n            case \"ENOTDIR\": return \"ENOTDIR: not a directory, \" + b + e;\n            case \"EISDIR\": return \"EISDIR: illegal operation on a directory, \" + b + e;\n            case \"EACCES\": return \"EACCES: permission denied, \" + b + e;\n            case \"ENOTEMPTY\": return \"ENOTEMPTY: directory not empty, \" + b + e;\n            case \"EMFILE\": return \"EMFILE: too many open files, \" +\n                b + e;\n            case \"ENOSYS\": return \"ENOSYS: function not implemented, \" + b + e;\n            default: return a + \": error occurred, \" + b + e;\n        }\n    }\n    function h(a, b, c, d, e) { void 0 === b && (b = \"\"); void 0 === c && (c = \"\"); void 0 === d && (d = \"\"); void 0 === e && (e = Error); b = new e(g(a, b, c, d)); b.code = a; return b; }\n    function k(a) { if (\"number\" === typeof a)\n        return a; if (\"string\" === typeof a) {\n        var b = ua[a];\n        if (\"undefined\" !== typeof b)\n            return b;\n    } throw new Pc.TypeError(\"ERR_INVALID_OPT_VALUE\", \"flags\", a); }\n    function p(a, b) {\n        if (b) {\n            var c = typeof b;\n            switch (c) {\n                case \"string\":\n                    a = aa({}, a, { encoding: b });\n                    break;\n                case \"object\":\n                    a = aa({}, a, b);\n                    break;\n                default: throw TypeError(\"Expected options to be either an object or a string, but got \" + c + \" instead\");\n            }\n        }\n        else\n            return a;\n        \"buffer\" !== a.encoding && K.assertEncoding(a.encoding);\n        return a;\n    }\n    function n(a) { return function (b) { return p(a, b); }; }\n    function q(a) { if (\"function\" !== typeof a)\n        throw TypeError(fa.CB); return a; }\n    function B(a) { return function (b, c) { return \"function\" === typeof b ? [a(), b] : [a(b), q(c)]; }; }\n    function m(a) {\n        if (\"string\" !== typeof a && !F.Buffer.isBuffer(a)) {\n            try {\n                if (!(a instanceof\n                    Fe.URL))\n                    throw new TypeError(fa.PATH_STR);\n            }\n            catch (Xa) {\n                throw new TypeError(fa.PATH_STR);\n            }\n            if (\"\" !== a.hostname)\n                throw new Pc.TypeError(\"ERR_INVALID_FILE_URL_HOST\", L.default.platform);\n            a = a.pathname;\n            for (var b = 0; b < a.length; b++)\n                if (\"%\" === a[b]) {\n                    var c = a.codePointAt(b + 2) | 32;\n                    if (\"2\" === a[b + 1] && 102 === c)\n                        throw new Pc.TypeError(\"ERR_INVALID_FILE_URL_PATH\", \"must not include encoded / characters\");\n                }\n            a = decodeURIComponent(a);\n        }\n        a = String(a);\n        qb(a);\n        return a;\n    }\n    function v(a, b) { return (a = c(a, b).substr(1)) ? a.split(S) : []; }\n    function xa(a) { return v(m(a)); }\n    function La(a, b) { void 0 === b && (b = K.ENCODING_UTF8); return F.Buffer.isBuffer(a) ? a : a instanceof Uint8Array ? F.bufferFrom(a) : F.bufferFrom(String(a), b); }\n    function $b(a, b) { return b && \"buffer\" !== b ? a.toString(b) : a; }\n    function qb(a, b) { if (-1 !== (\"\" + a).indexOf(\"\\x00\")) {\n        a = Error(\"Path must be a string without null bytes\");\n        a.code = \"ENOENT\";\n        if (\"function\" !== typeof b)\n            throw a;\n        L.default.nextTick(b, a);\n        return !1;\n    } return !0; }\n    function M(a, b) {\n        a = \"number\" === typeof a ? a : \"string\" === typeof a ? parseInt(a, 8) : b ? M(b) : void 0;\n        if (\"number\" !== typeof a ||\n            isNaN(a))\n            throw new TypeError(fa.MODE_INT);\n        return a;\n    }\n    function Ya(a) { if (a >>> 0 !== a)\n        throw TypeError(fa.FD); }\n    function ha(a) { if (\"string\" === typeof a && +a == a)\n        return +a; if (a instanceof Date)\n        return a.getTime() / 1E3; if (isFinite(a))\n        return 0 > a ? Date.now() / 1E3 : a; throw Error(\"Cannot parse time: \" + a); }\n    function Ha(a) { if (\"number\" !== typeof a)\n        throw TypeError(fa.UID); }\n    function Ia(a) { if (\"number\" !== typeof a)\n        throw TypeError(fa.GID); }\n    function ef(a) { a.emit(\"stop\"); }\n    function T(a, b, c) {\n        if (!(this instanceof T))\n            return new T(a, b, c);\n        this._vol =\n            a;\n        c = aa({}, p(c, {}));\n        void 0 === c.highWaterMark && (c.highWaterMark = 65536);\n        Y.Readable.call(this, c);\n        this.path = m(b);\n        this.fd = void 0 === c.fd ? null : c.fd;\n        this.flags = void 0 === c.flags ? \"r\" : c.flags;\n        this.mode = void 0 === c.mode ? 438 : c.mode;\n        this.start = c.start;\n        this.end = c.end;\n        this.autoClose = void 0 === c.autoClose ? !0 : c.autoClose;\n        this.pos = void 0;\n        this.bytesRead = 0;\n        if (void 0 !== this.start) {\n            if (\"number\" !== typeof this.start)\n                throw new TypeError('\"start\" option must be a Number');\n            if (void 0 === this.end)\n                this.end = Infinity;\n            else if (\"number\" !==\n                typeof this.end)\n                throw new TypeError('\"end\" option must be a Number');\n            if (this.start > this.end)\n                throw Error('\"start\" option must be <= \"end\" option');\n            this.pos = this.start;\n        }\n        \"number\" !== typeof this.fd && this.open();\n        this.on(\"end\", function () { this.autoClose && this.destroy && this.destroy(); });\n    }\n    function ff() { this.close(); }\n    function R(a, b, c) {\n        if (!(this instanceof R))\n            return new R(a, b, c);\n        this._vol = a;\n        c = aa({}, p(c, {}));\n        Y.Writable.call(this, c);\n        this.path = m(b);\n        this.fd = void 0 === c.fd ? null : c.fd;\n        this.flags = void 0 === c.flags ? \"w\" : c.flags;\n        this.mode = void 0 === c.mode ? 438 : c.mode;\n        this.start = c.start;\n        this.autoClose = void 0 === c.autoClose ? !0 : !!c.autoClose;\n        this.pos = void 0;\n        this.bytesWritten = 0;\n        if (void 0 !== this.start) {\n            if (\"number\" !== typeof this.start)\n                throw new TypeError('\"start\" option must be a Number');\n            if (0 > this.start)\n                throw Error('\"start\" must be >= zero');\n            this.pos = this.start;\n        }\n        c.encoding && this.setDefaultEncoding(c.encoding);\n        \"number\" !== typeof this.fd && this.open();\n        this.once(\"finish\", function () { this.autoClose && this.close(); });\n    }\n    var Ja = l && l.__extends ||\n        function () { function a(b, c) { a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (a, b) { a.__proto__ = b; } || function (a, b) { for (var c in b)\n            b.hasOwnProperty(c) && (a[c] = b[c]); }; return a(b, c); } return function (b, c) { function d() { this.constructor = b; } a(b, c); b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d); }; }(), Xb = l && l.__spreadArrays || function () {\n        for (var a = 0, b = 0, c = arguments.length; b < c; b++)\n            a += arguments[b].length;\n        a = Array(a);\n        var d = 0;\n        for (b = 0; b < c; b++)\n            for (var e = arguments[b], f = 0, g = e.length; f <\n                g; f++, d++)\n                a[d] = e[f];\n        return a;\n    };\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    var aa = le.extend, cf = Zc.resolve, mb = w.constants.O_RDONLY, Ka = w.constants.O_WRONLY, na = w.constants.O_RDWR, U = w.constants.O_CREAT, nb = w.constants.O_EXCL, Za = w.constants.O_TRUNC, $a = w.constants.O_APPEND, vd = w.constants.O_SYNC, gf = w.constants.O_DIRECTORY, wd = w.constants.F_OK, hf = w.constants.COPYFILE_EXCL, jf = w.constants.COPYFILE_FICLONE_FORCE;\n    var S = Zc.sep;\n    var xd = Zc.relative;\n    var Yb = \"win32\" === L.default.platform, fa = { PATH_STR: \"path must be a string or Buffer\",\n        FD: \"fd must be a file descriptor\", MODE_INT: \"mode must be an int\", CB: \"callback must be a function\", UID: \"uid must be an unsigned int\", GID: \"gid must be an unsigned int\", LEN: \"len must be an integer\", ATIME: \"atime must be an integer\", MTIME: \"mtime must be an integer\", PREFIX: \"filename prefix is required\", BUFFER: \"buffer must be an instance of Buffer or StaticBuffer\", OFFSET: \"offset must be an integer\", LENGTH: \"length must be an integer\", POSITION: \"position must be an integer\" }, ua;\n    (function (a) {\n        a[a.r = mb] = \"r\";\n        a[a[\"r+\"] =\n            na] = \"r+\";\n        a[a.rs = mb | vd] = \"rs\";\n        a[a.sr = a.rs] = \"sr\";\n        a[a[\"rs+\"] = na | vd] = \"rs+\";\n        a[a[\"sr+\"] = a[\"rs+\"]] = \"sr+\";\n        a[a.w = Ka | U | Za] = \"w\";\n        a[a.wx = Ka | U | Za | nb] = \"wx\";\n        a[a.xw = a.wx] = \"xw\";\n        a[a[\"w+\"] = na | U | Za] = \"w+\";\n        a[a[\"wx+\"] = na | U | Za | nb] = \"wx+\";\n        a[a[\"xw+\"] = a[\"wx+\"]] = \"xw+\";\n        a[a.a = Ka | $a | U] = \"a\";\n        a[a.ax = Ka | $a | U | nb] = \"ax\";\n        a[a.xa = a.ax] = \"xa\";\n        a[a[\"a+\"] = na | $a | U] = \"a+\";\n        a[a[\"ax+\"] = na | $a | U | nb] = \"ax+\";\n        a[a[\"xa+\"] = a[\"ax+\"]] = \"xa+\";\n    })(ua = b.FLAGS || (b.FLAGS = {}));\n    b.flagsToNumber = k;\n    a = { encoding: \"utf8\" };\n    var ob = n(a), yd = B(ob), zd = n({ flag: \"r\" }), Ad = { encoding: \"utf8\",\n        mode: 438, flag: ua[ua.w] }, Bd = n(Ad), Cd = { encoding: \"utf8\", mode: 438, flag: ua[ua.a] }, Dd = n(Cd), kf = B(Dd), Ed = n(a), lf = B(Ed), ud = { mode: 511, recursive: !1 }, Fd = { recursive: !1 }, Gd = n({ encoding: \"utf8\", withFileTypes: !1 }), mf = B(Gd), df = { bigint: !1 };\n    b.pathToFilename = m;\n    if (Yb) {\n        var nf = c, of = We.unixify;\n        c = function (a, b) { return of(nf(a, b)); };\n    }\n    b.filenameToSteps = v;\n    b.pathToSteps = xa;\n    b.dataToStr = function (a, b) { void 0 === b && (b = K.ENCODING_UTF8); return F.Buffer.isBuffer(a) ? a.toString(b) : a instanceof Uint8Array ? F.bufferFrom(a).toString(b) : String(a); };\n    b.dataToBuffer = La;\n    b.bufferToEncoding = $b;\n    b.toUnixTimestamp = ha;\n    a = function () {\n        function a(a) {\n            void 0 === a && (a = {});\n            this.ino = 0;\n            this.inodes = {};\n            this.releasedInos = [];\n            this.fds = {};\n            this.releasedFds = [];\n            this.maxFiles = 1E4;\n            this.openFiles = 0;\n            this.promisesApi = me.default(this);\n            this.statWatchers = {};\n            this.props = aa({ Node: fd.Node, Link: fd.Link, File: fd.File }, a);\n            a = this.createLink();\n            a.setNode(this.createNode(!0));\n            var b = this;\n            this.StatWatcher = function (a) { function c() { return a.call(this, b) || this; } Ja(c, a); return c; }(Hd);\n            this.ReadStream =\n                function (a) { function c() { for (var c = [], d = 0; d < arguments.length; d++)\n                    c[d] = arguments[d]; return a.apply(this, Xb([b], c)) || this; } Ja(c, a); return c; }(T);\n            this.WriteStream = function (a) { function c() { for (var c = [], d = 0; d < arguments.length; d++)\n                c[d] = arguments[d]; return a.apply(this, Xb([b], c)) || this; } Ja(c, a); return c; }(R);\n            this.FSWatcher = function (a) { function c() { return a.call(this, b) || this; } Ja(c, a); return c; }(Id);\n            this.root = a;\n        }\n        a.fromJSON = function (b, c) { var d = new a; d.fromJSON(b, c); return d; };\n        Object.defineProperty(a.prototype, \"promises\", { get: function () { if (null === this.promisesApi)\n                throw Error(\"Promise is not supported in this environment.\"); return this.promisesApi; }, enumerable: !0, configurable: !0 });\n        a.prototype.createLink = function (a, b, c, d) { void 0 === c && (c = !1); if (!a)\n            return new this.props.Link(this, null, \"\"); if (!b)\n            throw Error(\"createLink: name cannot be empty\"); return a.createChild(b, this.createNode(c, d)); };\n        a.prototype.deleteLink = function (a) { var b = a.parent; return b ? (b.deleteChild(a), !0) : !1; };\n        a.prototype.newInoNumber = function () {\n            var a = this.releasedInos.pop();\n            return a ? a : this.ino = (this.ino + 1) % 4294967295;\n        };\n        a.prototype.newFdNumber = function () { var b = this.releasedFds.pop(); return \"number\" === typeof b ? b : a.fd--; };\n        a.prototype.createNode = function (a, b) { void 0 === a && (a = !1); b = new this.props.Node(this.newInoNumber(), b); a && b.setIsDirectory(); return this.inodes[b.ino] = b; };\n        a.prototype.getNode = function (a) { return this.inodes[a]; };\n        a.prototype.deleteNode = function (a) { a.del(); delete this.inodes[a.ino]; this.releasedInos.push(a.ino); };\n        a.prototype.genRndStr = function () {\n            var a = (Math.random() +\n                1).toString(36).substr(2, 6);\n            return 6 === a.length ? a : this.genRndStr();\n        };\n        a.prototype.getLink = function (a) { return this.root.walk(a); };\n        a.prototype.getLinkOrThrow = function (a, b) { var c = v(a); c = this.getLink(c); if (!c)\n            throw h(\"ENOENT\", b, a); return c; };\n        a.prototype.getResolvedLink = function (a) { a = \"string\" === typeof a ? v(a) : a; for (var b = this.root, c = 0; c < a.length;) {\n            b = b.getChild(a[c]);\n            if (!b)\n                return null;\n            var d = b.getNode();\n            d.isSymlink() ? (a = d.symlink.concat(a.slice(c + 1)), b = this.root, c = 0) : c++;\n        } return b; };\n        a.prototype.getResolvedLinkOrThrow =\n            function (a, b) { var c = this.getResolvedLink(a); if (!c)\n                throw h(\"ENOENT\", b, a); return c; };\n        a.prototype.resolveSymlinks = function (a) { return this.getResolvedLink(a.steps.slice(1)); };\n        a.prototype.getLinkAsDirOrThrow = function (a, b) { var c = this.getLinkOrThrow(a, b); if (!c.getNode().isDirectory())\n            throw h(\"ENOTDIR\", b, a); return c; };\n        a.prototype.getLinkParent = function (a) { return this.root.walk(a, a.length - 1); };\n        a.prototype.getLinkParentAsDirOrThrow = function (a, b) {\n            a = a instanceof Array ? a : v(a);\n            var c = this.getLinkParent(a);\n            if (!c)\n                throw h(\"ENOENT\", b, S + a.join(S));\n            if (!c.getNode().isDirectory())\n                throw h(\"ENOTDIR\", b, S + a.join(S));\n            return c;\n        };\n        a.prototype.getFileByFd = function (a) { return this.fds[String(a)]; };\n        a.prototype.getFileByFdOrThrow = function (a, b) { if (a >>> 0 !== a)\n            throw TypeError(fa.FD); a = this.getFileByFd(a); if (!a)\n            throw h(\"EBADF\", b); return a; };\n        a.prototype.getNodeByIdOrCreate = function (a, b, c) {\n            if (\"number\" === typeof a) {\n                a = this.getFileByFd(a);\n                if (!a)\n                    throw Error(\"File nto found\");\n                return a.node;\n            }\n            var d = xa(a), e = this.getLink(d);\n            if (e)\n                return e.getNode();\n            if (b & U && (b = this.getLinkParent(d)))\n                return e =\n                    this.createLink(b, d[d.length - 1], !1, c), e.getNode();\n            throw h(\"ENOENT\", \"getNodeByIdOrCreate\", m(a));\n        };\n        a.prototype.wrapAsync = function (a, b, c) { var d = this; q(c); $c.default(function () { try {\n            c(null, a.apply(d, b));\n        }\n        catch (va) {\n            c(va);\n        } }); };\n        a.prototype._toJSON = function (a, b, c) {\n            var d;\n            void 0 === a && (a = this.root);\n            void 0 === b && (b = {});\n            var e = !0, r = a.children;\n            a.getNode().isFile() && (r = (d = {}, d[a.getName()] = a.parent.getChild(a.getName()), d), a = a.parent);\n            for (var D in r) {\n                e = !1;\n                r = a.getChild(D);\n                if (!r)\n                    throw Error(\"_toJSON: unexpected undefined\");\n                d = r.getNode();\n                d.isFile() ? (r = r.getPath(), c && (r = xd(c, r)), b[r] = d.getString()) : d.isDirectory() && this._toJSON(r, b, c);\n            }\n            a = a.getPath();\n            c && (a = xd(c, a));\n            a && e && (b[a] = null);\n            return b;\n        };\n        a.prototype.toJSON = function (a, b, c) { void 0 === b && (b = {}); void 0 === c && (c = !1); var d = []; if (a) {\n            a instanceof Array || (a = [a]);\n            for (var e = 0; e < a.length; e++) {\n                var r = m(a[e]);\n                (r = this.getResolvedLink(r)) && d.push(r);\n            }\n        }\n        else\n            d.push(this.root); if (!d.length)\n            return b; for (e = 0; e < d.length; e++)\n            r = d[e], this._toJSON(r, b, c ? r.getPath() : \"\"); return b; };\n        a.prototype.fromJSON =\n            function (a, b) { void 0 === b && (b = L.default.cwd()); for (var d in a) {\n                var e = a[d];\n                if (\"string\" === typeof e) {\n                    d = c(d, b);\n                    var r = v(d);\n                    1 < r.length && (r = S + r.slice(0, r.length - 1).join(S), this.mkdirpBase(r, 511));\n                    this.writeFileSync(d, e);\n                }\n                else\n                    this.mkdirpBase(d, 511);\n            } };\n        a.prototype.reset = function () { this.ino = 0; this.inodes = {}; this.releasedInos = []; this.fds = {}; this.releasedFds = []; this.openFiles = 0; this.root = this.createLink(); this.root.setNode(this.createNode(!0)); };\n        a.prototype.mountSync = function (a, b) { this.fromJSON(b, a); };\n        a.prototype.openLink =\n            function (a, b, c) { void 0 === c && (c = !0); if (this.openFiles >= this.maxFiles)\n                throw h(\"EMFILE\", \"open\", a.getPath()); var d = a; c && (d = this.resolveSymlinks(a)); if (!d)\n                throw h(\"ENOENT\", \"open\", a.getPath()); c = d.getNode(); if (c.isDirectory()) {\n                if ((b & (mb | na | Ka)) !== mb)\n                    throw h(\"EISDIR\", \"open\", a.getPath());\n            }\n            else if (b & gf)\n                throw h(\"ENOTDIR\", \"open\", a.getPath()); if (!(b & Ka || c.canRead()))\n                throw h(\"EACCES\", \"open\", a.getPath()); a = new this.props.File(a, c, b, this.newFdNumber()); this.fds[a.fd] = a; this.openFiles++; b & Za && a.truncate(); return a; };\n        a.prototype.openFile = function (a, b, c, d) { void 0 === d && (d = !0); var e = v(a), r = d ? this.getResolvedLink(e) : this.getLink(e); if (!r && b & U) {\n            var D = this.getResolvedLink(e.slice(0, e.length - 1));\n            if (!D)\n                throw h(\"ENOENT\", \"open\", S + e.join(S));\n            b & U && \"number\" === typeof c && (r = this.createLink(D, e[e.length - 1], !1, c));\n        } if (r)\n            return this.openLink(r, b, d); throw h(\"ENOENT\", \"open\", a); };\n        a.prototype.openBase = function (a, b, c, d) { void 0 === d && (d = !0); b = this.openFile(a, b, c, d); if (!b)\n            throw h(\"ENOENT\", \"open\", a); return b.fd; };\n        a.prototype.openSync = function (a, b, c) { void 0 === c && (c = 438); c = M(c); a = m(a); b = k(b); return this.openBase(a, b, c); };\n        a.prototype.open = function (a, b, c, d) { var e = c; \"function\" === typeof c && (e = 438, d = c); c = M(e || 438); a = m(a); b = k(b); this.wrapAsync(this.openBase, [a, b, c], d); };\n        a.prototype.closeFile = function (a) { this.fds[a.fd] && (this.openFiles--, delete this.fds[a.fd], this.releasedFds.push(a.fd)); };\n        a.prototype.closeSync = function (a) { Ya(a); a = this.getFileByFdOrThrow(a, \"close\"); this.closeFile(a); };\n        a.prototype.close = function (a, b) {\n            Ya(a);\n            this.wrapAsync(this.closeSync, [a], b);\n        };\n        a.prototype.openFileOrGetById = function (a, b, c) { if (\"number\" === typeof a) {\n            a = this.fds[a];\n            if (!a)\n                throw h(\"ENOENT\");\n            return a;\n        } return this.openFile(m(a), b, c); };\n        a.prototype.readBase = function (a, b, c, d, e) { return this.getFileByFdOrThrow(a).read(b, Number(c), Number(d), e); };\n        a.prototype.readSync = function (a, b, c, d, e) { Ya(a); return this.readBase(a, b, c, d, e); };\n        a.prototype.read = function (a, b, c, d, e, f) {\n            var r = this;\n            q(f);\n            if (0 === d)\n                return L.default.nextTick(function () { f && f(null, 0, b); });\n            $c.default(function () {\n                try {\n                    var D = r.readBase(a, b, c, d, e);\n                    f(null, D, b);\n                }\n                catch (pf) {\n                    f(pf);\n                }\n            });\n        };\n        a.prototype.readFileBase = function (a, b, c) { var d = \"number\" === typeof a && a >>> 0 === a; if (!d) {\n            var e = m(a);\n            e = v(e);\n            if ((e = this.getResolvedLink(e)) && e.getNode().isDirectory())\n                throw h(\"EISDIR\", \"open\", e.getPath());\n            a = this.openSync(a, b);\n        } try {\n            var r = $b(this.getFileByFdOrThrow(a).getBuffer(), c);\n        }\n        finally {\n            d || this.closeSync(a);\n        } return r; };\n        a.prototype.readFileSync = function (a, b) { b = zd(b); var c = k(b.flag); return this.readFileBase(a, c, b.encoding); };\n        a.prototype.readFile = function (a, b, c) {\n            c = B(zd)(b, c);\n            b = c[0];\n            c = c[1];\n            var d = k(b.flag);\n            this.wrapAsync(this.readFileBase, [a, d, b.encoding], c);\n        };\n        a.prototype.writeBase = function (a, b, c, d, e) { return this.getFileByFdOrThrow(a, \"write\").write(b, c, d, e); };\n        a.prototype.writeSync = function (a, b, c, d, e) { Ya(a); var r = \"string\" !== typeof b; if (r) {\n            var D = (c || 0) | 0;\n            var f = d;\n            c = e;\n        }\n        else\n            var Xa = d; b = La(b, Xa); r ? \"undefined\" === typeof f && (f = b.length) : (D = 0, f = b.length); return this.writeBase(a, b, D, f, c); };\n        a.prototype.write = function (a, b, c, d, e, f) {\n            var r = this;\n            Ya(a);\n            var D = typeof b, Xa = typeof c, g = typeof d, h = typeof e;\n            if (\"string\" !== D)\n                if (\"function\" === Xa)\n                    var k = c;\n                else if (\"function\" === g) {\n                    var lb = c | 0;\n                    k = d;\n                }\n                else if (\"function\" === h) {\n                    lb = c | 0;\n                    var m = d;\n                    k = e;\n                }\n                else {\n                    lb = c | 0;\n                    m = d;\n                    var n = e;\n                    k = f;\n                }\n            else if (\"function\" === Xa)\n                k = c;\n            else if (\"function\" === g)\n                n = c, k = d;\n            else if (\"function\" === h) {\n                n = c;\n                var va = d;\n                k = e;\n            }\n            var p = La(b, va);\n            \"string\" !== D ? \"undefined\" === typeof m && (m = p.length) : (lb = 0, m = p.length);\n            var v = q(k);\n            $c.default(function () { try {\n                var c = r.writeBase(a, p, lb, m, n);\n                \"string\" !== D ? v(null, c, p) : v(null, c, b);\n            }\n            catch (qf) {\n                v(qf);\n            } });\n        };\n        a.prototype.writeFileBase = function (a, b, c, d) { var e = \"number\" === typeof a; a = e ? a : this.openBase(m(a), c, d); d = 0; var r = b.length; c = c & $a ? void 0 : 0; try {\n            for (; 0 < r;) {\n                var D = this.writeSync(a, b, d, r, c);\n                d += D;\n                r -= D;\n                void 0 !== c && (c += D);\n            }\n        }\n        finally {\n            e || this.closeSync(a);\n        } };\n        a.prototype.writeFileSync = function (a, b, c) { var d = Bd(c); c = k(d.flag); var e = M(d.mode); b = La(b, d.encoding); this.writeFileBase(a, b, c, e); };\n        a.prototype.writeFile = function (a, b, c, d) {\n            var e = c;\n            \"function\" === typeof c && (e = Ad, d = c);\n            c = q(d);\n            var r = Bd(e);\n            e = k(r.flag);\n            d = M(r.mode);\n            b = La(b, r.encoding);\n            this.wrapAsync(this.writeFileBase, [a, b, e, d], c);\n        };\n        a.prototype.linkBase = function (a, b) { var c = v(a), d = this.getLink(c); if (!d)\n            throw h(\"ENOENT\", \"link\", a, b); var e = v(b); c = this.getLinkParent(e); if (!c)\n            throw h(\"ENOENT\", \"link\", a, b); e = e[e.length - 1]; if (c.getChild(e))\n            throw h(\"EEXIST\", \"link\", a, b); a = d.getNode(); a.nlink++; c.createChild(e, a); };\n        a.prototype.copyFileBase = function (a, b, c) { var d = this.readFileSync(a); if (c & hf && this.existsSync(b))\n            throw h(\"EEXIST\", \"copyFile\", a, b); if (c & jf)\n            throw h(\"ENOSYS\", \"copyFile\", a, b); this.writeFileBase(b, d, ua.w, 438); };\n        a.prototype.copyFileSync =\n            function (a, b, c) { a = m(a); b = m(b); return this.copyFileBase(a, b, (c || 0) | 0); };\n        a.prototype.copyFile = function (a, b, c, d) { a = m(a); b = m(b); if (\"function\" === typeof c)\n            var e = 0;\n        else\n            e = c, c = d; q(c); this.wrapAsync(this.copyFileBase, [a, b, e], c); };\n        a.prototype.linkSync = function (a, b) { a = m(a); b = m(b); this.linkBase(a, b); };\n        a.prototype.link = function (a, b, c) { a = m(a); b = m(b); this.wrapAsync(this.linkBase, [a, b], c); };\n        a.prototype.unlinkBase = function (a) {\n            var b = v(a);\n            b = this.getLink(b);\n            if (!b)\n                throw h(\"ENOENT\", \"unlink\", a);\n            if (b.length)\n                throw Error(\"Dir not empty...\");\n            this.deleteLink(b);\n            a = b.getNode();\n            a.nlink--;\n            0 >= a.nlink && this.deleteNode(a);\n        };\n        a.prototype.unlinkSync = function (a) { a = m(a); this.unlinkBase(a); };\n        a.prototype.unlink = function (a, b) { a = m(a); this.wrapAsync(this.unlinkBase, [a], b); };\n        a.prototype.symlinkBase = function (a, b) { var c = v(b), d = this.getLinkParent(c); if (!d)\n            throw h(\"ENOENT\", \"symlink\", a, b); c = c[c.length - 1]; if (d.getChild(c))\n            throw h(\"EEXIST\", \"symlink\", a, b); b = d.createChild(c); b.getNode().makeSymlink(v(a)); return b; };\n        a.prototype.symlinkSync = function (a, b) {\n            a = m(a);\n            b = m(b);\n            this.symlinkBase(a, b);\n        };\n        a.prototype.symlink = function (a, b, c, d) { c = q(\"function\" === typeof c ? c : d); a = m(a); b = m(b); this.wrapAsync(this.symlinkBase, [a, b], c); };\n        a.prototype.realpathBase = function (a, b) { var c = v(a); c = this.getResolvedLink(c); if (!c)\n            throw h(\"ENOENT\", \"realpath\", a); return K.strToEncoding(c.getPath(), b); };\n        a.prototype.realpathSync = function (a, b) { return this.realpathBase(m(a), Ed(b).encoding); };\n        a.prototype.realpath = function (a, b, c) {\n            c = lf(b, c);\n            b = c[0];\n            c = c[1];\n            a = m(a);\n            this.wrapAsync(this.realpathBase, [a, b.encoding], c);\n        };\n        a.prototype.lstatBase = function (a, b) { void 0 === b && (b = !1); var c = this.getLink(v(a)); if (!c)\n            throw h(\"ENOENT\", \"lstat\", a); return ka.default.build(c.getNode(), b); };\n        a.prototype.lstatSync = function (a, b) { return this.lstatBase(m(a), e(b).bigint); };\n        a.prototype.lstat = function (a, b, c) { c = d(b, c); b = c[0]; c = c[1]; this.wrapAsync(this.lstatBase, [m(a), b.bigint], c); };\n        a.prototype.statBase = function (a, b) { void 0 === b && (b = !1); var c = this.getResolvedLink(v(a)); if (!c)\n            throw h(\"ENOENT\", \"stat\", a); return ka.default.build(c.getNode(), b); };\n        a.prototype.statSync = function (a, b) { return this.statBase(m(a), e(b).bigint); };\n        a.prototype.stat = function (a, b, c) { c = d(b, c); b = c[0]; c = c[1]; this.wrapAsync(this.statBase, [m(a), b.bigint], c); };\n        a.prototype.fstatBase = function (a, b) { void 0 === b && (b = !1); a = this.getFileByFd(a); if (!a)\n            throw h(\"EBADF\", \"fstat\"); return ka.default.build(a.node, b); };\n        a.prototype.fstatSync = function (a, b) { return this.fstatBase(a, e(b).bigint); };\n        a.prototype.fstat = function (a, b, c) { b = d(b, c); this.wrapAsync(this.fstatBase, [a, b[0].bigint], b[1]); };\n        a.prototype.renameBase =\n            function (a, b) { var c = this.getLink(v(a)); if (!c)\n                throw h(\"ENOENT\", \"rename\", a, b); var d = v(b), e = this.getLinkParent(d); if (!e)\n                throw h(\"ENOENT\", \"rename\", a, b); (a = c.parent) && a.deleteChild(c); c.steps = Xb(e.steps, [d[d.length - 1]]); e.setChild(c.getName(), c); };\n        a.prototype.renameSync = function (a, b) { a = m(a); b = m(b); this.renameBase(a, b); };\n        a.prototype.rename = function (a, b, c) { a = m(a); b = m(b); this.wrapAsync(this.renameBase, [a, b], c); };\n        a.prototype.existsBase = function (a) { return !!this.statBase(a); };\n        a.prototype.existsSync = function (a) { try {\n            return this.existsBase(m(a));\n        }\n        catch (D) {\n            return !1;\n        } };\n        a.prototype.exists = function (a, b) { var c = this, d = m(a); if (\"function\" !== typeof b)\n            throw Error(fa.CB); $c.default(function () { try {\n            b(c.existsBase(d));\n        }\n        catch (va) {\n            b(!1);\n        } }); };\n        a.prototype.accessBase = function (a) { this.getLinkOrThrow(a, \"access\"); };\n        a.prototype.accessSync = function (a, b) { void 0 === b && (b = wd); a = m(a); this.accessBase(a, b | 0); };\n        a.prototype.access = function (a, b, c) { var d = wd; \"function\" !== typeof b && (d = b | 0, b = q(c)); a = m(a); this.wrapAsync(this.accessBase, [a, d], b); };\n        a.prototype.appendFileSync = function (a, b, c) {\n            void 0 === c && (c =\n                Cd);\n            c = Dd(c);\n            c.flag && a >>> 0 !== a || (c.flag = \"a\");\n            this.writeFileSync(a, b, c);\n        };\n        a.prototype.appendFile = function (a, b, c, d) { d = kf(c, d); c = d[0]; d = d[1]; c.flag && a >>> 0 !== a || (c.flag = \"a\"); this.writeFile(a, b, c, d); };\n        a.prototype.readdirBase = function (a, b) {\n            var c = v(a);\n            c = this.getResolvedLink(c);\n            if (!c)\n                throw h(\"ENOENT\", \"readdir\", a);\n            if (!c.getNode().isDirectory())\n                throw h(\"ENOTDIR\", \"scandir\", a);\n            if (b.withFileTypes) {\n                var d = [];\n                for (e in c.children)\n                    (a = c.getChild(e)) && d.push(Qc.default.build(a, b.encoding));\n                Yb || \"buffer\" === b.encoding || d.sort(function (a, b) { return a.name < b.name ? -1 : a.name > b.name ? 1 : 0; });\n                return d;\n            }\n            var e = [];\n            for (d in c.children)\n                e.push(K.strToEncoding(d, b.encoding));\n            Yb || \"buffer\" === b.encoding || e.sort();\n            return e;\n        };\n        a.prototype.readdirSync = function (a, b) { b = Gd(b); a = m(a); return this.readdirBase(a, b); };\n        a.prototype.readdir = function (a, b, c) { c = mf(b, c); b = c[0]; c = c[1]; a = m(a); this.wrapAsync(this.readdirBase, [a, b], c); };\n        a.prototype.readlinkBase = function (a, b) {\n            var c = this.getLinkOrThrow(a, \"readlink\").getNode();\n            if (!c.isSymlink())\n                throw h(\"EINVAL\", \"readlink\", a);\n            a =\n                S + c.symlink.join(S);\n            return K.strToEncoding(a, b);\n        };\n        a.prototype.readlinkSync = function (a, b) { b = ob(b); a = m(a); return this.readlinkBase(a, b.encoding); };\n        a.prototype.readlink = function (a, b, c) { c = yd(b, c); b = c[0]; c = c[1]; a = m(a); this.wrapAsync(this.readlinkBase, [a, b.encoding], c); };\n        a.prototype.fsyncBase = function (a) { this.getFileByFdOrThrow(a, \"fsync\"); };\n        a.prototype.fsyncSync = function (a) { this.fsyncBase(a); };\n        a.prototype.fsync = function (a, b) { this.wrapAsync(this.fsyncBase, [a], b); };\n        a.prototype.fdatasyncBase = function (a) {\n            this.getFileByFdOrThrow(a, \"fdatasync\");\n        };\n        a.prototype.fdatasyncSync = function (a) { this.fdatasyncBase(a); };\n        a.prototype.fdatasync = function (a, b) { this.wrapAsync(this.fdatasyncBase, [a], b); };\n        a.prototype.ftruncateBase = function (a, b) { this.getFileByFdOrThrow(a, \"ftruncate\").truncate(b); };\n        a.prototype.ftruncateSync = function (a, b) { this.ftruncateBase(a, b); };\n        a.prototype.ftruncate = function (a, b, c) { var d = \"number\" === typeof b ? b : 0; b = q(\"number\" === typeof b ? c : b); this.wrapAsync(this.ftruncateBase, [a, d], b); };\n        a.prototype.truncateBase = function (a, b) {\n            a = this.openSync(a, \"r+\");\n            try {\n                this.ftruncateSync(a, b);\n            }\n            finally {\n                this.closeSync(a);\n            }\n        };\n        a.prototype.truncateSync = function (a, b) { if (a >>> 0 === a)\n            return this.ftruncateSync(a, b); this.truncateBase(a, b); };\n        a.prototype.truncate = function (a, b, c) { var d = \"number\" === typeof b ? b : 0; b = q(\"number\" === typeof b ? c : b); if (a >>> 0 === a)\n            return this.ftruncate(a, d, b); this.wrapAsync(this.truncateBase, [a, d], b); };\n        a.prototype.futimesBase = function (a, b, c) { a = this.getFileByFdOrThrow(a, \"futimes\").node; a.atime = new Date(1E3 * b); a.mtime = new Date(1E3 * c); };\n        a.prototype.futimesSync =\n            function (a, b, c) { this.futimesBase(a, ha(b), ha(c)); };\n        a.prototype.futimes = function (a, b, c, d) { this.wrapAsync(this.futimesBase, [a, ha(b), ha(c)], d); };\n        a.prototype.utimesBase = function (a, b, c) { a = this.openSync(a, \"r+\"); try {\n            this.futimesBase(a, b, c);\n        }\n        finally {\n            this.closeSync(a);\n        } };\n        a.prototype.utimesSync = function (a, b, c) { this.utimesBase(m(a), ha(b), ha(c)); };\n        a.prototype.utimes = function (a, b, c, d) { this.wrapAsync(this.utimesBase, [m(a), ha(b), ha(c)], d); };\n        a.prototype.mkdirBase = function (a, b) {\n            var c = v(a);\n            if (!c.length)\n                throw h(\"EISDIR\", \"mkdir\", a);\n            var d = this.getLinkParentAsDirOrThrow(a, \"mkdir\");\n            c = c[c.length - 1];\n            if (d.getChild(c))\n                throw h(\"EEXIST\", \"mkdir\", a);\n            d.createChild(c, this.createNode(!0, b));\n        };\n        a.prototype.mkdirpBase = function (a, b) { a = v(a); for (var c = this.root, d = 0; d < a.length; d++) {\n            var e = a[d];\n            if (!c.getNode().isDirectory())\n                throw h(\"ENOTDIR\", \"mkdir\", c.getPath());\n            var f = c.getChild(e);\n            if (f)\n                if (f.getNode().isDirectory())\n                    c = f;\n                else\n                    throw h(\"ENOTDIR\", \"mkdir\", f.getPath());\n            else\n                c = c.createChild(e, this.createNode(!0, b));\n        } };\n        a.prototype.mkdirSync = function (a, b) {\n            b =\n                f(b);\n            var c = M(b.mode, 511);\n            a = m(a);\n            b.recursive ? this.mkdirpBase(a, c) : this.mkdirBase(a, c);\n        };\n        a.prototype.mkdir = function (a, b, c) { var d = f(b); b = q(\"function\" === typeof b ? b : c); c = M(d.mode, 511); a = m(a); d.recursive ? this.wrapAsync(this.mkdirpBase, [a, c], b) : this.wrapAsync(this.mkdirBase, [a, c], b); };\n        a.prototype.mkdirpSync = function (a, b) { this.mkdirSync(a, { mode: b, recursive: !0 }); };\n        a.prototype.mkdirp = function (a, b, c) { var d = \"function\" === typeof b ? void 0 : b; b = q(\"function\" === typeof b ? b : c); this.mkdir(a, { mode: d, recursive: !0 }, b); };\n        a.prototype.mkdtempBase =\n            function (a, b, c) { void 0 === c && (c = 5); var d = a + this.genRndStr(); try {\n                return this.mkdirBase(d, 511), K.strToEncoding(d, b);\n            }\n            catch (va) {\n                if (\"EEXIST\" === va.code) {\n                    if (1 < c)\n                        return this.mkdtempBase(a, b, c - 1);\n                    throw Error(\"Could not create temp dir.\");\n                }\n                throw va;\n            } };\n        a.prototype.mkdtempSync = function (a, b) { b = ob(b).encoding; if (!a || \"string\" !== typeof a)\n            throw new TypeError(\"filename prefix is required\"); qb(a); return this.mkdtempBase(a, b); };\n        a.prototype.mkdtemp = function (a, b, c) {\n            c = yd(b, c);\n            b = c[0].encoding;\n            c = c[1];\n            if (!a || \"string\" !== typeof a)\n                throw new TypeError(\"filename prefix is required\");\n            qb(a) && this.wrapAsync(this.mkdtempBase, [a, b], c);\n        };\n        a.prototype.rmdirBase = function (a, b) { b = aa({}, Fd, b); var c = this.getLinkAsDirOrThrow(a, \"rmdir\"); if (c.length && !b.recursive)\n            throw h(\"ENOTEMPTY\", \"rmdir\", a); this.deleteLink(c); };\n        a.prototype.rmdirSync = function (a, b) { this.rmdirBase(m(a), b); };\n        a.prototype.rmdir = function (a, b, c) { var d = aa({}, Fd, b); b = q(\"function\" === typeof b ? b : c); this.wrapAsync(this.rmdirBase, [m(a), d], b); };\n        a.prototype.fchmodBase = function (a, b) { this.getFileByFdOrThrow(a, \"fchmod\").chmod(b); };\n        a.prototype.fchmodSync =\n            function (a, b) { this.fchmodBase(a, M(b)); };\n        a.prototype.fchmod = function (a, b, c) { this.wrapAsync(this.fchmodBase, [a, M(b)], c); };\n        a.prototype.chmodBase = function (a, b) { a = this.openSync(a, \"r+\"); try {\n            this.fchmodBase(a, b);\n        }\n        finally {\n            this.closeSync(a);\n        } };\n        a.prototype.chmodSync = function (a, b) { b = M(b); a = m(a); this.chmodBase(a, b); };\n        a.prototype.chmod = function (a, b, c) { b = M(b); a = m(a); this.wrapAsync(this.chmodBase, [a, b], c); };\n        a.prototype.lchmodBase = function (a, b) { a = this.openBase(a, na, 0, !1); try {\n            this.fchmodBase(a, b);\n        }\n        finally {\n            this.closeSync(a);\n        } };\n        a.prototype.lchmodSync = function (a, b) { b = M(b); a = m(a); this.lchmodBase(a, b); };\n        a.prototype.lchmod = function (a, b, c) { b = M(b); a = m(a); this.wrapAsync(this.lchmodBase, [a, b], c); };\n        a.prototype.fchownBase = function (a, b, c) { this.getFileByFdOrThrow(a, \"fchown\").chown(b, c); };\n        a.prototype.fchownSync = function (a, b, c) { Ha(b); Ia(c); this.fchownBase(a, b, c); };\n        a.prototype.fchown = function (a, b, c, d) { Ha(b); Ia(c); this.wrapAsync(this.fchownBase, [a, b, c], d); };\n        a.prototype.chownBase = function (a, b, c) {\n            this.getResolvedLinkOrThrow(a, \"chown\").getNode().chown(b, c);\n        };\n        a.prototype.chownSync = function (a, b, c) { Ha(b); Ia(c); this.chownBase(m(a), b, c); };\n        a.prototype.chown = function (a, b, c, d) { Ha(b); Ia(c); this.wrapAsync(this.chownBase, [m(a), b, c], d); };\n        a.prototype.lchownBase = function (a, b, c) { this.getLinkOrThrow(a, \"lchown\").getNode().chown(b, c); };\n        a.prototype.lchownSync = function (a, b, c) { Ha(b); Ia(c); this.lchownBase(m(a), b, c); };\n        a.prototype.lchown = function (a, b, c, d) { Ha(b); Ia(c); this.wrapAsync(this.lchownBase, [m(a), b, c], d); };\n        a.prototype.watchFile = function (a, b, c) {\n            a = m(a);\n            var d = b;\n            \"function\" ===\n                typeof d && (c = b, d = null);\n            if (\"function\" !== typeof c)\n                throw Error('\"watchFile()\" requires a listener function');\n            b = 5007;\n            var e = !0;\n            d && \"object\" === typeof d && (\"number\" === typeof d.interval && (b = d.interval), \"boolean\" === typeof d.persistent && (e = d.persistent));\n            d = this.statWatchers[a];\n            d || (d = new this.StatWatcher, d.start(a, e, b), this.statWatchers[a] = d);\n            d.addListener(\"change\", c);\n            return d;\n        };\n        a.prototype.unwatchFile = function (a, b) {\n            a = m(a);\n            var c = this.statWatchers[a];\n            c && (\"function\" === typeof b ? c.removeListener(\"change\", b) : c.removeAllListeners(\"change\"),\n                0 === c.listenerCount(\"change\") && (c.stop(), delete this.statWatchers[a]));\n        };\n        a.prototype.createReadStream = function (a, b) { return new this.ReadStream(a, b); };\n        a.prototype.createWriteStream = function (a, b) { return new this.WriteStream(a, b); };\n        a.prototype.watch = function (a, b, c) { a = m(a); var d = b; \"function\" === typeof b && (c = b, d = null); var e = ob(d); b = e.persistent; d = e.recursive; e = e.encoding; void 0 === b && (b = !0); void 0 === d && (d = !1); var f = new this.FSWatcher; f.start(a, b, d, e); c && f.addListener(\"change\", c); return f; };\n        a.fd = 2147483647;\n        return a;\n    }();\n    b.Volume = a;\n    var Hd = function (a) {\n        function b(b) { var c = a.call(this) || this; c.onInterval = function () { try {\n            var a = c.vol.statSync(c.filename);\n            c.hasChanged(a) && (c.emit(\"change\", a, c.prev), c.prev = a);\n        }\n        finally {\n            c.loop();\n        } }; c.vol = b; return c; }\n        Ja(b, a);\n        b.prototype.loop = function () { this.timeoutRef = this.setTimeout(this.onInterval, this.interval); };\n        b.prototype.hasChanged = function (a) { return a.mtimeMs > this.prev.mtimeMs || a.nlink !== this.prev.nlink ? !0 : !1; };\n        b.prototype.start = function (a, b, c) {\n            void 0 === b && (b = !0);\n            void 0 === c && (c = 5007);\n            this.filename =\n                m(a);\n            this.setTimeout = b ? setTimeout : hd.default;\n            this.interval = c;\n            this.prev = this.vol.statSync(this.filename);\n            this.loop();\n        };\n        b.prototype.stop = function () { clearTimeout(this.timeoutRef); L.default.nextTick(ef, this); };\n        return b;\n    }(O.EventEmitter);\n    b.StatWatcher = Hd;\n    var N;\n    lc.inherits(T, Y.Readable);\n    b.ReadStream = T;\n    T.prototype.open = function () { var a = this; this._vol.open(this.path, this.flags, this.mode, function (b, c) { b ? (a.autoClose && a.destroy && a.destroy(), a.emit(\"error\", b)) : (a.fd = c, a.emit(\"open\", c), a.read()); }); };\n    T.prototype._read =\n        function (a) {\n            if (\"number\" !== typeof this.fd)\n                return this.once(\"open\", function () { this._read(a); });\n            if (!this.destroyed) {\n                if (!N || 128 > N.length - N.used)\n                    N = F.bufferAllocUnsafe(this._readableState.highWaterMark), N.used = 0;\n                var b = N, c = Math.min(N.length - N.used, a), d = N.used;\n                void 0 !== this.pos && (c = Math.min(this.end - this.pos + 1, c));\n                if (0 >= c)\n                    return this.push(null);\n                var e = this;\n                this._vol.read(this.fd, N, N.used, c, this.pos, function (a, c) {\n                    a ? (e.autoClose && e.destroy && e.destroy(), e.emit(\"error\", a)) : (a = null, 0 < c && (e.bytesRead += c, a = b.slice(d, d + c)), e.push(a));\n                });\n                void 0 !== this.pos && (this.pos += c);\n                N.used += c;\n            }\n        };\n    T.prototype._destroy = function (a, b) { this.close(function (c) { b(a || c); }); };\n    T.prototype.close = function (a) { var b = this; if (a)\n        this.once(\"close\", a); if (this.closed || \"number\" !== typeof this.fd) {\n        if (\"number\" !== typeof this.fd) {\n            this.once(\"open\", ff);\n            return;\n        }\n        return L.default.nextTick(function () { return b.emit(\"close\"); });\n    } this.closed = !0; this._vol.close(this.fd, function (a) { a ? b.emit(\"error\", a) : b.emit(\"close\"); }); this.fd = null; };\n    lc.inherits(R, Y.Writable);\n    b.WriteStream =\n        R;\n    R.prototype.open = function () { this._vol.open(this.path, this.flags, this.mode, function (a, b) { a ? (this.autoClose && this.destroy && this.destroy(), this.emit(\"error\", a)) : (this.fd = b, this.emit(\"open\", b)); }.bind(this)); };\n    R.prototype._write = function (a, b, c) {\n        if (!(a instanceof F.Buffer))\n            return this.emit(\"error\", Error(\"Invalid data\"));\n        if (\"number\" !== typeof this.fd)\n            return this.once(\"open\", function () { this._write(a, b, c); });\n        var d = this;\n        this._vol.write(this.fd, a, 0, a.length, this.pos, function (a, b) {\n            if (a)\n                return d.autoClose && d.destroy &&\n                    d.destroy(), c(a);\n            d.bytesWritten += b;\n            c();\n        });\n        void 0 !== this.pos && (this.pos += a.length);\n    };\n    R.prototype._writev = function (a, b) { if (\"number\" !== typeof this.fd)\n        return this.once(\"open\", function () { this._writev(a, b); }); for (var c = this, d = a.length, e = Array(d), f = 0, g = 0; g < d; g++) {\n        var h = a[g].chunk;\n        e[g] = h;\n        f += h.length;\n    } d = F.Buffer.concat(e); this._vol.write(this.fd, d, 0, d.length, this.pos, function (a, d) { if (a)\n        return c.destroy && c.destroy(), b(a); c.bytesWritten += d; b(); }); void 0 !== this.pos && (this.pos += f); };\n    R.prototype._destroy = T.prototype._destroy;\n    R.prototype.close = T.prototype.close;\n    R.prototype.destroySoon = R.prototype.end;\n    var Id = function (a) {\n        function b(b) { var c = a.call(this) || this; c._filename = \"\"; c._filenameEncoded = \"\"; c._recursive = !1; c._encoding = K.ENCODING_UTF8; c._onNodeChange = function () { c._emit(\"change\"); }; c._onParentChild = function (a) { a.getName() === c._getName() && c._emit(\"rename\"); }; c._emit = function (a) { c.emit(\"change\", a, c._filenameEncoded); }; c._persist = function () { c._timer = setTimeout(c._persist, 1E6); }; c._vol = b; return c; }\n        Ja(b, a);\n        b.prototype._getName =\n            function () { return this._steps[this._steps.length - 1]; };\n        b.prototype.start = function (a, b, c, d) {\n            void 0 === b && (b = !0);\n            void 0 === c && (c = !1);\n            void 0 === d && (d = K.ENCODING_UTF8);\n            this._filename = m(a);\n            this._steps = v(this._filename);\n            this._filenameEncoded = K.strToEncoding(this._filename);\n            this._recursive = c;\n            this._encoding = d;\n            try {\n                this._link = this._vol.getLinkOrThrow(this._filename, \"FSWatcher\");\n            }\n            catch (Wb) {\n                throw b = Error(\"watch \" + this._filename + \" \" + Wb.code), b.code = Wb.code, b.errno = Wb.code, b;\n            }\n            this._link.getNode().on(\"change\", this._onNodeChange);\n            this._link.on(\"child:add\", this._onNodeChange);\n            this._link.on(\"child:delete\", this._onNodeChange);\n            if (a = this._link.parent)\n                a.setMaxListeners(a.getMaxListeners() + 1), a.on(\"child:delete\", this._onParentChild);\n            b && this._persist();\n        };\n        b.prototype.close = function () { clearTimeout(this._timer); this._link.getNode().removeListener(\"change\", this._onNodeChange); var a = this._link.parent; a && a.removeListener(\"child:delete\", this._onParentChild); };\n        return b;\n    }(O.EventEmitter);\n    b.FSWatcher = Id;\n});\nt(Xe);\nvar Ye = Xe.pathToFilename, Ze = Xe.filenameToSteps, $e = Xe.Volume, af = u(function (a, b) {\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    b.fsProps = \"constants F_OK R_OK W_OK X_OK Stats\".split(\" \");\n    b.fsSyncMethods = \"renameSync ftruncateSync truncateSync chownSync fchownSync lchownSync chmodSync fchmodSync lchmodSync statSync lstatSync fstatSync linkSync symlinkSync readlinkSync realpathSync unlinkSync rmdirSync mkdirSync mkdirpSync readdirSync closeSync openSync utimesSync futimesSync fsyncSync writeSync readSync readFileSync writeFileSync appendFileSync existsSync accessSync fdatasyncSync mkdtempSync copyFileSync createReadStream createWriteStream\".split(\" \");\n    b.fsAsyncMethods = \"rename ftruncate truncate chown fchown lchown chmod fchmod lchmod stat lstat fstat link symlink readlink realpath unlink rmdir mkdir mkdirp readdir close open utimes futimes fsync write read readFile writeFile appendFile exists access fdatasync mkdtemp copyFile watchFile unwatchFile watch\".split(\" \");\n});\nt(af);\nvar bf = u(function (a, b) {\n    function c(a) { for (var b = { F_OK: g, R_OK: h, W_OK: k, X_OK: p, constants: w.constants, Stats: ka.default, Dirent: Qc.default }, c = 0, d = e; c < d.length; c++) {\n        var n = d[c];\n        \"function\" === typeof a[n] && (b[n] = a[n].bind(a));\n    } c = 0; for (d = f; c < d.length; c++)\n        n = d[c], \"function\" === typeof a[n] && (b[n] = a[n].bind(a)); b.StatWatcher = a.StatWatcher; b.FSWatcher = a.FSWatcher; b.WriteStream = a.WriteStream; b.ReadStream = a.ReadStream; b.promises = a.promises; b._toUnixTimestamp = Xe.toUnixTimestamp; return b; }\n    var d = l && l.__assign || function () {\n        d =\n            Object.assign || function (a) { for (var b, c = 1, d = arguments.length; c < d; c++) {\n                b = arguments[c];\n                for (var e in b)\n                    Object.prototype.hasOwnProperty.call(b, e) && (a[e] = b[e]);\n            } return a; };\n        return d.apply(this, arguments);\n    };\n    Object.defineProperty(b, \"__esModule\", { value: !0 });\n    var e = af.fsSyncMethods, f = af.fsAsyncMethods, g = w.constants.F_OK, h = w.constants.R_OK, k = w.constants.W_OK, p = w.constants.X_OK;\n    b.Volume = Xe.Volume;\n    b.vol = new Xe.Volume;\n    b.createFsFromVolume = c;\n    b.fs = c(b.vol);\n    a.exports = d(d({}, a.exports), b.fs);\n    a.exports.semantic = !0;\n});\nt(bf);\nvar rf = bf.createFsFromVolume;\ngd.prototype.emit = function (a) { for (var b, c, d = [], e = 1; e < arguments.length; e++)\n    d[e - 1] = arguments[e]; e = this.listeners(a); try {\n    for (var f = da(e), g = f.next(); !g.done; g = f.next()) {\n        var h = g.value;\n        try {\n            h.apply(void 0, ia(d));\n        }\n        catch (k) {\n            console.error(k);\n        }\n    }\n}\ncatch (k) {\n    b = { error: k };\n}\nfinally {\n    try {\n        g && !g.done && (c = f.return) && c.call(f);\n    }\n    finally {\n        if (b)\n            throw b.error;\n    }\n} return 0 < e.length; };\nvar sf = function () {\n    function a() { this.volume = new $e; this.fs = rf(this.volume); this.fromJSON({ \"/dev/stdin\": \"\", \"/dev/stdout\": \"\", \"/dev/stderr\": \"\" }); }\n    a.prototype._toJSON = function (a, c, d) { void 0 === c && (c = {}); var b = !0, f; for (f in a.children) {\n        b = !1;\n        var g = a.getChild(f);\n        if (g) {\n            var h = g.getNode();\n            h && h.isFile() ? (g = g.getPath(), d && (g = Yc(d, g)), c[g] = h.getBuffer()) : h && h.isDirectory() && this._toJSON(g, c, d);\n        }\n    } a = a.getPath(); d && (a = Yc(d, a)); a && b && (c[a] = null); return c; };\n    a.prototype.toJSON = function (a, c, d) {\n        var b, f;\n        void 0 === c && (c = {});\n        void 0 === d && (d = !1);\n        var g = [];\n        if (a) {\n            a instanceof Array || (a = [a]);\n            try {\n                for (var h = da(a), k = h.next(); !k.done; k = h.next()) {\n                    var p = Ye(k.value), n = this.volume.getResolvedLink(p);\n                    n && g.push(n);\n                }\n            }\n            catch (xa) {\n                var q = { error: xa };\n            }\n            finally {\n                try {\n                    k && !k.done && (b = h.return) && b.call(h);\n                }\n                finally {\n                    if (q)\n                        throw q.error;\n                }\n            }\n        }\n        else\n            g.push(this.volume.root);\n        if (!g.length)\n            return c;\n        try {\n            for (var B = da(g), m = B.next(); !m.done; m = B.next())\n                n = m.value, this._toJSON(n, c, d ? n.getPath() : \"\");\n        }\n        catch (xa) {\n            var v = { error: xa };\n        }\n        finally {\n            try {\n                m && !m.done && (f = B.return) && f.call(B);\n            }\n            finally {\n                if (v)\n                    throw v.error;\n            }\n        }\n        return c;\n    };\n    a.prototype.fromJSONFixed = function (a, c) { for (var b in c) {\n        var e = c[b];\n        if (e ? null !== Object.getPrototypeOf(e) : null !== e) {\n            var f = Ze(b);\n            1 < f.length && (f = \"/\" + f.slice(0, f.length - 1).join(\"/\"), a.mkdirpBase(f, 511));\n            a.writeFileSync(b, e || \"\");\n        }\n        else\n            a.mkdirpBase(b, 511);\n    } };\n    a.prototype.fromJSON = function (a) {\n        this.volume = new $e;\n        this.fromJSONFixed(this.volume, a);\n        this.fs = rf(this.volume);\n        this.volume.releasedFds = [0, 1, 2];\n        a = this.volume.openSync(\"/dev/stderr\", \"w\");\n        var b = this.volume.openSync(\"/dev/stdout\", \"w\"), d = this.volume.openSync(\"/dev/stdin\", \"r\");\n        if (2 !== a)\n            throw Error(\"invalid handle for stderr: \" + a);\n        if (1 !== b)\n            throw Error(\"invalid handle for stdout: \" + b);\n        if (0 !== d)\n            throw Error(\"invalid handle for stdin: \" + d);\n    };\n    a.prototype.getStdOut = function () { return ba(this, void 0, void 0, function () { var a, c = this; return ca(this, function () { a = new Promise(function (a) { a(c.fs.readFileSync(\"/dev/stdout\", \"utf8\")); }); return [2, a]; }); }); };\n    return a;\n}();\nexports.WasmFs = sf;\nexports.default = sf;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/@wasmer/wasmfs/lib/index.esm.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\nfunction getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error('Invalid string. Length must be a multiple of 4');\n    }\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf('=');\n    if (validLen === -1)\n        validLen = len;\n    var placeHoldersLen = validLen === len\n        ? 0\n        : 4 - (validLen % 4);\n    return [validLen, placeHoldersLen];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;\n}\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;\n}\nfunction toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0\n        ? validLen - 4\n        : validLen;\n    var i;\n    for (i = 0; i < len; i += 4) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 18) |\n                (revLookup[b64.charCodeAt(i + 1)] << 12) |\n                (revLookup[b64.charCodeAt(i + 2)] << 6) |\n                revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = (tmp >> 16) & 0xFF;\n        arr[curByte++] = (tmp >> 8) & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 2) |\n                (revLookup[b64.charCodeAt(i + 1)] >> 4);\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 10) |\n                (revLookup[b64.charCodeAt(i + 1)] << 4) |\n                (revLookup[b64.charCodeAt(i + 2)] >> 2);\n        arr[curByte++] = (tmp >> 8) & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] +\n        lookup[num >> 12 & 0x3F] +\n        lookup[num >> 6 & 0x3F] +\n        lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i = start; i < end; i += 3) {\n        tmp =\n            ((uint8[i] << 16) & 0xFF0000) +\n                ((uint8[i + 1] << 8) & 0xFF00) +\n                (uint8[i + 2] & 0xFF);\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join('');\n}\nfunction fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] +\n            lookup[(tmp << 4) & 0x3F] +\n            '==');\n    }\n    else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] +\n            lookup[(tmp >> 4) & 0x3F] +\n            lookup[(tmp << 2) & 0x3F] +\n            '=');\n    }\n    return parts.join('');\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n/* eslint-env browser */\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (function () {\n    var warned = false;\n    return function () {\n        if (!warned) {\n            warned = true;\n            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n        }\n    };\n})();\n/**\n * Colors.\n */\nexports.colors = [\n    '#0000CC',\n    '#0000FF',\n    '#0033CC',\n    '#0033FF',\n    '#0066CC',\n    '#0066FF',\n    '#0099CC',\n    '#0099FF',\n    '#00CC00',\n    '#00CC33',\n    '#00CC66',\n    '#00CC99',\n    '#00CCCC',\n    '#00CCFF',\n    '#3300CC',\n    '#3300FF',\n    '#3333CC',\n    '#3333FF',\n    '#3366CC',\n    '#3366FF',\n    '#3399CC',\n    '#3399FF',\n    '#33CC00',\n    '#33CC33',\n    '#33CC66',\n    '#33CC99',\n    '#33CCCC',\n    '#33CCFF',\n    '#6600CC',\n    '#6600FF',\n    '#6633CC',\n    '#6633FF',\n    '#66CC00',\n    '#66CC33',\n    '#9900CC',\n    '#9900FF',\n    '#9933CC',\n    '#9933FF',\n    '#99CC00',\n    '#99CC33',\n    '#CC0000',\n    '#CC0033',\n    '#CC0066',\n    '#CC0099',\n    '#CC00CC',\n    '#CC00FF',\n    '#CC3300',\n    '#CC3333',\n    '#CC3366',\n    '#CC3399',\n    '#CC33CC',\n    '#CC33FF',\n    '#CC6600',\n    '#CC6633',\n    '#CC9900',\n    '#CC9933',\n    '#CCCC00',\n    '#CCCC33',\n    '#FF0000',\n    '#FF0033',\n    '#FF0066',\n    '#FF0099',\n    '#FF00CC',\n    '#FF00FF',\n    '#FF3300',\n    '#FF3333',\n    '#FF3366',\n    '#FF3399',\n    '#FF33CC',\n    '#FF33FF',\n    '#FF6600',\n    '#FF6633',\n    '#FF9900',\n    '#FF9933',\n    '#FFCC00',\n    '#FFCC33'\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n        return true;\n    }\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n        // Is firebug? http://stackoverflow.com/a/398120/376773\n        (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n        // Is firefox >= v31?\n        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n        // Double check webkit in userAgent just in case we are in a worker\n        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\nfunction formatArgs(args) {\n    args[0] = (this.useColors ? '%c' : '') +\n        this.namespace +\n        (this.useColors ? ' %c' : ' ') +\n        args[0] +\n        (this.useColors ? '%c ' : ' ') +\n        '+' + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    var c = 'color: ' + this.color;\n    args.splice(1, 0, c, 'color: inherit');\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    var index = 0;\n    var lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, function (match) {\n        if (match === '%%') {\n            return;\n        }\n        index++;\n        if (match === '%c') {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (function () { });\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem('debug', namespaces);\n        }\n        else {\n            exports.storage.removeItem('debug');\n        }\n    }\n    catch (error) {\n        // Swallow\n        // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n    var r;\n    try {\n        r = exports.storage.getItem('debug');\n    }\n    catch (error) {\n        // Swallow\n        // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== 'undefined' && 'env' in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\nfunction localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    }\n    catch (error) {\n        // Swallow\n        // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\nformatters.j = function (v) {\n    try {\n        return JSON.stringify(v);\n    }\n    catch (error) {\n        return '[UnexpectedJSONParseError]: ' + error.message;\n    }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nfunction setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach(function (key) {\n        createDebug[key] = env[key];\n    });\n    /**\n    * The currently active debug mode names, and names to skip.\n    */\n    createDebug.names = [];\n    createDebug.skips = [];\n    /**\n    * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n    *\n    * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n    */\n    createDebug.formatters = {};\n    /**\n    * Selects a color for a debug namespace\n    * @param {String} namespace The namespace string for the debug instance to be colored\n    * @return {Number|String} An ANSI color code for the given namespace\n    * @api private\n    */\n    function selectColor(namespace) {\n        var hash = 0;\n        for (var i = 0; i < namespace.length; i++) {\n            hash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n    * Create a debugger with the given `namespace`.\n    *\n    * @param {String} namespace\n    * @return {Function}\n    * @api public\n    */\n    function createDebug(namespace) {\n        var prevTime;\n        var enableOverride = null;\n        var namespacesCache;\n        var enabledCache;\n        function debug() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            var self = debug;\n            // Set `diff` timestamp\n            var curr = Number(new Date());\n            var ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== 'string') {\n                // Anything else let's inspect with %O\n                args.unshift('%O');\n            }\n            // Apply any `formatters` transformations\n            var index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n                // If we encounter an escaped % then don't increase the array index\n                if (match === '%%') {\n                    return '%';\n                }\n                index++;\n                var formatter = createDebug.formatters[format];\n                if (typeof formatter === 'function') {\n                    var val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            var logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, 'enabled', {\n            enumerable: true,\n            configurable: false,\n            get: function () {\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: function (v) {\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === 'function') {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n    * Enables a debug mode by namespaces. This can include modes\n    * separated by a colon and wildcards.\n    *\n    * @param {String} namespaces\n    * @api public\n    */\n    function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        var i;\n        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n        var len = split.length;\n        for (i = 0; i < len; i++) {\n            if (!split[i]) {\n                // ignore empty strings\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, '.*?');\n            if (namespaces[0] === '-') {\n                createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n            }\n            else {\n                createDebug.names.push(new RegExp('^' + namespaces + '$'));\n            }\n        }\n    }\n    /**\n    * Disable debug output.\n    *\n    * @return {String} namespaces\n    * @api public\n    */\n    function disable() {\n        var namespaces = __spreadArray(__spreadArray([], createDebug.names.map(toNamespace), true), createDebug.skips.map(toNamespace).map(function (namespace) { return '-' + namespace; }), true).join(',');\n        createDebug.enable('');\n        return namespaces;\n    }\n    /**\n    * Returns true if the given mode name is enabled, false otherwise.\n    *\n    * @param {String} name\n    * @return {Boolean}\n    * @api public\n    */\n    function enabled(name) {\n        if (name[name.length - 1] === '*') {\n            return true;\n        }\n        var i;\n        var len;\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n    * Convert regexp to namespace\n    *\n    * @param {RegExp} regxep\n    * @return {String} namespace\n    * @api private\n    */\n    function toNamespace(regexp) {\n        return regexp.toString()\n            .substring(2, regexp.toString().length - 2)\n            .replace(/\\.\\*\\?$/, '*');\n    }\n    /**\n    * Coerce `val`.\n    *\n    * @param {Mixed} val\n    * @return {Mixed}\n    * @api private\n    */\n    function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n    * XXX DO NOT USE. This is a temporary stub function.\n    * XXX It WILL be removed in the next major release.\n    */\n    function destroy() {\n        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = (nBytes * 8) - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? (nBytes - 1) : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & ((1 << (-nBits)) - 1);\n    s >>= (-nBits);\n    nBits += eLen;\n    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) { }\n    m = e & ((1 << (-nBits)) - 1);\n    e >>= (-nBits);\n    nBits += mLen;\n    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) { }\n    if (e === 0) {\n        e = 1 - eBias;\n    }\n    else if (e === eMax) {\n        return m ? NaN : ((s ? -1 : 1) * Infinity);\n    }\n    else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = (nBytes * 8) - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n    var i = isLE ? 0 : (nBytes - 1);\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    }\n    else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        }\n        else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        }\n        else if (e + eBias >= 1) {\n            m = ((value * c) - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        }\n        else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }\n    e = (e << mLen) | m;\n    eLen += mLen;\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }\n    buffer[offset + i - d] |= s * 128;\n};\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/is-observable/index.js":
/*!*********************************************!*\
  !*** ./node_modules/is-observable/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (value) {\n    if (!value) {\n        return false;\n    }\n    // eslint-disable-next-line no-use-extend-native/no-use-extend-native\n    if (typeof Symbol.observable === 'symbol' && typeof value[Symbol.observable] === 'function') {\n        // eslint-disable-next-line no-use-extend-native/no-use-extend-native\n        return value === value[Symbol.observable]();\n    }\n    if (typeof value['@@observable'] === 'function') {\n        return value === value['@@observable']();\n    }\n    return false;\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-observable/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar toString = {}.toString;\nmodule.exports = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\nmodule.exports = function (val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === 'string' && val.length > 0) {\n        return parse(val);\n    }\n    else if (type === 'number' && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error('val is not a non-empty string or a valid number. val=' +\n        JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\nfunction parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || 'ms').toLowerCase();\n    switch (type) {\n        case 'years':\n        case 'year':\n        case 'yrs':\n        case 'yr':\n        case 'y':\n            return n * y;\n        case 'weeks':\n        case 'week':\n        case 'w':\n            return n * w;\n        case 'days':\n        case 'day':\n        case 'd':\n            return n * d;\n        case 'hours':\n        case 'hour':\n        case 'hrs':\n        case 'hr':\n        case 'h':\n            return n * h;\n        case 'minutes':\n        case 'minute':\n        case 'mins':\n        case 'min':\n        case 'm':\n            return n * m;\n        case 'seconds':\n        case 'second':\n        case 'secs':\n        case 'sec':\n        case 's':\n            return n * s;\n        case 'milliseconds':\n        case 'millisecond':\n        case 'msecs':\n        case 'msec':\n        case 'ms':\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\nfunction fmtShort(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return Math.round(ms / d) + 'd';\n    }\n    if (msAbs >= h) {\n        return Math.round(ms / h) + 'h';\n    }\n    if (msAbs >= m) {\n        return Math.round(ms / m) + 'm';\n    }\n    if (msAbs >= s) {\n        return Math.round(ms / s) + 's';\n    }\n    return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\nfunction fmtLong(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, 'day');\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, 'hour');\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, 'minute');\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, 'second');\n    }\n    return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\nfunction plural(ms, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\");\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n    ? global.TYPED_ARRAY_SUPPORT\n    : typedArraySupport();\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength();\nfunction typedArraySupport() {\n    try {\n        var arr = new Uint8Array(1);\n        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42; } };\n        return arr.foo() === 42 && // typed array instances can be augmented\n            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n            arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n    }\n    catch (e) {\n        return false;\n    }\n}\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT\n        ? 0x7fffffff\n        : 0x3fffffff;\n}\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError('Invalid typed array length');\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length);\n        }\n        that.length = length;\n    }\n    return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\nfunction Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n    }\n    // Common case.\n    if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') {\n            throw new Error('If encoding is specified then the first argument must be a string');\n        }\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, encodingOrOffset, length);\n}\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n};\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === 'string') {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n};\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== 'undefined' && Symbol.species &&\n        Buffer[Symbol.species] === Buffer) {\n        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n        Object.defineProperty(Buffer, Symbol.species, {\n            value: null,\n            configurable: true\n        });\n    }\n}\nfunction assertSize(size) {\n    if (typeof size !== 'number') {\n        throw new TypeError('\"size\" argument must be a number');\n    }\n    else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n    }\n}\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === 'string'\n            ? createBuffer(that, size).fill(fill, encoding)\n            : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n};\nfunction allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            that[i] = 0;\n        }\n    }\n    return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n    return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n    return allocUnsafe(null, size);\n};\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') {\n        encoding = 'utf8';\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n    }\n    return that;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255;\n    }\n    return that;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\\'offset\\' is out of bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\\'length\\' is out of bounds');\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    }\n    else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    }\n    else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}\nfunction fromObject(that, obj) {\n    if (Buffer.isBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n        if (that.length === 0) {\n            return that;\n        }\n        obj.copy(that, 0, 0, len);\n        return that;\n    }\n    if (obj) {\n        if ((typeof ArrayBuffer !== 'undefined' &&\n            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n            if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === 'Buffer' && isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n            'size: 0x' + kMaxLength().toString(16) + ' bytes');\n    }\n    return length | 0;\n}\nfunction SlowBuffer(length) {\n    if (+length != length) { // eslint-disable-line eqeqeq\n        length = 0;\n    }\n    return Buffer.alloc(+length);\n}\nBuffer.isBuffer = function isBuffer(b) {\n    return !!(b != null && b._isBuffer);\n};\nBuffer.compare = function compare(a, b) {\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n        throw new TypeError('Arguments must be Buffers');\n    }\n    if (a === b)\n        return 0;\n    var x = a.length;\n    var y = b.length;\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y)\n        return -1;\n    if (y < x)\n        return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n        }\n    }\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== 'string') {\n        string = '' + string;\n    }\n    var len = string.length;\n    if (len === 0)\n        return 0;\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for (;;) {\n        switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n                return len;\n            case 'utf8':\n            case 'utf-8':\n            case undefined:\n                return utf8ToBytes(string).length;\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return len * 2;\n            case 'hex':\n                return len >>> 1;\n            case 'base64':\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase)\n                    return utf8ToBytes(string).length; // assume utf8\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return '';\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return '';\n    }\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return '';\n    }\n    if (!encoding)\n        encoding = 'utf8';\n    while (true) {\n        switch (encoding) {\n            case 'hex':\n                return hexSlice(this, start, end);\n            case 'utf8':\n            case 'utf-8':\n                return utf8Slice(this, start, end);\n            case 'ascii':\n                return asciiSlice(this, start, end);\n            case 'latin1':\n            case 'binary':\n                return latin1Slice(this, start, end);\n            case 'base64':\n                return base64Slice(this, start, end);\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase)\n                    throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = (encoding + '').toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 16-bits');\n    }\n    for (var i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 32-bits');\n    }\n    for (var i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 64-bits');\n    }\n    for (var i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0)\n        return '';\n    if (arguments.length === 0)\n        return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.equals = function equals(b) {\n    if (!Buffer.isBuffer(b))\n        throw new TypeError('Argument must be a Buffer');\n    if (this === b)\n        return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    var str = '';\n    var max = exports.INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n        if (this.length > max)\n            str += ' ... ';\n    }\n    return '<Buffer ' + str + '>';\n};\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!Buffer.isBuffer(target)) {\n        throw new TypeError('Argument must be a Buffer');\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError('out of range index');\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target)\n        return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for (var i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y)\n        return -1;\n    if (y < x)\n        return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0)\n        return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n        encoding = byteOffset;\n        byteOffset = 0;\n    }\n    else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    }\n    else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : (buffer.length - 1);\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0)\n        byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir)\n            return -1;\n        else\n            byteOffset = buffer.length - 1;\n    }\n    else if (byteOffset < 0) {\n        if (dir)\n            byteOffset = 0;\n        else\n            return -1;\n    }\n    // Normalize val\n    if (typeof val === 'string') {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    }\n    else if (typeof val === 'number') {\n        val = val & 0xFF; // Search for a byte value [0-255]\n        if (Buffer.TYPED_ARRAY_SUPPORT &&\n            typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            }\n            else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n    }\n    throw new TypeError('val must be string, number or Buffer');\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n            encoding === 'utf16le' || encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        }\n        else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1)\n                    foundIndex = i;\n                if (i - foundIndex + 1 === valLength)\n                    return foundIndex * indexSize;\n            }\n            else {\n                if (foundIndex !== -1)\n                    i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    }\n    else {\n        if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found)\n                return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    }\n    else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0)\n        throw new TypeError('Invalid hex string');\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed))\n            return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = 'utf8';\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, encoding)\n    }\n    else if (length === undefined && typeof offset === 'string') {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, offset[, length][, encoding])\n    }\n    else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined)\n                encoding = 'utf8';\n        }\n        else {\n            encoding = length;\n            length = undefined;\n        }\n        // legacy write(string, encoding, offset, length) - remove in v0.13\n    }\n    else {\n        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining)\n        length = remaining;\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n        throw new RangeError('Attempt to write outside buffer bounds');\n    }\n    if (!encoding)\n        encoding = 'utf8';\n    var loweredCase = false;\n    for (;;) {\n        switch (encoding) {\n            case 'hex':\n                return hexWrite(this, string, offset, length);\n            case 'utf8':\n            case 'utf-8':\n                return utf8Write(this, string, offset, length);\n            case 'ascii':\n                return asciiWrite(this, string, offset, length);\n            case 'latin1':\n            case 'binary':\n                return latin1Write(this, string, offset, length);\n            case 'base64':\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase)\n                    throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: 'Buffer',\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n    }\n    else {\n        return base64.fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = (firstByte > 0xEF) ? 4\n            : (firstByte > 0xDF) ? 3\n                : (firstByte > 0xBF) ? 2\n                    : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch (bytesPerSequence) {\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        }\n        else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = '';\n    var i = 0;\n    while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    var ret = '';\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    var ret = '';\n    end = Math.min(buf.length, end);\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0)\n        start = 0;\n    if (!end || end < 0 || end > len)\n        end = len;\n    var out = '';\n    for (var i = start; i < end; ++i) {\n        out += toHex(buf[i]);\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = '';\n    for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0)\n            start = 0;\n    }\n    else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0)\n            end = 0;\n    }\n    else if (end > len) {\n        end = len;\n    }\n    if (end < start)\n        end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n    }\n    else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for (var i = 0; i < sliceLen; ++i) {\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n    if ((offset % 1) !== 0 || offset < 0)\n        throw new RangeError('offset is not uint');\n    if (offset + ext > length)\n        throw new RangeError('Trying to access beyond buffer length');\n}\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert)\n        checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while (byteLength > 0 && (mul *= 0x100)) {\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 2, this.length);\n    return this[offset] | (this[offset + 1] << 8);\n};\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 2, this.length);\n    return (this[offset] << 8) | this[offset + 1];\n};\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return ((this[offset]) |\n        (this[offset + 1] << 8) |\n        (this[offset + 2] << 16)) +\n        (this[offset + 3] * 0x1000000);\n};\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return (this[offset] * 0x1000000) +\n        ((this[offset + 1] << 16) |\n            (this[offset + 2] << 8) |\n            this[offset + 3]);\n};\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert)\n        checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert)\n        checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while (i > 0 && (mul *= 0x100)) {\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80))\n        return (this[offset]);\n    return ((0xff - this[offset] + 1) * -1);\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 2, this.length);\n    var val = this[offset] | (this[offset + 1] << 8);\n    return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | (this[offset] << 8);\n    return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return (this[offset]) |\n        (this[offset + 1] << 8) |\n        (this[offset + 2] << 16) |\n        (this[offset + 3] << 24);\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return (this[offset] << 24) |\n        (this[offset + 1] << 16) |\n        (this[offset + 2] << 8) |\n        (this[offset + 3]);\n};\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 4, this.length);\n    return ieee754.read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert)\n        checkOffset(offset, 8, this.length);\n    return ieee754.read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!Buffer.isBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min)\n        throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length)\n        throw new RangeError('Index out of range');\n}\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while (++i < byteLength && (mul *= 0x100)) {\n        this[offset + i] = (value / mul) & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while (--i >= 0 && (mul *= 0x100)) {\n        this[offset + i] = (value / mul) & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT)\n        value = Math.floor(value);\n    this[offset] = (value & 0xff);\n    return offset + 1;\n};\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0)\n        value = 0xffff + value + 1;\n    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8;\n    }\n}\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value & 0xff);\n        this[offset + 1] = (value >>> 8);\n    }\n    else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value >>> 8);\n        this[offset + 1] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0)\n        value = 0xffffffff + value + 1;\n    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n    }\n}\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = (value >>> 24);\n        this[offset + 2] = (value >>> 16);\n        this[offset + 1] = (value >>> 8);\n        this[offset] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value >>> 24);\n        this[offset + 1] = (value >>> 16);\n        this[offset + 2] = (value >>> 8);\n        this[offset + 3] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while (++i < byteLength && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while (--i >= 0 && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT)\n        value = Math.floor(value);\n    if (value < 0)\n        value = 0xff + value + 1;\n    this[offset] = (value & 0xff);\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value & 0xff);\n        this[offset + 1] = (value >>> 8);\n    }\n    else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value >>> 8);\n        this[offset + 1] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value & 0xff);\n        this[offset + 1] = (value >>> 8);\n        this[offset + 2] = (value >>> 16);\n        this[offset + 3] = (value >>> 24);\n    }\n    else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert)\n        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0)\n        value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = (value >>> 24);\n        this[offset + 1] = (value >>> 16);\n        this[offset + 2] = (value >>> 8);\n        this[offset + 3] = (value & 0xff);\n    }\n    else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length)\n        throw new RangeError('Index out of range');\n    if (offset < 0)\n        throw new RangeError('Index out of range');\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n    }\n    ieee754.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start)\n        start = 0;\n    if (!end && end !== 0)\n        end = this.length;\n    if (targetStart >= target.length)\n        targetStart = target.length;\n    if (!targetStart)\n        targetStart = 0;\n    if (end > 0 && end < start)\n        end = start;\n    // Copy 0 bytes; we're done\n    if (end === start)\n        return 0;\n    if (target.length === 0 || this.length === 0)\n        return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds');\n    }\n    if (start < 0 || start >= this.length)\n        throw new RangeError('sourceStart out of bounds');\n    if (end < 0)\n        throw new RangeError('sourceEnd out of bounds');\n    // Are we oob?\n    if (end > this.length)\n        end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for (i = 0; i < len; ++i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        }\n        else if (typeof end === 'string') {\n            encoding = end;\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== 'string') {\n            throw new TypeError('encoding must be a string');\n        }\n        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n            throw new TypeError('Unknown encoding: ' + encoding);\n        }\n    }\n    else if (typeof val === 'number') {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError('Out of range index');\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val)\n        val = 0;\n    var i;\n    if (typeof val === 'number') {\n        for (i = start; i < end; ++i) {\n            this[i] = val;\n        }\n    }\n    else {\n        var bytes = Buffer.isBuffer(val)\n            ? val\n            : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n        for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2)\n        return '';\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while (str.length % 4 !== 0) {\n        str = str + '=';\n    }\n    return str;\n}\nfunction stringtrim(str) {\n    if (str.trim)\n        return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, '');\n}\nfunction toHex(n) {\n    if (n < 16)\n        return '0' + n.toString(16);\n    return n.toString(16);\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1)\n                    bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        }\n        else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1)\n                bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0)\n                break;\n            bytes.push(codePoint);\n        }\n        else if (codePoint < 0x800) {\n            if ((units -= 2) < 0)\n                break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0)\n                break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0)\n                break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else {\n            throw new Error('Invalid code point');\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0)\n            break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return base64.toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n        if ((i + offset >= dst.length) || (i >= src.length))\n            break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction isnan(val) {\n    return val !== val; // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/_scheduler.js":
/*!************************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/_scheduler.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncSerialScheduler = void 0;\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar AsyncSerialScheduler = /** @class */ (function () {\n    function AsyncSerialScheduler(observer) {\n        this._baseObserver = observer;\n        this._pendingPromises = new Set();\n    }\n    AsyncSerialScheduler.prototype.complete = function () {\n        var _this = this;\n        Promise.all(this._pendingPromises)\n            .then(function () { return _this._baseObserver.complete(); })\n            .catch(function (error) { return _this._baseObserver.error(error); });\n    };\n    AsyncSerialScheduler.prototype.error = function (error) {\n        this._baseObserver.error(error);\n    };\n    AsyncSerialScheduler.prototype.schedule = function (task) {\n        var _this = this;\n        var prevPromisesCompletion = Promise.all(this._pendingPromises);\n        var values = [];\n        var next = function (value) { return values.push(value); };\n        var promise = Promise.resolve()\n            .then(function () { return __awaiter(_this, void 0, void 0, function () {\n            var _i, values_1, value;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, prevPromisesCompletion];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, task(next)];\n                    case 2:\n                        _a.sent();\n                        this._pendingPromises.delete(promise);\n                        for (_i = 0, values_1 = values; _i < values_1.length; _i++) {\n                            value = values_1[_i];\n                            this._baseObserver.next(value);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); })\n            .catch(function (error) {\n            _this._pendingPromises.delete(promise);\n            _this._baseObserver.error(error);\n        });\n        this._pendingPromises.add(promise);\n    };\n    return AsyncSerialScheduler;\n}());\nexports.AsyncSerialScheduler = AsyncSerialScheduler;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/_scheduler.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/_symbols.js":
/*!**********************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/_symbols.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerObservableSymbol = exports.getSymbol = exports.hasSymbol = exports.hasSymbols = void 0;\nvar hasSymbols = function () { return typeof Symbol === \"function\"; };\nexports.hasSymbols = hasSymbols;\nvar hasSymbol = function (name) { return (0, exports.hasSymbols)() && Boolean(Symbol[name]); };\nexports.hasSymbol = hasSymbol;\nvar getSymbol = function (name) { return (0, exports.hasSymbol)(name) ? Symbol[name] : \"@@\" + name; };\nexports.getSymbol = getSymbol;\nfunction registerObservableSymbol() {\n    if ((0, exports.hasSymbols)() && !(0, exports.hasSymbol)(\"observable\")) {\n        Symbol.observable = Symbol(\"observable\");\n    }\n}\nexports.registerObservableSymbol = registerObservableSymbol;\nif (!(0, exports.hasSymbol)(\"asyncIterator\")) {\n    Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for(\"Symbol.asyncIterator\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/_symbols.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/_util.js":
/*!*******************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/_util.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isIterator = exports.isAsyncIterator = void 0;\n/// <reference lib=\"es2018\" />\nvar _symbols_1 = __webpack_require__(/*! ./_symbols */ \"./node_modules/observable-fns/dist.esm/_symbols.js\");\nfunction isAsyncIterator(thing) {\n    return thing && (0, _symbols_1.hasSymbol)(\"asyncIterator\") && thing[Symbol.asyncIterator];\n}\nexports.isAsyncIterator = isAsyncIterator;\nfunction isIterator(thing) {\n    return thing && (0, _symbols_1.hasSymbol)(\"iterator\") && thing[Symbol.iterator];\n}\nexports.isIterator = isIterator;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/_util.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/filter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _scheduler_1 = __webpack_require__(/*! ./_scheduler */ \"./node_modules/observable-fns/dist.esm/_scheduler.js\");\nvar observable_1 = __importDefault(__webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\"));\nvar unsubscribe_1 = __importDefault(__webpack_require__(/*! ./unsubscribe */ \"./node_modules/observable-fns/dist.esm/unsubscribe.js\"));\n/**\n * Filters the values emitted by another observable.\n * To be applied to an input observable using `pipe()`.\n */\nfunction filter(test) {\n    return function (observable) {\n        return new observable_1.default(function (observer) {\n            var scheduler = new _scheduler_1.AsyncSerialScheduler(observer);\n            var subscription = observable.subscribe({\n                complete: function () {\n                    scheduler.complete();\n                },\n                error: function (error) {\n                    scheduler.error(error);\n                },\n                next: function (input) {\n                    var _this = this;\n                    scheduler.schedule(function (next) { return __awaiter(_this, void 0, void 0, function () {\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0: return [4 /*yield*/, test(input)];\n                                case 1:\n                                    if (_a.sent()) {\n                                        next(input);\n                                    }\n                                    return [2 /*return*/];\n                            }\n                        });\n                    }); });\n                }\n            });\n            return function () { return (0, unsubscribe_1.default)(subscription); };\n        });\n    };\n}\nexports.default = filter;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/filter.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/flatMap.js":
/*!*********************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/flatMap.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator)\n        throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar _scheduler_1 = __webpack_require__(/*! ./_scheduler */ \"./node_modules/observable-fns/dist.esm/_scheduler.js\");\nvar _util_1 = __webpack_require__(/*! ./_util */ \"./node_modules/observable-fns/dist.esm/_util.js\");\nvar observable_1 = __importDefault(__webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\"));\nvar unsubscribe_1 = __importDefault(__webpack_require__(/*! ./unsubscribe */ \"./node_modules/observable-fns/dist.esm/unsubscribe.js\"));\n/**\n * Maps the values emitted by another observable. In contrast to `map()`\n * the `mapper` function returns an array of values that will be emitted\n * separately.\n * Use `flatMap()` to map input values to zero, one or multiple output\n * values. To be applied to an input observable using `pipe()`.\n */\nfunction flatMap(mapper) {\n    return function (observable) {\n        return new observable_1.default(function (observer) {\n            var scheduler = new _scheduler_1.AsyncSerialScheduler(observer);\n            var subscription = observable.subscribe({\n                complete: function () {\n                    scheduler.complete();\n                },\n                error: function (error) {\n                    scheduler.error(error);\n                },\n                next: function (input) {\n                    var _this = this;\n                    scheduler.schedule(function (next) { return __awaiter(_this, void 0, void 0, function () {\n                        var e_1, _a, mapped, mapped_1, mapped_1_1, element, e_1_1_1;\n                        return __generator(this, function (_b) {\n                            switch (_b.label) {\n                                case 0: return [4 /*yield*/, mapper(input)];\n                                case 1:\n                                    mapped = _b.sent();\n                                    if (!((0, _util_1.isIterator)(mapped) || (0, _util_1.isAsyncIterator)(mapped))) return [3 /*break*/, 14];\n                                    _b.label = 2;\n                                case 2:\n                                    _b.trys.push([2, 7, 8, 13]);\n                                    mapped_1 = __asyncValues(mapped);\n                                    _b.label = 3;\n                                case 3: return [4 /*yield*/, mapped_1.next()];\n                                case 4:\n                                    if (!(mapped_1_1 = _b.sent(), !mapped_1_1.done)) return [3 /*break*/, 6];\n                                    element = mapped_1_1.value;\n                                    next(element);\n                                    _b.label = 5;\n                                case 5: return [3 /*break*/, 3];\n                                case 6: return [3 /*break*/, 13];\n                                case 7:\n                                    e_1_1_1 = _b.sent();\n                                    e_1 = { error: e_1_1_1 };\n                                    return [3 /*break*/, 13];\n                                case 8:\n                                    _b.trys.push([8, , 11, 12]);\n                                    if (!(mapped_1_1 && !mapped_1_1.done && (_a = mapped_1.return))) return [3 /*break*/, 10];\n                                    return [4 /*yield*/, _a.call(mapped_1)];\n                                case 9:\n                                    _b.sent();\n                                    _b.label = 10;\n                                case 10: return [3 /*break*/, 12];\n                                case 11:\n                                    if (e_1)\n                                        throw e_1.error;\n                                    return [7 /*endfinally*/];\n                                case 12: return [7 /*endfinally*/];\n                                case 13: return [3 /*break*/, 15];\n                                case 14:\n                                    mapped.map(function (output) { return next(output); });\n                                    _b.label = 15;\n                                case 15: return [2 /*return*/];\n                            }\n                        });\n                    }); });\n                }\n            });\n            return function () { return (0, unsubscribe_1.default)(subscription); };\n        });\n    };\n}\nexports.default = flatMap;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/flatMap.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unsubscribe = exports.Subject = exports.scan = exports.Observable = exports.multicast = exports.merge = exports.map = exports.interval = exports.flatMap = exports.filter = void 0;\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/observable-fns/dist.esm/filter.js\");\nObject.defineProperty(exports, \"filter\", { enumerable: true, get: function () { return __importDefault(filter_1).default; } });\nvar flatMap_1 = __webpack_require__(/*! ./flatMap */ \"./node_modules/observable-fns/dist.esm/flatMap.js\");\nObject.defineProperty(exports, \"flatMap\", { enumerable: true, get: function () { return __importDefault(flatMap_1).default; } });\nvar interval_1 = __webpack_require__(/*! ./interval */ \"./node_modules/observable-fns/dist.esm/interval.js\");\nObject.defineProperty(exports, \"interval\", { enumerable: true, get: function () { return __importDefault(interval_1).default; } });\nvar map_1 = __webpack_require__(/*! ./map */ \"./node_modules/observable-fns/dist.esm/map.js\");\nObject.defineProperty(exports, \"map\", { enumerable: true, get: function () { return __importDefault(map_1).default; } });\nvar merge_1 = __webpack_require__(/*! ./merge */ \"./node_modules/observable-fns/dist.esm/merge.js\");\nObject.defineProperty(exports, \"merge\", { enumerable: true, get: function () { return __importDefault(merge_1).default; } });\nvar multicast_1 = __webpack_require__(/*! ./multicast */ \"./node_modules/observable-fns/dist.esm/multicast.js\");\nObject.defineProperty(exports, \"multicast\", { enumerable: true, get: function () { return __importDefault(multicast_1).default; } });\nvar observable_1 = __webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\");\nObject.defineProperty(exports, \"Observable\", { enumerable: true, get: function () { return __importDefault(observable_1).default; } });\nvar scan_1 = __webpack_require__(/*! ./scan */ \"./node_modules/observable-fns/dist.esm/scan.js\");\nObject.defineProperty(exports, \"scan\", { enumerable: true, get: function () { return __importDefault(scan_1).default; } });\nvar subject_1 = __webpack_require__(/*! ./subject */ \"./node_modules/observable-fns/dist.esm/subject.js\");\nObject.defineProperty(exports, \"Subject\", { enumerable: true, get: function () { return __importDefault(subject_1).default; } });\nvar unsubscribe_1 = __webpack_require__(/*! ./unsubscribe */ \"./node_modules/observable-fns/dist.esm/unsubscribe.js\");\nObject.defineProperty(exports, \"unsubscribe\", { enumerable: true, get: function () { return __importDefault(unsubscribe_1).default; } });\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/index.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/interval.js":
/*!**********************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/interval.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar observable_1 = __webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\");\n/**\n * Creates an observable that yields a new value every `period` milliseconds.\n * The first value emitted is 0, then 1, 2, etc. The first value is not emitted\n * immediately, but after the first interval.\n */\nfunction interval(period) {\n    return new observable_1.Observable(function (observer) {\n        var counter = 0;\n        var handle = setInterval(function () {\n            observer.next(counter++);\n        }, period);\n        return function () { return clearInterval(handle); };\n    });\n}\nexports.default = interval;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/interval.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/map.js":
/*!*****************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/map.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _scheduler_1 = __webpack_require__(/*! ./_scheduler */ \"./node_modules/observable-fns/dist.esm/_scheduler.js\");\nvar observable_1 = __importDefault(__webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\"));\nvar unsubscribe_1 = __importDefault(__webpack_require__(/*! ./unsubscribe */ \"./node_modules/observable-fns/dist.esm/unsubscribe.js\"));\n/**\n * Maps the values emitted by another observable to different values.\n * To be applied to an input observable using `pipe()`.\n */\nfunction map(mapper) {\n    return function (observable) {\n        return new observable_1.default(function (observer) {\n            var scheduler = new _scheduler_1.AsyncSerialScheduler(observer);\n            var subscription = observable.subscribe({\n                complete: function () {\n                    scheduler.complete();\n                },\n                error: function (error) {\n                    scheduler.error(error);\n                },\n                next: function (input) {\n                    var _this = this;\n                    scheduler.schedule(function (next) { return __awaiter(_this, void 0, void 0, function () {\n                        var mapped;\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0: return [4 /*yield*/, mapper(input)];\n                                case 1:\n                                    mapped = _a.sent();\n                                    next(mapped);\n                                    return [2 /*return*/];\n                            }\n                        });\n                    }); });\n                }\n            });\n            return function () { return (0, unsubscribe_1.default)(subscription); };\n        });\n    };\n}\nexports.default = map;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/map.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/merge.js":
/*!*******************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/merge.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar observable_1 = __webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\");\nvar unsubscribe_1 = __importDefault(__webpack_require__(/*! ./unsubscribe */ \"./node_modules/observable-fns/dist.esm/unsubscribe.js\"));\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    if (observables.length === 0) {\n        return observable_1.Observable.from([]);\n    }\n    return new observable_1.Observable(function (observer) {\n        var completed = 0;\n        var subscriptions = observables.map(function (input) {\n            return input.subscribe({\n                error: function (error) {\n                    observer.error(error);\n                    unsubscribeAll();\n                },\n                next: function (value) {\n                    observer.next(value);\n                },\n                complete: function () {\n                    if (++completed === observables.length) {\n                        observer.complete();\n                        unsubscribeAll();\n                    }\n                }\n            });\n        });\n        var unsubscribeAll = function () {\n            subscriptions.forEach(function (subscription) { return (0, unsubscribe_1.default)(subscription); });\n        };\n        return unsubscribeAll;\n    });\n}\nexports.default = merge;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/merge.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/multicast.js":
/*!***********************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/multicast.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar observable_1 = __importDefault(__webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\"));\nvar subject_1 = __importDefault(__webpack_require__(/*! ./subject */ \"./node_modules/observable-fns/dist.esm/subject.js\"));\nvar unsubscribe_1 = __importDefault(__webpack_require__(/*! ./unsubscribe */ \"./node_modules/observable-fns/dist.esm/unsubscribe.js\"));\n// TODO: Subject already creates additional observables \"under the hood\",\n//       now we introduce even more. A true native MulticastObservable\n//       would be preferable.\n/**\n * Takes a \"cold\" observable and returns a wrapping \"hot\" observable that\n * proxies the input observable's values and errors.\n *\n * An observable is called \"cold\" when its initialization function is run\n * for each new subscriber. This is how observable-fns's `Observable`\n * implementation works.\n *\n * A hot observable is an observable where new subscribers subscribe to\n * the upcoming values of an already-initialiazed observable.\n *\n * The multicast observable will lazily subscribe to the source observable\n * once it has its first own subscriber and will unsubscribe from the\n * source observable when its last own subscriber unsubscribed.\n */\nfunction multicast(coldObservable) {\n    var subject = new subject_1.default();\n    var sourceSubscription;\n    var subscriberCount = 0;\n    return new observable_1.default(function (observer) {\n        // Init source subscription lazily\n        if (!sourceSubscription) {\n            sourceSubscription = coldObservable.subscribe(subject);\n        }\n        // Pipe all events from `subject` into this observable\n        var subscription = subject.subscribe(observer);\n        subscriberCount++;\n        return function () {\n            subscriberCount--;\n            subscription.unsubscribe();\n            // Close source subscription once last subscriber has unsubscribed\n            if (subscriberCount === 0) {\n                (0, unsubscribe_1.default)(sourceSubscription);\n                sourceSubscription = undefined;\n            }\n        };\n    });\n}\nexports.default = multicast;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/multicast.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/observable.js":
/*!************************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/observable.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Observable = exports.SubscriptionObserver = exports.Subscription = void 0;\n/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\n__webpack_require__(/*! ./symbols */ \"./node_modules/observable-fns/dist.esm/symbols.js\");\nvar _symbols_1 = __webpack_require__(/*! ./_symbols */ \"./node_modules/observable-fns/dist.esm/_symbols.js\");\nvar SymbolIterator = (0, _symbols_1.getSymbol)(\"iterator\");\nvar SymbolObservable = (0, _symbols_1.getSymbol)(\"observable\");\nvar SymbolSpecies = (0, _symbols_1.getSymbol)(\"species\");\n// === Abstract Operations ===\nfunction getMethod(obj, key) {\n    var value = obj[key];\n    if (value == null) {\n        return undefined;\n    }\n    if (typeof value !== \"function\") {\n        throw new TypeError(value + \" is not a function\");\n    }\n    return value;\n}\nfunction getSpecies(obj) {\n    var ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(error) {\n    if (hostReportError.log) {\n        hostReportError.log(error);\n    }\n    else {\n        setTimeout(function () { throw error; }, 0);\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(function () {\n        try {\n            fn();\n        }\n        catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    var cleanup = subscription._cleanup;\n    if (cleanup === undefined) {\n        return;\n    }\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        }\n        else {\n            var unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    var queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for (var _i = 0, queue_1 = queue; _i < queue_1.length; _i++) {\n        var item = queue_1[_i];\n        notifySubscription(subscription, item.type, item.value);\n        if (subscription._state === \"closed\") {\n            break;\n        }\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    var observer = subscription._observer;\n    try {\n        var m = observer ? getMethod(observer, type) : undefined;\n        switch (type) {\n            case \"next\":\n                if (m)\n                    m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer, value);\n                else\n                    throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer);\n                break;\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") {\n        cleanupSubscription(subscription);\n    }\n    else if (subscription._state === \"running\") {\n        subscription._state = \"ready\";\n    }\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") {\n        return;\n    }\n    if (subscription._state === \"buffering\") {\n        subscription._queue = subscription._queue || [];\n        subscription._queue.push({ type: type, value: value });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [{ type: type, value: value }];\n        enqueue(function () { return flushSubscription(subscription); });\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nvar Subscription = /** @class */ (function () {\n    function Subscription(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        var subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        }\n        catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") {\n            this._state = \"ready\";\n        }\n    }\n    Object.defineProperty(Subscription.prototype, \"closed\", {\n        get: function () {\n            return this._state === \"closed\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Subscription.prototype.unsubscribe = function () {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    };\n    return Subscription;\n}());\nexports.Subscription = Subscription;\nvar SubscriptionObserver = /** @class */ (function () {\n    function SubscriptionObserver(subscription) {\n        this._subscription = subscription;\n    }\n    Object.defineProperty(SubscriptionObserver.prototype, \"closed\", {\n        get: function () { return this._subscription._state === \"closed\"; },\n        enumerable: false,\n        configurable: true\n    });\n    SubscriptionObserver.prototype.next = function (value) { onNotify(this._subscription, \"next\", value); };\n    SubscriptionObserver.prototype.error = function (value) { onNotify(this._subscription, \"error\", value); };\n    SubscriptionObserver.prototype.complete = function () { onNotify(this._subscription, \"complete\"); };\n    return SubscriptionObserver;\n}());\nexports.SubscriptionObserver = SubscriptionObserver;\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\nvar Observable = /** @class */ (function () {\n    function Observable(subscriber) {\n        if (!(this instanceof Observable)) {\n            throw new TypeError(\"Observable cannot be called as a function\");\n        }\n        if (typeof subscriber !== \"function\") {\n            throw new TypeError(\"Observable initializer must be a function\");\n        }\n        this._subscriber = subscriber;\n    }\n    Observable.prototype.subscribe = function (nextOrObserver, onError, onComplete) {\n        if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n            nextOrObserver = {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            };\n        }\n        return new Subscription(nextOrObserver, this._subscriber);\n    };\n    Observable.prototype.pipe = function (first) {\n        var mappers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            mappers[_i - 1] = arguments[_i];\n        }\n        // tslint:disable-next-line no-this-assignment\n        var intermediate = this;\n        for (var _a = 0, _b = __spreadArray([first], mappers, true); _a < _b.length; _a++) {\n            var mapper = _b[_a];\n            intermediate = mapper(intermediate);\n        }\n        return intermediate;\n    };\n    Observable.prototype.tap = function (nextOrObserver, onError, onComplete) {\n        var _this = this;\n        var tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null\n            ? {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            }\n            : nextOrObserver;\n        return new Observable(function (observer) {\n            return _this.subscribe({\n                next: function (value) {\n                    tapObserver.next && tapObserver.next(value);\n                    observer.next(value);\n                },\n                error: function (error) {\n                    tapObserver.error && tapObserver.error(error);\n                    observer.error(error);\n                },\n                complete: function () {\n                    tapObserver.complete && tapObserver.complete();\n                    observer.complete();\n                },\n                start: function (subscription) {\n                    tapObserver.start && tapObserver.start(subscription);\n                }\n            });\n        });\n    };\n    Observable.prototype.forEach = function (fn) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve(undefined);\n            }\n            var subscription = _this.subscribe({\n                next: function (value) {\n                    try {\n                        fn(value, done);\n                    }\n                    catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error: function (error) {\n                    reject(error);\n                },\n                complete: function () {\n                    resolve(undefined);\n                }\n            });\n        });\n    };\n    Observable.prototype.map = function (fn) {\n        var _this = this;\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        var C = getSpecies(this);\n        return new C(function (observer) { return _this.subscribe({\n            next: function (value) {\n                var propagatedValue = value;\n                try {\n                    propagatedValue = fn(value);\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(propagatedValue);\n            },\n            error: function (e) { observer.error(e); },\n            complete: function () { observer.complete(); },\n        }); });\n    };\n    Observable.prototype.filter = function (fn) {\n        var _this = this;\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        var C = getSpecies(this);\n        return new C(function (observer) { return _this.subscribe({\n            next: function (value) {\n                try {\n                    if (!fn(value))\n                        return;\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(value);\n            },\n            error: function (e) { observer.error(e); },\n            complete: function () { observer.complete(); },\n        }); });\n    };\n    Observable.prototype.reduce = function (fn, seed) {\n        var _this = this;\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        var C = getSpecies(this);\n        var hasSeed = arguments.length > 1;\n        var hasValue = false;\n        var acc = seed;\n        return new C(function (observer) { return _this.subscribe({\n            next: function (value) {\n                var first = !hasValue;\n                hasValue = true;\n                if (!first || hasSeed) {\n                    try {\n                        acc = fn(acc, value);\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                }\n                else {\n                    acc = value;\n                }\n            },\n            error: function (e) { observer.error(e); },\n            complete: function () {\n                if (!hasValue && !hasSeed) {\n                    return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                }\n                observer.next(acc);\n                observer.complete();\n            },\n        }); });\n    };\n    Observable.prototype.concat = function () {\n        var _this = this;\n        var sources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sources[_i] = arguments[_i];\n        }\n        var C = getSpecies(this);\n        return new C(function (observer) {\n            var subscription;\n            var index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next: function (v) { observer.next(v); },\n                    error: function (e) { observer.error(e); },\n                    complete: function () {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        }\n                        else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    },\n                });\n            }\n            startNext(_this);\n            return function () {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    };\n    Observable.prototype.flatMap = function (fn) {\n        var _this = this;\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        var C = getSpecies(this);\n        return new C(function (observer) {\n            var subscriptions = [];\n            var outer = _this.subscribe({\n                next: function (value) {\n                    var normalizedValue;\n                    if (fn) {\n                        try {\n                            normalizedValue = fn(value);\n                        }\n                        catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    else {\n                        normalizedValue = value;\n                    }\n                    var inner = C.from(normalizedValue).subscribe({\n                        next: function (innerValue) { observer.next(innerValue); },\n                        error: function (e) { observer.error(e); },\n                        complete: function () {\n                            var i = subscriptions.indexOf(inner);\n                            if (i >= 0)\n                                subscriptions.splice(i, 1);\n                            completeIfDone();\n                        },\n                    });\n                    subscriptions.push(inner);\n                },\n                error: function (e) { observer.error(e); },\n                complete: function () { completeIfDone(); },\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) {\n                    observer.complete();\n                }\n            }\n            return function () {\n                subscriptions.forEach(function (s) { return s.unsubscribe(); });\n                outer.unsubscribe();\n            };\n        });\n    };\n    Observable.prototype[(Symbol.observable, SymbolObservable)] = function () { return this; };\n    Observable.from = function (x) {\n        var C = (typeof this === \"function\" ? this : Observable);\n        if (x == null) {\n            throw new TypeError(x + \" is not an object\");\n        }\n        var observableMethod = getMethod(x, SymbolObservable);\n        if (observableMethod) {\n            var observable_1 = observableMethod.call(x);\n            if (Object(observable_1) !== observable_1) {\n                throw new TypeError(observable_1 + \" is not an object\");\n            }\n            if (isObservable(observable_1) && observable_1.constructor === C) {\n                return observable_1;\n            }\n            return new C(function (observer) { return observable_1.subscribe(observer); });\n        }\n        if ((0, _symbols_1.hasSymbol)(\"iterator\")) {\n            var iteratorMethod_1 = getMethod(x, SymbolIterator);\n            if (iteratorMethod_1) {\n                return new C(function (observer) {\n                    enqueue(function () {\n                        if (observer.closed)\n                            return;\n                        for (var _i = 0, _a = iteratorMethod_1.call(x); _i < _a.length; _i++) {\n                            var item = _a[_i];\n                            observer.next(item);\n                            if (observer.closed)\n                                return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(function (observer) {\n                enqueue(function () {\n                    if (observer.closed)\n                        return;\n                    for (var _i = 0, x_1 = x; _i < x_1.length; _i++) {\n                        var item = x_1[_i];\n                        observer.next(item);\n                        if (observer.closed)\n                            return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    };\n    Observable.of = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var C = (typeof this === \"function\" ? this : Observable);\n        return new C(function (observer) {\n            enqueue(function () {\n                if (observer.closed)\n                    return;\n                for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n                    var item = items_1[_i];\n                    observer.next(item);\n                    if (observer.closed)\n                        return;\n                }\n                observer.complete();\n            });\n        });\n    };\n    Object.defineProperty(Observable, SymbolSpecies, {\n        get: function () { return this; },\n        enumerable: false,\n        configurable: true\n    });\n    return Observable;\n}());\nexports.Observable = Observable;\nif ((0, _symbols_1.hasSymbols)()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError: hostReportError,\n        },\n        configurable: true,\n    });\n}\nexports.default = Observable;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/observable.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/scan.js":
/*!******************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/scan.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _scheduler_1 = __webpack_require__(/*! ./_scheduler */ \"./node_modules/observable-fns/dist.esm/_scheduler.js\");\nvar observable_1 = __importDefault(__webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\"));\nvar unsubscribe_1 = __importDefault(__webpack_require__(/*! ./unsubscribe */ \"./node_modules/observable-fns/dist.esm/unsubscribe.js\"));\nfunction scan(accumulator, seed) {\n    return function (observable) {\n        return new observable_1.default(function (observer) {\n            var accumulated;\n            var index = 0;\n            var scheduler = new _scheduler_1.AsyncSerialScheduler(observer);\n            var subscription = observable.subscribe({\n                complete: function () {\n                    scheduler.complete();\n                },\n                error: function (error) {\n                    scheduler.error(error);\n                },\n                next: function (value) {\n                    var _this = this;\n                    scheduler.schedule(function (next) { return __awaiter(_this, void 0, void 0, function () {\n                        var prevAcc;\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0:\n                                    prevAcc = index === 0\n                                        ? (typeof seed === \"undefined\" ? value : seed)\n                                        : accumulated;\n                                    return [4 /*yield*/, accumulator(prevAcc, value, index++)];\n                                case 1:\n                                    accumulated = _a.sent();\n                                    next(accumulated);\n                                    return [2 /*return*/];\n                            }\n                        });\n                    }); });\n                }\n            });\n            return function () { return (0, unsubscribe_1.default)(subscription); };\n        });\n    };\n}\nexports.default = scan;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/scan.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/subject.js":
/*!*********************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/subject.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar observable_1 = __importDefault(__webpack_require__(/*! ./observable */ \"./node_modules/observable-fns/dist.esm/observable.js\"));\n// TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\nvar MulticastSubject = /** @class */ (function (_super) {\n    __extends(MulticastSubject, _super);\n    function MulticastSubject() {\n        var _this = _super.call(this, function (observer) {\n            _this._observers.add(observer);\n            return function () { return _this._observers.delete(observer); };\n        }) || this;\n        _this._observers = new Set();\n        return _this;\n    }\n    MulticastSubject.prototype.next = function (value) {\n        for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {\n            var observer = _a[_i];\n            observer.next(value);\n        }\n    };\n    MulticastSubject.prototype.error = function (error) {\n        for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {\n            var observer = _a[_i];\n            observer.error(error);\n        }\n    };\n    MulticastSubject.prototype.complete = function () {\n        for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {\n            var observer = _a[_i];\n            observer.complete();\n        }\n    };\n    return MulticastSubject;\n}(observable_1.default));\nexports.default = MulticastSubject;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/subject.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/symbols.js":
/*!*********************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/symbols.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/symbols.js?");

/***/ }),

/***/ "./node_modules/observable-fns/dist.esm/unsubscribe.js":
/*!*************************************************************!*\
  !*** ./node_modules/observable-fns/dist.esm/unsubscribe.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Unsubscribe from a subscription returned by something that looks like an observable,\n * but is not necessarily our observable implementation.\n */\nfunction unsubscribe(subscription) {\n    if (typeof subscription === \"function\") {\n        subscription();\n    }\n    else if (subscription && typeof subscription.unsubscribe === \"function\") {\n        subscription.unsubscribe();\n    }\n}\nexports.default = unsubscribe;\n\n\n//# sourceURL=webpack:///./node_modules/observable-fns/dist.esm/unsubscribe.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction assertPath(path) {\n    if (typeof path !== 'string') {\n        throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n    }\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n    var res = '';\n    var lastSegmentLength = 0;\n    var lastSlash = -1;\n    var dots = 0;\n    var code;\n    for (var i = 0; i <= path.length; ++i) {\n        if (i < path.length)\n            code = path.charCodeAt(i);\n        else if (code === 47 /*/*/)\n            break;\n        else\n            code = 47 /*/*/;\n        if (code === 47 /*/*/) {\n            if (lastSlash === i - 1 || dots === 1) {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n                    if (res.length > 2) {\n                        var lastSlashIndex = res.lastIndexOf('/');\n                        if (lastSlashIndex !== res.length - 1) {\n                            if (lastSlashIndex === -1) {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0)\n                        res += '/..';\n                    else\n                        res = '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0)\n                    res += '/' + path.slice(lastSlash + 1, i);\n                else\n                    res = path.slice(lastSlash + 1, i);\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 /*.*/ && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    var dir = pathObject.dir || pathObject.root;\n    var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n    if (!dir) {\n        return base;\n    }\n    if (dir === pathObject.root) {\n        return dir + base;\n    }\n    return dir + sep + base;\n}\nvar posix = {\n    // path.resolve([from ...], to)\n    resolve: function resolve() {\n        var resolvedPath = '';\n        var resolvedAbsolute = false;\n        var cwd;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            var path;\n            if (i >= 0)\n                path = arguments[i];\n            else {\n                if (cwd === undefined)\n                    cwd = process.cwd();\n                path = cwd;\n            }\n            assertPath(path);\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = path + '/' + resolvedPath;\n            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n        if (resolvedAbsolute) {\n            if (resolvedPath.length > 0)\n                return '/' + resolvedPath;\n            else\n                return '/';\n        }\n        else if (resolvedPath.length > 0) {\n            return resolvedPath;\n        }\n        else {\n            return '.';\n        }\n    },\n    normalize: function normalize(path) {\n        assertPath(path);\n        if (path.length === 0)\n            return '.';\n        var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n        // Normalize the path\n        path = normalizeStringPosix(path, !isAbsolute);\n        if (path.length === 0 && !isAbsolute)\n            path = '.';\n        if (path.length > 0 && trailingSeparator)\n            path += '/';\n        if (isAbsolute)\n            return '/' + path;\n        return path;\n    },\n    isAbsolute: function isAbsolute(path) {\n        assertPath(path);\n        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n    },\n    join: function join() {\n        if (arguments.length === 0)\n            return '.';\n        var joined;\n        for (var i = 0; i < arguments.length; ++i) {\n            var arg = arguments[i];\n            assertPath(arg);\n            if (arg.length > 0) {\n                if (joined === undefined)\n                    joined = arg;\n                else\n                    joined += '/' + arg;\n            }\n        }\n        if (joined === undefined)\n            return '.';\n        return posix.normalize(joined);\n    },\n    relative: function relative(from, to) {\n        assertPath(from);\n        assertPath(to);\n        if (from === to)\n            return '';\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to)\n            return '';\n        // Trim any leading backslashes\n        var fromStart = 1;\n        for (; fromStart < from.length; ++fromStart) {\n            if (from.charCodeAt(fromStart) !== 47 /*/*/)\n                break;\n        }\n        var fromEnd = from.length;\n        var fromLen = fromEnd - fromStart;\n        // Trim any leading backslashes\n        var toStart = 1;\n        for (; toStart < to.length; ++toStart) {\n            if (to.charCodeAt(toStart) !== 47 /*/*/)\n                break;\n        }\n        var toEnd = to.length;\n        var toLen = toEnd - toStart;\n        // Compare paths to find the longest common path from root\n        var length = fromLen < toLen ? fromLen : toLen;\n        var lastCommonSep = -1;\n        var i = 0;\n        for (; i <= length; ++i) {\n            if (i === length) {\n                if (toLen > length) {\n                    if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n                        // We get here if `from` is the exact base path for `to`.\n                        // For example: from='/foo/bar'; to='/foo/bar/baz'\n                        return to.slice(toStart + i + 1);\n                    }\n                    else if (i === 0) {\n                        // We get here if `from` is the root\n                        // For example: from='/'; to='/foo'\n                        return to.slice(toStart + i);\n                    }\n                }\n                else if (fromLen > length) {\n                    if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n                        // We get here if `to` is the exact base path for `from`.\n                        // For example: from='/foo/bar/baz'; to='/foo/bar'\n                        lastCommonSep = i;\n                    }\n                    else if (i === 0) {\n                        // We get here if `to` is the root.\n                        // For example: from='/foo'; to='/'\n                        lastCommonSep = 0;\n                    }\n                }\n                break;\n            }\n            var fromCode = from.charCodeAt(fromStart + i);\n            var toCode = to.charCodeAt(toStart + i);\n            if (fromCode !== toCode)\n                break;\n            else if (fromCode === 47 /*/*/)\n                lastCommonSep = i;\n        }\n        var out = '';\n        // Generate the relative path based on the path difference between `to`\n        // and `from`\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n                if (out.length === 0)\n                    out += '..';\n                else\n                    out += '/..';\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts\n        if (out.length > 0)\n            return out + to.slice(toStart + lastCommonSep);\n        else {\n            toStart += lastCommonSep;\n            if (to.charCodeAt(toStart) === 47 /*/*/)\n                ++toStart;\n            return to.slice(toStart);\n        }\n    },\n    _makeLong: function _makeLong(path) {\n        return path;\n    },\n    dirname: function dirname(path) {\n        assertPath(path);\n        if (path.length === 0)\n            return '.';\n        var code = path.charCodeAt(0);\n        var hasRoot = code === 47 /*/*/;\n        var end = -1;\n        var matchedSlash = true;\n        for (var i = path.length - 1; i >= 1; --i) {\n            code = path.charCodeAt(i);\n            if (code === 47 /*/*/) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1)\n            return hasRoot ? '/' : '.';\n        if (hasRoot && end === 1)\n            return '//';\n        return path.slice(0, end);\n    },\n    basename: function basename(path, ext) {\n        if (ext !== undefined && typeof ext !== 'string')\n            throw new TypeError('\"ext\" argument must be a string');\n        assertPath(path);\n        var start = 0;\n        var end = -1;\n        var matchedSlash = true;\n        var i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext.length === path.length && ext === path)\n                return '';\n            var extIdx = ext.length - 1;\n            var firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                var code = path.charCodeAt(i);\n                if (code === 47 /*/*/) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end)\n                end = firstNonSlashEnd;\n            else if (end === -1)\n                end = path.length;\n            return path.slice(start, end);\n        }\n        else {\n            for (i = path.length - 1; i >= 0; --i) {\n                if (path.charCodeAt(i) === 47 /*/*/) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else if (end === -1) {\n                    // We saw the first non-path separator, mark this as the end of our\n                    // path component\n                    matchedSlash = false;\n                    end = i + 1;\n                }\n            }\n            if (end === -1)\n                return '';\n            return path.slice(start, end);\n        }\n    },\n    extname: function extname(path) {\n        assertPath(path);\n        var startDot = -1;\n        var startPart = 0;\n        var end = -1;\n        var matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        var preDotState = 0;\n        for (var i = path.length - 1; i >= 0; --i) {\n            var code = path.charCodeAt(i);\n            if (code === 47 /*/*/) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46 /*.*/) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1)\n                    startDot = i;\n                else if (preDotState !== 1)\n                    preDotState = 1;\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 || end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: function format(pathObject) {\n        if (pathObject === null || typeof pathObject !== 'object') {\n            throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n        }\n        return _format('/', pathObject);\n    },\n    parse: function parse(path) {\n        assertPath(path);\n        var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0)\n            return ret;\n        var code = path.charCodeAt(0);\n        var isAbsolute = code === 47 /*/*/;\n        var start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        var startDot = -1;\n        var startPart = 0;\n        var end = -1;\n        var matchedSlash = true;\n        var i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        var preDotState = 0;\n        // Get non-dir info\n        for (; i >= start; --i) {\n            code = path.charCodeAt(i);\n            if (code === 47 /*/*/) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46 /*.*/) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1)\n                    startDot = i;\n                else if (preDotState !== 1)\n                    preDotState = 1;\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 || end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            if (end !== -1) {\n                if (startPart === 0 && isAbsolute)\n                    ret.base = ret.name = path.slice(1, end);\n                else\n                    ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else {\n            if (startPart === 0 && isAbsolute) {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n        if (startPart > 0)\n            ret.dir = path.slice(0, startPart - 1);\n        else if (isAbsolute)\n            ret.dir = '/';\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null\n};\nposix.posix = posix;\nmodule.exports = posix;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// shim for using process in browser\nvar process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar cachedSetTimeout;\nvar cachedClearTimeout;\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        }\n        else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    }\n    catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        }\n        else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    }\n    catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n}());\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    }\n    catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        }\n        catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    }\n    catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        }\n        catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    }\n    else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\nfunction noop() { }\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\nprocess.listeners = function (name) { return []; };\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\nprocess.cwd = function () { return '/'; };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n// limit of Crypto.getRandomValues()\n// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\nvar MAX_BYTES = 65536;\n// Node supports requesting up to this number of bytes\n// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48\nvar MAX_UINT32 = 4294967295;\nfunction oldBrowser() {\n    throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11');\n}\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar crypto = global.crypto || global.msCrypto;\nif (crypto && crypto.getRandomValues) {\n    module.exports = randomBytes;\n}\nelse {\n    module.exports = oldBrowser;\n}\nfunction randomBytes(size, cb) {\n    // phantomjs needs to throw\n    if (size > MAX_UINT32)\n        throw new RangeError('requested too many random bytes');\n    var bytes = Buffer.allocUnsafe(size);\n    if (size > 0) { // getRandomValues fails on IE if size == 0\n        if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues\n            // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n            for (var generated = 0; generated < size; generated += MAX_BYTES) {\n                // buffer.slice automatically checks if the end is past the end of\n                // the buffer so we don't have to here\n                crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));\n            }\n        }\n        else {\n            crypto.getRandomValues(bytes);\n        }\n    }\n    if (typeof cb === 'function') {\n        return process.nextTick(function () {\n            cb(null, bytes);\n        });\n    }\n    return bytes;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/randombytes/browser.js?");

/***/ }),

/***/ "./node_modules/randomfill/browser.js":
/*!********************************************!*\
  !*** ./node_modules/randomfill/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\nfunction oldBrowser() {\n    throw new Error('secure random number generation not supported by this browser\\nuse chrome, FireFox or Internet Explorer 11');\n}\nvar safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\");\nvar randombytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\nvar Buffer = safeBuffer.Buffer;\nvar kBufferMaxLength = safeBuffer.kMaxLength;\nvar crypto = global.crypto || global.msCrypto;\nvar kMaxUint32 = Math.pow(2, 32) - 1;\nfunction assertOffset(offset, length) {\n    if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare\n        throw new TypeError('offset must be a number');\n    }\n    if (offset > kMaxUint32 || offset < 0) {\n        throw new TypeError('offset must be a uint32');\n    }\n    if (offset > kBufferMaxLength || offset > length) {\n        throw new RangeError('offset out of range');\n    }\n}\nfunction assertSize(size, offset, length) {\n    if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare\n        throw new TypeError('size must be a number');\n    }\n    if (size > kMaxUint32 || size < 0) {\n        throw new TypeError('size must be a uint32');\n    }\n    if (size + offset > length || size > kBufferMaxLength) {\n        throw new RangeError('buffer too small');\n    }\n}\nif ((crypto && crypto.getRandomValues) || !process.browser) {\n    exports.randomFill = randomFill;\n    exports.randomFillSync = randomFillSync;\n}\nelse {\n    exports.randomFill = oldBrowser;\n    exports.randomFillSync = oldBrowser;\n}\nfunction randomFill(buf, offset, size, cb) {\n    if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {\n        throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array');\n    }\n    if (typeof offset === 'function') {\n        cb = offset;\n        offset = 0;\n        size = buf.length;\n    }\n    else if (typeof size === 'function') {\n        cb = size;\n        size = buf.length - offset;\n    }\n    else if (typeof cb !== 'function') {\n        throw new TypeError('\"cb\" argument must be a function');\n    }\n    assertOffset(offset, buf.length);\n    assertSize(size, offset, buf.length);\n    return actualFill(buf, offset, size, cb);\n}\nfunction actualFill(buf, offset, size, cb) {\n    if (process.browser) {\n        var ourBuf = buf.buffer;\n        var uint = new Uint8Array(ourBuf, offset, size);\n        crypto.getRandomValues(uint);\n        if (cb) {\n            process.nextTick(function () {\n                cb(null, buf);\n            });\n            return;\n        }\n        return buf;\n    }\n    if (cb) {\n        randombytes(size, function (err, bytes) {\n            if (err) {\n                return cb(err);\n            }\n            bytes.copy(buf, offset);\n            cb(null, buf);\n        });\n        return;\n    }\n    var bytes = randombytes(size);\n    bytes.copy(buf, offset);\n    return buf;\n}\nfunction randomFillSync(buf, offset, size) {\n    if (typeof offset === 'undefined') {\n        offset = 0;\n    }\n    if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {\n        throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array');\n    }\n    assertOffset(offset, buf.length);\n    if (size === undefined)\n        size = buf.length - offset;\n    assertSize(size, offset, buf.length);\n    return actualFill(buf, offset, size);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/randomfill/browser.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\");\nvar Buffer = buffer.Buffer;\n// alternative to using Object.keys for old browsers\nfunction copyProps(src, dst) {\n    for (var key in src) {\n        dst[key] = src[key];\n    }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n    module.exports = buffer;\n}\nelse {\n    // Copy properties from require('buffer')\n    copyProps(buffer, exports);\n    exports.Buffer = SafeBuffer;\n}\nfunction SafeBuffer(arg, encodingOrOffset, length) {\n    return Buffer(arg, encodingOrOffset, length);\n}\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer);\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n    if (typeof arg === 'number') {\n        throw new TypeError('Argument must not be a number');\n    }\n    return Buffer(arg, encodingOrOffset, length);\n};\nSafeBuffer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n        throw new TypeError('Argument must be a number');\n    }\n    var buf = Buffer(size);\n    if (fill !== undefined) {\n        if (typeof encoding === 'string') {\n            buf.fill(fill, encoding);\n        }\n        else {\n            buf.fill(fill);\n        }\n    }\n    else {\n        buf.fill(0);\n    }\n    return buf;\n};\nSafeBuffer.allocUnsafe = function (size) {\n    if (typeof size !== 'number') {\n        throw new TypeError('Argument must be a number');\n    }\n    return Buffer(size);\n};\nSafeBuffer.allocUnsafeSlow = function (size) {\n    if (typeof size !== 'number') {\n        throw new TypeError('Argument must be a number');\n    }\n    return buffer.SlowBuffer(size);\n};\n\n\n//# sourceURL=webpack:///./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n(function (global, undefined) {\n    \"use strict\";\n    if (global.setImmediate) {\n        return;\n    }\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n    function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== \"function\") {\n            callback = new Function(\"\" + callback);\n        }\n        // Copy function arguments\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n        }\n        // Store and register the task\n        var task = { callback: callback, args: args };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n    }\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n            case 0:\n                callback();\n                break;\n            case 1:\n                callback(args[0]);\n                break;\n            case 2:\n                callback(args[0], args[1]);\n                break;\n            case 3:\n                callback(args[0], args[1], args[2]);\n                break;\n            default:\n                callback.apply(undefined, args);\n                break;\n        }\n    }\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        }\n        else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                }\n                finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n    function installNextTickImplementation() {\n        registerImmediate = function (handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function (event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        }\n        else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n        registerImmediate = function (handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n        registerImmediate = function (handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function (handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n    function installSetTimeoutImplementation() {\n        registerImmediate = function (handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    }\n    else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    }\n    else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    }\n    else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n    }\n    else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/common.js":
/*!*************************************************!*\
  !*** ./node_modules/threads/dist-esm/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serialize = exports.deserialize = exports.registerSerializer = void 0;\nvar serializers_1 = __webpack_require__(/*! ./serializers */ \"./node_modules/threads/dist-esm/serializers.js\");\nvar registeredSerializer = serializers_1.DefaultSerializer;\nfunction registerSerializer(serializer) {\n    registeredSerializer = (0, serializers_1.extendSerializer)(registeredSerializer, serializer);\n}\nexports.registerSerializer = registerSerializer;\nfunction deserialize(message) {\n    return registeredSerializer.deserialize(message);\n}\nexports.deserialize = deserialize;\nfunction serialize(input) {\n    return registeredSerializer.serialize(input);\n}\nexports.serialize = serialize;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/common.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/threads/dist-esm/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transfer = exports.DefaultSerializer = exports.expose = exports.registerSerializer = void 0;\nvar common_1 = __webpack_require__(/*! ./common */ \"./node_modules/threads/dist-esm/common.js\");\nObject.defineProperty(exports, \"registerSerializer\", { enumerable: true, get: function () { return common_1.registerSerializer; } });\n__exportStar(__webpack_require__(/*! ./master/index */ \"./node_modules/threads/dist-esm/master/index.js\"), exports);\nvar index_1 = __webpack_require__(/*! ./worker/index */ \"./node_modules/threads/dist-esm/worker/index.js\");\nObject.defineProperty(exports, \"expose\", { enumerable: true, get: function () { return index_1.expose; } });\nvar serializers_1 = __webpack_require__(/*! ./serializers */ \"./node_modules/threads/dist-esm/serializers.js\");\nObject.defineProperty(exports, \"DefaultSerializer\", { enumerable: true, get: function () { return serializers_1.DefaultSerializer; } });\nvar transferable_1 = __webpack_require__(/*! ./transferable */ \"./node_modules/threads/dist-esm/transferable.js\");\nObject.defineProperty(exports, \"Transfer\", { enumerable: true, get: function () { return transferable_1.Transfer; } });\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/index.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/master/get-bundle-url.browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/threads/dist-esm/master/get-bundle-url.browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBundleURL = exports.getBaseURL = void 0;\n// Source: <https://github.com/parcel-bundler/parcel/blob/master/packages/core/parcel-bundler/src/builtins/bundle-url.js>\nvar bundleURL;\nfunction getBundleURLCached() {\n    if (!bundleURL) {\n        bundleURL = getBundleURL();\n    }\n    return bundleURL;\n}\nexports.getBundleURL = getBundleURLCached;\nfunction getBundleURL() {\n    // Attempt to find the URL of the current script and use that as the base URL\n    try {\n        throw new Error;\n    }\n    catch (err) {\n        var matches = (\"\" + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n        if (matches) {\n            return getBaseURL(matches[0]);\n        }\n    }\n    return \"/\";\n}\nfunction getBaseURL(url) {\n    return (\"\" + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)?\\/[^/]+(?:\\?.*)?$/, '$1') + '/';\n}\nexports.getBaseURL = getBaseURL;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/master/get-bundle-url.browser.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/master/implementation.browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/threads/dist-esm/master/implementation.browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isWorkerRuntime = exports.getWorkerImplementation = exports.defaultPoolSize = void 0;\n// tslint:disable max-classes-per-file\nvar get_bundle_url_browser_1 = __webpack_require__(/*! ./get-bundle-url.browser */ \"./node_modules/threads/dist-esm/master/get-bundle-url.browser.js\");\nexports.defaultPoolSize = typeof navigator !== \"undefined\" && navigator.hardwareConcurrency\n    ? navigator.hardwareConcurrency\n    : 4;\nvar isAbsoluteURL = function (value) { return /^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(value); };\nfunction createSourceBlobURL(code) {\n    var blob = new Blob([code], { type: \"application/javascript\" });\n    return URL.createObjectURL(blob);\n}\nfunction selectWorkerImplementation() {\n    if (typeof Worker === \"undefined\") {\n        // Might happen on Safari, for instance\n        // The idea is to only fail if the constructor is actually used\n        return /** @class */ (function () {\n            function NoWebWorker() {\n                throw Error(\"No web worker implementation available. You might have tried to spawn a worker within a worker in a browser that doesn't support workers in workers.\");\n            }\n            return NoWebWorker;\n        }());\n    }\n    var WebWorker = /** @class */ (function (_super) {\n        __extends(WebWorker, _super);\n        function WebWorker(url, options) {\n            var _this = this;\n            var _a, _b;\n            if (typeof url === \"string\" && options && options._baseURL) {\n                url = new URL(url, options._baseURL);\n            }\n            else if (typeof url === \"string\" && !isAbsoluteURL(url) && (0, get_bundle_url_browser_1.getBundleURL)().match(/^file:\\/\\//i)) {\n                url = new URL(url, (0, get_bundle_url_browser_1.getBundleURL)().replace(/\\/[^\\/]+$/, \"/\"));\n                if ((_a = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _a !== void 0 ? _a : true) {\n                    url = createSourceBlobURL(\"importScripts(\".concat(JSON.stringify(url), \");\"));\n                }\n            }\n            if (typeof url === \"string\" && isAbsoluteURL(url)) {\n                // Create source code blob loading JS file via `importScripts()`\n                // to circumvent worker CORS restrictions\n                if ((_b = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _b !== void 0 ? _b : true) {\n                    url = createSourceBlobURL(\"importScripts(\".concat(JSON.stringify(url), \");\"));\n                }\n            }\n            _this = _super.call(this, url, options) || this;\n            return _this;\n        }\n        return WebWorker;\n    }(Worker));\n    var BlobWorker = /** @class */ (function (_super) {\n        __extends(BlobWorker, _super);\n        function BlobWorker(blob, options) {\n            var _this = this;\n            var url = window.URL.createObjectURL(blob);\n            _this = _super.call(this, url, options) || this;\n            return _this;\n        }\n        BlobWorker.fromText = function (source, options) {\n            var blob = new window.Blob([source], { type: \"text/javascript\" });\n            return new BlobWorker(blob, options);\n        };\n        return BlobWorker;\n    }(WebWorker));\n    return {\n        blob: BlobWorker,\n        default: WebWorker\n    };\n}\nvar implementation;\nfunction getWorkerImplementation() {\n    if (!implementation) {\n        implementation = selectWorkerImplementation();\n    }\n    return implementation;\n}\nexports.getWorkerImplementation = getWorkerImplementation;\nfunction isWorkerRuntime() {\n    var isWindowContext = typeof self !== \"undefined\" && typeof Window !== \"undefined\" && self instanceof Window;\n    return typeof self !== \"undefined\" && self.postMessage && !isWindowContext ? true : false;\n}\nexports.isWorkerRuntime = isWorkerRuntime;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/master/implementation.browser.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/master/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/threads/dist-esm/master/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Worker = exports.BlobWorker = exports.isWorkerRuntime = exports.Thread = exports.spawn = exports.Pool = void 0;\nvar implementation_1 = __webpack_require__(/*! ./implementation */ \"./node_modules/threads/dist-esm/master/implementation.browser.js\");\nObject.defineProperty(exports, \"isWorkerRuntime\", { enumerable: true, get: function () { return implementation_1.isWorkerRuntime; } });\nvar pool_1 = __webpack_require__(/*! ./pool */ \"./node_modules/threads/dist-esm/master/pool.js\");\nObject.defineProperty(exports, \"Pool\", { enumerable: true, get: function () { return pool_1.Pool; } });\nvar spawn_1 = __webpack_require__(/*! ./spawn */ \"./node_modules/threads/dist-esm/master/spawn.js\");\nObject.defineProperty(exports, \"spawn\", { enumerable: true, get: function () { return spawn_1.spawn; } });\nvar thread_1 = __webpack_require__(/*! ./thread */ \"./node_modules/threads/dist-esm/master/thread.js\");\nObject.defineProperty(exports, \"Thread\", { enumerable: true, get: function () { return thread_1.Thread; } });\n/** Separate class to spawn workers from source code blobs or strings. */\nexports.BlobWorker = (0, implementation_1.getWorkerImplementation)().blob;\n/** Worker implementation. Either web worker or a node.js Worker class. */\nexports.Worker = (0, implementation_1.getWorkerImplementation)().default;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/master/index.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/master/invocation-proxy.js":
/*!******************************************************************!*\
  !*** ./node_modules/threads/dist-esm/master/invocation-proxy.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProxyModule = exports.createProxyFunction = void 0;\n/*\n * This source file contains the code for proxying calls in the master thread to calls in the workers\n * by `.postMessage()`-ing.\n *\n * Keep in mind that this code can make or break the program's performance! Need to optimize more\n */\nvar debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"));\nvar observable_fns_1 = __webpack_require__(/*! observable-fns */ \"./node_modules/observable-fns/dist.esm/index.js\");\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/threads/dist-esm/common.js\");\nvar observable_promise_1 = __webpack_require__(/*! ../observable-promise */ \"./node_modules/threads/dist-esm/observable-promise.js\");\nvar transferable_1 = __webpack_require__(/*! ../transferable */ \"./node_modules/threads/dist-esm/transferable.js\");\nvar messages_1 = __webpack_require__(/*! ../types/messages */ \"./node_modules/threads/dist-esm/types/messages.js\");\nvar debugMessages = (0, debug_1.default)(\"threads:master:messages\");\nvar nextJobUID = 1;\nvar dedupe = function (array) { return Array.from(new Set(array)); };\nvar isJobErrorMessage = function (data) { return data && data.type === messages_1.WorkerMessageType.error; };\nvar isJobResultMessage = function (data) { return data && data.type === messages_1.WorkerMessageType.result; };\nvar isJobStartMessage = function (data) { return data && data.type === messages_1.WorkerMessageType.running; };\nfunction createObservableForJob(worker, jobUID) {\n    return new observable_fns_1.Observable(function (observer) {\n        var asyncType;\n        var messageHandler = (function (event) {\n            debugMessages(\"Message from worker:\", event.data);\n            if (!event.data || event.data.uid !== jobUID)\n                return;\n            if (isJobStartMessage(event.data)) {\n                asyncType = event.data.resultType;\n            }\n            else if (isJobResultMessage(event.data)) {\n                if (asyncType === \"promise\") {\n                    if (typeof event.data.payload !== \"undefined\") {\n                        observer.next((0, common_1.deserialize)(event.data.payload));\n                    }\n                    observer.complete();\n                    worker.removeEventListener(\"message\", messageHandler);\n                }\n                else {\n                    if (event.data.payload) {\n                        observer.next((0, common_1.deserialize)(event.data.payload));\n                    }\n                    if (event.data.complete) {\n                        observer.complete();\n                        worker.removeEventListener(\"message\", messageHandler);\n                    }\n                }\n            }\n            else if (isJobErrorMessage(event.data)) {\n                var error = (0, common_1.deserialize)(event.data.error);\n                if (asyncType === \"promise\" || !asyncType) {\n                    observer.error(error);\n                }\n                else {\n                    observer.error(error);\n                }\n                worker.removeEventListener(\"message\", messageHandler);\n            }\n        });\n        worker.addEventListener(\"message\", messageHandler);\n        return function () {\n            if (asyncType === \"observable\" || !asyncType) {\n                var cancelMessage = {\n                    type: messages_1.MasterMessageType.cancel,\n                    uid: jobUID\n                };\n                worker.postMessage(cancelMessage);\n            }\n            worker.removeEventListener(\"message\", messageHandler);\n        };\n    });\n}\nfunction prepareArguments(rawArgs) {\n    if (rawArgs.length === 0) {\n        // Exit early if possible\n        return {\n            args: [],\n            transferables: []\n        };\n    }\n    var args = [];\n    var transferables = [];\n    for (var _i = 0, rawArgs_1 = rawArgs; _i < rawArgs_1.length; _i++) {\n        var arg = rawArgs_1[_i];\n        if ((0, transferable_1.isTransferDescriptor)(arg)) {\n            args.push((0, common_1.serialize)(arg.send));\n            transferables.push.apply(transferables, arg.transferables);\n        }\n        else {\n            args.push((0, common_1.serialize)(arg));\n        }\n    }\n    return {\n        args: args,\n        transferables: transferables.length === 0 ? transferables : dedupe(transferables)\n    };\n}\nfunction createProxyFunction(worker, method) {\n    return (function () {\n        var rawArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            rawArgs[_i] = arguments[_i];\n        }\n        var uid = nextJobUID++;\n        var _a = prepareArguments(rawArgs), args = _a.args, transferables = _a.transferables;\n        var runMessage = {\n            type: messages_1.MasterMessageType.run,\n            uid: uid,\n            method: method,\n            args: args\n        };\n        debugMessages(\"Sending command to run function to worker:\", runMessage);\n        try {\n            worker.postMessage(runMessage, transferables);\n        }\n        catch (error) {\n            return observable_promise_1.ObservablePromise.from(Promise.reject(error));\n        }\n        return observable_promise_1.ObservablePromise.from((0, observable_fns_1.multicast)(createObservableForJob(worker, uid)));\n    });\n}\nexports.createProxyFunction = createProxyFunction;\nfunction createProxyModule(worker, methodNames) {\n    var proxy = {};\n    for (var _i = 0, methodNames_1 = methodNames; _i < methodNames_1.length; _i++) {\n        var methodName = methodNames_1[_i];\n        proxy[methodName] = createProxyFunction(worker, methodName);\n    }\n    return proxy;\n}\nexports.createProxyModule = createProxyModule;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/master/invocation-proxy.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/master/pool-types.js":
/*!************************************************************!*\
  !*** ./node_modules/threads/dist-esm/master/pool-types.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PoolEventType = void 0;\n(function (PoolEventType) {\n    PoolEventType[\"initialized\"] = \"initialized\";\n    PoolEventType[\"taskCanceled\"] = \"taskCanceled\";\n    PoolEventType[\"taskCompleted\"] = \"taskCompleted\";\n    PoolEventType[\"taskFailed\"] = \"taskFailed\";\n    PoolEventType[\"taskQueued\"] = \"taskQueued\";\n    PoolEventType[\"taskQueueDrained\"] = \"taskQueueDrained\";\n    PoolEventType[\"taskStart\"] = \"taskStart\";\n    PoolEventType[\"terminated\"] = \"terminated\";\n})(exports.PoolEventType || (exports.PoolEventType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/master/pool-types.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/master/pool.js":
/*!******************************************************!*\
  !*** ./node_modules/threads/dist-esm/master/pool.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pool = exports.Thread = exports.PoolEventType = void 0;\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"));\nvar observable_fns_1 = __webpack_require__(/*! observable-fns */ \"./node_modules/observable-fns/dist.esm/index.js\");\nvar ponyfills_1 = __webpack_require__(/*! ../ponyfills */ \"./node_modules/threads/dist-esm/ponyfills.js\");\nvar implementation_1 = __webpack_require__(/*! ./implementation */ \"./node_modules/threads/dist-esm/master/implementation.browser.js\");\nvar pool_types_1 = __webpack_require__(/*! ./pool-types */ \"./node_modules/threads/dist-esm/master/pool-types.js\");\nObject.defineProperty(exports, \"PoolEventType\", { enumerable: true, get: function () { return pool_types_1.PoolEventType; } });\nvar thread_1 = __webpack_require__(/*! ./thread */ \"./node_modules/threads/dist-esm/master/thread.js\");\nObject.defineProperty(exports, \"Thread\", { enumerable: true, get: function () { return thread_1.Thread; } });\nvar nextPoolID = 1;\nfunction createArray(size) {\n    var array = [];\n    for (var index = 0; index < size; index++) {\n        array.push(index);\n    }\n    return array;\n}\nfunction delay(ms) {\n    return new Promise(function (resolve) { return setTimeout(resolve, ms); });\n}\nfunction flatMap(array, mapper) {\n    return array.reduce(function (flattened, element) { return __spreadArray(__spreadArray([], flattened, true), mapper(element), true); }, []);\n}\nfunction slugify(text) {\n    return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spawnWorkers(spawnWorker, count) {\n    return createArray(count).map(function () { return ({\n        init: spawnWorker(),\n        runningTasks: []\n    }); });\n}\nvar WorkerPool = /** @class */ (function () {\n    function WorkerPool(spawnWorker, optionsOrSize) {\n        var _this = this;\n        this.eventSubject = new observable_fns_1.Subject();\n        this.initErrors = [];\n        this.isClosing = false;\n        this.nextTaskID = 1;\n        this.taskQueue = [];\n        var options = typeof optionsOrSize === \"number\"\n            ? { size: optionsOrSize }\n            : optionsOrSize || {};\n        var _a = options.size, size = _a === void 0 ? implementation_1.defaultPoolSize : _a;\n        this.debug = (0, debug_1.default)(\"threads:pool:\".concat(slugify(options.name || String(nextPoolID++))));\n        this.options = options;\n        this.workers = spawnWorkers(spawnWorker, size);\n        this.eventObservable = (0, observable_fns_1.multicast)(observable_fns_1.Observable.from(this.eventSubject));\n        Promise.all(this.workers.map(function (worker) { return worker.init; })).then(function () { return _this.eventSubject.next({\n            type: pool_types_1.PoolEventType.initialized,\n            size: _this.workers.length\n        }); }, function (error) {\n            _this.debug(\"Error while initializing pool worker:\", error);\n            _this.eventSubject.error(error);\n            _this.initErrors.push(error);\n        });\n    }\n    WorkerPool.prototype.findIdlingWorker = function () {\n        var _a = this.options.concurrency, concurrency = _a === void 0 ? 1 : _a;\n        return this.workers.find(function (worker) { return worker.runningTasks.length < concurrency; });\n    };\n    WorkerPool.prototype.runPoolTask = function (worker, task) {\n        return __awaiter(this, void 0, void 0, function () {\n            var workerID, returnValue, _a, _b, error_1;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        workerID = this.workers.indexOf(worker) + 1;\n                        this.debug(\"Running task #\".concat(task.id, \" on worker #\").concat(workerID, \"...\"));\n                        this.eventSubject.next({\n                            type: pool_types_1.PoolEventType.taskStart,\n                            taskID: task.id,\n                            workerID: workerID\n                        });\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 4, , 5]);\n                        _b = (_a = task).run;\n                        return [4 /*yield*/, worker.init];\n                    case 2: return [4 /*yield*/, _b.apply(_a, [_c.sent()])];\n                    case 3:\n                        returnValue = _c.sent();\n                        this.debug(\"Task #\".concat(task.id, \" completed successfully\"));\n                        this.eventSubject.next({\n                            type: pool_types_1.PoolEventType.taskCompleted,\n                            returnValue: returnValue,\n                            taskID: task.id,\n                            workerID: workerID\n                        });\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_1 = _c.sent();\n                        this.debug(\"Task #\".concat(task.id, \" failed\"));\n                        this.eventSubject.next({\n                            type: pool_types_1.PoolEventType.taskFailed,\n                            taskID: task.id,\n                            error: error_1,\n                            workerID: workerID\n                        });\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    WorkerPool.prototype.run = function (worker, task) {\n        return __awaiter(this, void 0, void 0, function () {\n            var runPromise;\n            var _this = this;\n            return __generator(this, function (_a) {\n                runPromise = (function () { return __awaiter(_this, void 0, void 0, function () {\n                    var removeTaskFromWorkersRunningTasks;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                removeTaskFromWorkersRunningTasks = function () {\n                                    worker.runningTasks = worker.runningTasks.filter(function (someRunPromise) { return someRunPromise !== runPromise; });\n                                };\n                                // Defer task execution by one tick to give handlers time to subscribe\n                                return [4 /*yield*/, delay(0)];\n                            case 1:\n                                // Defer task execution by one tick to give handlers time to subscribe\n                                _a.sent();\n                                _a.label = 2;\n                            case 2:\n                                _a.trys.push([2, , 4, 5]);\n                                return [4 /*yield*/, this.runPoolTask(worker, task)];\n                            case 3:\n                                _a.sent();\n                                return [3 /*break*/, 5];\n                            case 4:\n                                removeTaskFromWorkersRunningTasks();\n                                if (!this.isClosing) {\n                                    this.scheduleWork();\n                                }\n                                return [7 /*endfinally*/];\n                            case 5: return [2 /*return*/];\n                        }\n                    });\n                }); })();\n                worker.runningTasks.push(runPromise);\n                return [2 /*return*/];\n            });\n        });\n    };\n    WorkerPool.prototype.scheduleWork = function () {\n        this.debug(\"Attempt de-queueing a task in order to run it...\");\n        var availableWorker = this.findIdlingWorker();\n        if (!availableWorker)\n            return;\n        var nextTask = this.taskQueue.shift();\n        if (!nextTask) {\n            this.debug(\"Task queue is empty\");\n            this.eventSubject.next({ type: pool_types_1.PoolEventType.taskQueueDrained });\n            return;\n        }\n        this.run(availableWorker, nextTask);\n    };\n    WorkerPool.prototype.taskCompletion = function (taskID) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var eventSubscription = _this.events().subscribe(function (event) {\n                if (event.type === pool_types_1.PoolEventType.taskCompleted && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    resolve(event.returnValue);\n                }\n                else if (event.type === pool_types_1.PoolEventType.taskFailed && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    reject(event.error);\n                }\n                else if (event.type === pool_types_1.PoolEventType.terminated) {\n                    eventSubscription.unsubscribe();\n                    reject(Error(\"Pool has been terminated before task was run.\"));\n                }\n            });\n        });\n    };\n    WorkerPool.prototype.settled = function (allowResolvingImmediately) {\n        if (allowResolvingImmediately === void 0) { allowResolvingImmediately = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var getCurrentlyRunningTasks, taskFailures, failureSubscription;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        getCurrentlyRunningTasks = function () { return flatMap(_this.workers, function (worker) { return worker.runningTasks; }); };\n                        taskFailures = [];\n                        failureSubscription = this.eventObservable.subscribe(function (event) {\n                            if (event.type === pool_types_1.PoolEventType.taskFailed) {\n                                taskFailures.push(event.error);\n                            }\n                        });\n                        if (this.initErrors.length > 0) {\n                            return [2 /*return*/, Promise.reject(this.initErrors[0])];\n                        }\n                        if (!(allowResolvingImmediately && this.taskQueue.length === 0)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, (0, ponyfills_1.allSettled)(getCurrentlyRunningTasks())];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, taskFailures];\n                    case 2: return [4 /*yield*/, new Promise(function (resolve, reject) {\n                            var subscription = _this.eventObservable.subscribe({\n                                next: function (event) {\n                                    if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n                                        subscription.unsubscribe();\n                                        resolve(void 0);\n                                    }\n                                },\n                                error: reject // make a pool-wide error reject the completed() result promise\n                            });\n                        })];\n                    case 3:\n                        _a.sent();\n                        return [4 /*yield*/, (0, ponyfills_1.allSettled)(getCurrentlyRunningTasks())];\n                    case 4:\n                        _a.sent();\n                        failureSubscription.unsubscribe();\n                        return [2 /*return*/, taskFailures];\n                }\n            });\n        });\n    };\n    WorkerPool.prototype.completed = function (allowResolvingImmediately) {\n        if (allowResolvingImmediately === void 0) { allowResolvingImmediately = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var settlementPromise, earlyExitPromise, errors;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        settlementPromise = this.settled(allowResolvingImmediately);\n                        earlyExitPromise = new Promise(function (resolve, reject) {\n                            var subscription = _this.eventObservable.subscribe({\n                                next: function (event) {\n                                    if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n                                        subscription.unsubscribe();\n                                        resolve(settlementPromise);\n                                    }\n                                    else if (event.type === pool_types_1.PoolEventType.taskFailed) {\n                                        subscription.unsubscribe();\n                                        reject(event.error);\n                                    }\n                                },\n                                error: reject // make a pool-wide error reject the completed() result promise\n                            });\n                        });\n                        return [4 /*yield*/, Promise.race([\n                                settlementPromise,\n                                earlyExitPromise\n                            ])];\n                    case 1:\n                        errors = _a.sent();\n                        if (errors.length > 0) {\n                            throw errors[0];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    WorkerPool.prototype.events = function () {\n        return this.eventObservable;\n    };\n    WorkerPool.prototype.queue = function (taskFunction) {\n        var _this = this;\n        var _a = this.options.maxQueuedJobs, maxQueuedJobs = _a === void 0 ? Infinity : _a;\n        if (this.isClosing) {\n            throw Error(\"Cannot schedule pool tasks after terminate() has been called.\");\n        }\n        if (this.initErrors.length > 0) {\n            throw this.initErrors[0];\n        }\n        var taskID = this.nextTaskID++;\n        var taskCompletion = this.taskCompletion(taskID);\n        taskCompletion.catch(function (error) {\n            // Prevent unhandled rejections here as we assume the user will use\n            // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n            _this.debug(\"Task #\".concat(taskID, \" errored:\"), error);\n        });\n        var task = {\n            id: taskID,\n            run: taskFunction,\n            cancel: function () {\n                if (_this.taskQueue.indexOf(task) === -1)\n                    return;\n                _this.taskQueue = _this.taskQueue.filter(function (someTask) { return someTask !== task; });\n                _this.eventSubject.next({\n                    type: pool_types_1.PoolEventType.taskCanceled,\n                    taskID: task.id\n                });\n            },\n            then: taskCompletion.then.bind(taskCompletion)\n        };\n        if (this.taskQueue.length >= maxQueuedJobs) {\n            throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" +\n                \"This usually happens for one of two reasons: We are either at peak \" +\n                \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n        }\n        this.debug(\"Queueing task #\".concat(task.id, \"...\"));\n        this.taskQueue.push(task);\n        this.eventSubject.next({\n            type: pool_types_1.PoolEventType.taskQueued,\n            taskID: task.id\n        });\n        this.scheduleWork();\n        return task;\n    };\n    WorkerPool.prototype.terminate = function (force) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.isClosing = true;\n                        if (!!force) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.completed(true)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        this.eventSubject.next({\n                            type: pool_types_1.PoolEventType.terminated,\n                            remainingQueue: __spreadArray([], this.taskQueue, true)\n                        });\n                        this.eventSubject.complete();\n                        return [4 /*yield*/, Promise.all(this.workers.map(function (worker) { return __awaiter(_this, void 0, void 0, function () { var _a, _b; return __generator(this, function (_c) {\n                                switch (_c.label) {\n                                    case 0:\n                                        _b = (_a = thread_1.Thread).terminate;\n                                        return [4 /*yield*/, worker.init];\n                                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n                                }\n                            }); }); }))];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return WorkerPool;\n}());\nWorkerPool.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n    // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n    // If the Pool is a class or not is an implementation detail that should not concern the user.\n    return new WorkerPool(spawnWorker, optionsOrSize);\n}\nPoolConstructor.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nexports.Pool = PoolConstructor;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/master/pool.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/master/spawn.js":
/*!*******************************************************!*\
  !*** ./node_modules/threads/dist-esm/master/spawn.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.spawn = void 0;\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"));\nvar observable_fns_1 = __webpack_require__(/*! observable-fns */ \"./node_modules/observable-fns/dist.esm/index.js\");\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/threads/dist-esm/common.js\");\nvar promise_1 = __webpack_require__(/*! ../promise */ \"./node_modules/threads/dist-esm/promise.js\");\nvar symbols_1 = __webpack_require__(/*! ../symbols */ \"./node_modules/threads/dist-esm/symbols.js\");\nvar master_1 = __webpack_require__(/*! ../types/master */ \"./node_modules/threads/dist-esm/types/master.js\");\nvar invocation_proxy_1 = __webpack_require__(/*! ./invocation-proxy */ \"./node_modules/threads/dist-esm/master/invocation-proxy.js\");\nvar debugMessages = (0, debug_1.default)(\"threads:master:messages\");\nvar debugSpawn = (0, debug_1.default)(\"threads:master:spawn\");\nvar debugThreadUtils = (0, debug_1.default)(\"threads:master:thread-utils\");\nvar isInitMessage = function (data) { return data && data.type === \"init\"; };\nvar isUncaughtErrorMessage = function (data) { return data && data.type === \"uncaughtError\"; };\nvar initMessageTimeout = typeof process !== \"undefined\" && process.env.THREADS_WORKER_INIT_TIMEOUT\n    ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10)\n    : 10000;\nfunction withTimeout(promise, timeoutInMs, errorMessage) {\n    return __awaiter(this, void 0, void 0, function () {\n        var timeoutHandle, timeout, result;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    timeout = new Promise(function (resolve, reject) {\n                        timeoutHandle = setTimeout(function () { return reject(Error(errorMessage)); }, timeoutInMs);\n                    });\n                    return [4 /*yield*/, Promise.race([\n                            promise,\n                            timeout\n                        ])];\n                case 1:\n                    result = _a.sent();\n                    clearTimeout(timeoutHandle);\n                    return [2 /*return*/, result];\n            }\n        });\n    });\n}\nfunction receiveInitMessage(worker) {\n    return new Promise(function (resolve, reject) {\n        var messageHandler = (function (event) {\n            debugMessages(\"Message from worker before finishing initialization:\", event.data);\n            if (isInitMessage(event.data)) {\n                worker.removeEventListener(\"message\", messageHandler);\n                resolve(event.data);\n            }\n            else if (isUncaughtErrorMessage(event.data)) {\n                worker.removeEventListener(\"message\", messageHandler);\n                reject((0, common_1.deserialize)(event.data.error));\n            }\n        });\n        worker.addEventListener(\"message\", messageHandler);\n    });\n}\nfunction createEventObservable(worker, workerTermination) {\n    return new observable_fns_1.Observable(function (observer) {\n        var messageHandler = (function (messageEvent) {\n            var workerEvent = {\n                type: master_1.WorkerEventType.message,\n                data: messageEvent.data\n            };\n            observer.next(workerEvent);\n        });\n        var rejectionHandler = (function (errorEvent) {\n            debugThreadUtils(\"Unhandled promise rejection event in thread:\", errorEvent);\n            var workerEvent = {\n                type: master_1.WorkerEventType.internalError,\n                error: Error(errorEvent.reason)\n            };\n            observer.next(workerEvent);\n        });\n        worker.addEventListener(\"message\", messageHandler);\n        worker.addEventListener(\"unhandledrejection\", rejectionHandler);\n        workerTermination.then(function () {\n            var terminationEvent = {\n                type: master_1.WorkerEventType.termination\n            };\n            worker.removeEventListener(\"message\", messageHandler);\n            worker.removeEventListener(\"unhandledrejection\", rejectionHandler);\n            observer.next(terminationEvent);\n            observer.complete();\n        });\n    });\n}\nfunction createTerminator(worker) {\n    var _this = this;\n    var _a = (0, promise_1.createPromiseWithResolver)(), termination = _a[0], resolver = _a[1];\n    var terminate = function () { return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    debugThreadUtils(\"Terminating worker\");\n                    // Newer versions of worker_threads workers return a promise\n                    return [4 /*yield*/, worker.terminate()];\n                case 1:\n                    // Newer versions of worker_threads workers return a promise\n                    _a.sent();\n                    resolver();\n                    return [2 /*return*/];\n            }\n        });\n    }); };\n    return { terminate: terminate, termination: termination };\n}\nfunction setPrivateThreadProps(raw, worker, workerEvents, terminate) {\n    var _a;\n    var workerErrors = workerEvents\n        .filter(function (event) { return event.type === master_1.WorkerEventType.internalError; })\n        .map(function (errorEvent) { return errorEvent.error; });\n    // tslint:disable-next-line prefer-object-spread\n    return Object.assign(raw, (_a = {},\n        _a[symbols_1.$errors] = workerErrors,\n        _a[symbols_1.$events] = workerEvents,\n        _a[symbols_1.$terminate] = terminate,\n        _a[symbols_1.$worker] = worker,\n        _a));\n}\n/**\n * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin\n * abstraction layer to provide the transparent API and verifies that\n * the worker has initialized successfully.\n *\n * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.\n * @param [options]\n * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.\n */\nfunction spawn(worker, options) {\n    return __awaiter(this, void 0, void 0, function () {\n        var timeout, initMessage, exposed, _a, termination, terminate, events, proxy, proxy, type;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    debugSpawn(\"Initializing new thread\");\n                    timeout = options && options.timeout ? options.timeout : initMessageTimeout;\n                    return [4 /*yield*/, withTimeout(receiveInitMessage(worker), timeout, \"Timeout: Did not receive an init message from worker after \".concat(timeout, \"ms. Make sure the worker calls expose().\"))];\n                case 1:\n                    initMessage = _b.sent();\n                    exposed = initMessage.exposed;\n                    _a = createTerminator(worker), termination = _a.termination, terminate = _a.terminate;\n                    events = createEventObservable(worker, termination);\n                    if (exposed.type === \"function\") {\n                        proxy = (0, invocation_proxy_1.createProxyFunction)(worker);\n                        return [2 /*return*/, setPrivateThreadProps(proxy, worker, events, terminate)];\n                    }\n                    else if (exposed.type === \"module\") {\n                        proxy = (0, invocation_proxy_1.createProxyModule)(worker, exposed.methods);\n                        return [2 /*return*/, setPrivateThreadProps(proxy, worker, events, terminate)];\n                    }\n                    else {\n                        type = exposed.type;\n                        throw Error(\"Worker init message states unexpected type of expose(): \".concat(type));\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.spawn = spawn;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/master/spawn.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/master/thread.js":
/*!********************************************************!*\
  !*** ./node_modules/threads/dist-esm/master/thread.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Thread = void 0;\nvar symbols_1 = __webpack_require__(/*! ../symbols */ \"./node_modules/threads/dist-esm/symbols.js\");\nfunction fail(message) {\n    throw Error(message);\n}\n/** Thread utility functions. Use them to manage or inspect a `spawn()`-ed thread. */\nexports.Thread = {\n    /** Return an observable that can be used to subscribe to all errors happening in the thread. */\n    errors: function (thread) {\n        return thread[symbols_1.$errors] || fail(\"Error observable not found. Make sure to pass a thread instance as returned by the spawn() promise.\");\n    },\n    /** Return an observable that can be used to subscribe to internal events happening in the thread. Useful for debugging. */\n    events: function (thread) {\n        return thread[symbols_1.$events] || fail(\"Events observable not found. Make sure to pass a thread instance as returned by the spawn() promise.\");\n    },\n    /** Terminate a thread. Remember to terminate every thread when you are done using it. */\n    terminate: function (thread) {\n        return thread[symbols_1.$terminate]();\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/master/thread.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/observable-promise.js":
/*!*************************************************************!*\
  !*** ./node_modules/threads/dist-esm/observable-promise.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservablePromise = void 0;\nvar observable_fns_1 = __webpack_require__(/*! observable-fns */ \"./node_modules/observable-fns/dist.esm/index.js\");\nvar doNothing = function () { return undefined; };\nvar returnInput = function (input) { return input; };\nvar runDeferred = function (fn) { return Promise.resolve().then(fn); };\nfunction fail(error) {\n    throw error;\n}\nfunction isThenable(thing) {\n    return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nvar ObservablePromise = /** @class */ (function (_super) {\n    __extends(ObservablePromise, _super);\n    function ObservablePromise(init) {\n        var _this = _super.call(this, function (originalObserver) {\n            // tslint:disable-next-line no-this-assignment\n            var self = _this;\n            var observer = Object.assign(Object.assign({}, originalObserver), { complete: function () {\n                    originalObserver.complete();\n                    self.onCompletion();\n                }, error: function (error) {\n                    originalObserver.error(error);\n                    self.onError(error);\n                }, next: function (value) {\n                    originalObserver.next(value);\n                    self.onNext(value);\n                } });\n            try {\n                _this.initHasRun = true;\n                return init(observer);\n            }\n            catch (error) {\n                observer.error(error);\n            }\n        }) || this;\n        _this.initHasRun = false;\n        _this.fulfillmentCallbacks = [];\n        _this.rejectionCallbacks = [];\n        _this.firstValueSet = false;\n        _this.state = \"pending\";\n        return _this;\n    }\n    ObservablePromise.prototype.onNext = function (value) {\n        if (!this.firstValueSet) {\n            this.firstValue = value;\n            this.firstValueSet = true;\n        }\n    };\n    ObservablePromise.prototype.onError = function (error) {\n        this.state = \"rejected\";\n        this.rejection = error;\n        var _loop_1 = function (onRejected) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(function () { return onRejected(error); });\n        };\n        for (var _i = 0, _a = this.rejectionCallbacks; _i < _a.length; _i++) {\n            var onRejected = _a[_i];\n            _loop_1(onRejected);\n        }\n    };\n    ObservablePromise.prototype.onCompletion = function () {\n        var _this = this;\n        this.state = \"fulfilled\";\n        var _loop_2 = function (onFulfilled) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(function () { return onFulfilled(_this.firstValue); });\n        };\n        for (var _i = 0, _a = this.fulfillmentCallbacks; _i < _a.length; _i++) {\n            var onFulfilled = _a[_i];\n            _loop_2(onFulfilled);\n        }\n    };\n    ObservablePromise.prototype.then = function (onFulfilledRaw, onRejectedRaw) {\n        var _this = this;\n        var onFulfilled = onFulfilledRaw || returnInput;\n        var onRejected = onRejectedRaw || fail;\n        var onRejectedCalled = false;\n        return new Promise(function (resolve, reject) {\n            var rejectionCallback = function (error) {\n                if (onRejectedCalled)\n                    return;\n                onRejectedCalled = true;\n                try {\n                    resolve(onRejected(error));\n                }\n                catch (anotherError) {\n                    reject(anotherError);\n                }\n            };\n            var fulfillmentCallback = function (value) {\n                try {\n                    resolve(onFulfilled(value));\n                }\n                catch (error) {\n                    rejectionCallback(error);\n                }\n            };\n            if (!_this.initHasRun) {\n                _this.subscribe({ error: rejectionCallback });\n            }\n            if (_this.state === \"fulfilled\") {\n                return resolve(onFulfilled(_this.firstValue));\n            }\n            if (_this.state === \"rejected\") {\n                onRejectedCalled = true;\n                return resolve(onRejected(_this.rejection));\n            }\n            _this.fulfillmentCallbacks.push(fulfillmentCallback);\n            _this.rejectionCallbacks.push(rejectionCallback);\n        });\n    };\n    ObservablePromise.prototype.catch = function (onRejected) {\n        return this.then(undefined, onRejected);\n    };\n    ObservablePromise.prototype.finally = function (onCompleted) {\n        var handler = onCompleted || doNothing;\n        return this.then(function (value) {\n            handler();\n            return value;\n        }, function () { return handler(); });\n    };\n    ObservablePromise.from = function (thing) {\n        if (isThenable(thing)) {\n            return new ObservablePromise(function (observer) {\n                var onFulfilled = function (value) {\n                    observer.next(value);\n                    observer.complete();\n                };\n                var onRejected = function (error) {\n                    observer.error(error);\n                };\n                thing.then(onFulfilled, onRejected);\n            });\n        }\n        else {\n            return _super.from.call(this, thing);\n        }\n    };\n    return ObservablePromise;\n}(observable_fns_1.Observable));\nexports.ObservablePromise = ObservablePromise;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/observable-promise.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/ponyfills.js":
/*!****************************************************!*\
  !*** ./node_modules/threads/dist-esm/ponyfills.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.allSettled = void 0;\n// Based on <https://github.com/es-shims/Promise.allSettled/blob/master/implementation.js>\nfunction allSettled(values) {\n    return Promise.all(values.map(function (item) {\n        var onFulfill = function (value) {\n            return { status: 'fulfilled', value: value };\n        };\n        var onReject = function (reason) {\n            return { status: 'rejected', reason: reason };\n        };\n        var itemPromise = Promise.resolve(item);\n        try {\n            return itemPromise.then(onFulfill, onReject);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }));\n}\nexports.allSettled = allSettled;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/ponyfills.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/promise.js":
/*!**************************************************!*\
  !*** ./node_modules/threads/dist-esm/promise.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createPromiseWithResolver = void 0;\nvar doNothing = function () { return undefined; };\n/**\n * Creates a new promise and exposes its resolver function.\n * Use with care!\n */\nfunction createPromiseWithResolver() {\n    var alreadyResolved = false;\n    var resolvedTo;\n    var resolver = doNothing;\n    var promise = new Promise(function (resolve) {\n        if (alreadyResolved) {\n            resolve(resolvedTo);\n        }\n        else {\n            resolver = resolve;\n        }\n    });\n    var exposedResolver = function (value) {\n        alreadyResolved = true;\n        resolvedTo = value;\n        resolver(resolvedTo);\n    };\n    return [promise, exposedResolver];\n}\nexports.createPromiseWithResolver = createPromiseWithResolver;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/promise.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/serializers.js":
/*!******************************************************!*\
  !*** ./node_modules/threads/dist-esm/serializers.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultSerializer = exports.extendSerializer = void 0;\nfunction extendSerializer(extend, implementation) {\n    var fallbackDeserializer = extend.deserialize.bind(extend);\n    var fallbackSerializer = extend.serialize.bind(extend);\n    return {\n        deserialize: function (message) {\n            return implementation.deserialize(message, fallbackDeserializer);\n        },\n        serialize: function (input) {\n            return implementation.serialize(input, fallbackSerializer);\n        }\n    };\n}\nexports.extendSerializer = extendSerializer;\nvar DefaultErrorSerializer = {\n    deserialize: function (message) {\n        return Object.assign(Error(message.message), {\n            name: message.name,\n            stack: message.stack\n        });\n    },\n    serialize: function (error) {\n        return {\n            __error_marker: \"$$error\",\n            message: error.message,\n            name: error.name,\n            stack: error.stack\n        };\n    }\n};\nvar isSerializedError = function (thing) { return thing && typeof thing === \"object\" && \"__error_marker\" in thing && thing.__error_marker === \"$$error\"; };\nexports.DefaultSerializer = {\n    deserialize: function (message) {\n        if (isSerializedError(message)) {\n            return DefaultErrorSerializer.deserialize(message);\n        }\n        else {\n            return message;\n        }\n    },\n    serialize: function (input) {\n        if (input instanceof Error) {\n            return DefaultErrorSerializer.serialize(input);\n        }\n        else {\n            return input;\n        }\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/serializers.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/symbols.js":
/*!**************************************************!*\
  !*** ./node_modules/threads/dist-esm/symbols.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$worker = exports.$transferable = exports.$terminate = exports.$events = exports.$errors = void 0;\nexports.$errors = Symbol(\"thread.errors\");\nexports.$events = Symbol(\"thread.events\");\nexports.$terminate = Symbol(\"thread.terminate\");\nexports.$transferable = Symbol(\"thread.transferable\");\nexports.$worker = Symbol(\"thread.worker\");\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/symbols.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/transferable.js":
/*!*******************************************************!*\
  !*** ./node_modules/threads/dist-esm/transferable.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transfer = exports.isTransferDescriptor = void 0;\nvar symbols_1 = __webpack_require__(/*! ./symbols */ \"./node_modules/threads/dist-esm/symbols.js\");\nfunction isTransferable(thing) {\n    if (!thing || typeof thing !== \"object\")\n        return false;\n    // Don't check too thoroughly, since the list of transferable things in JS might grow over time\n    return true;\n}\nfunction isTransferDescriptor(thing) {\n    return thing && typeof thing === \"object\" && thing[symbols_1.$transferable];\n}\nexports.isTransferDescriptor = isTransferDescriptor;\nfunction Transfer(payload, transferables) {\n    var _a;\n    if (!transferables) {\n        if (!isTransferable(payload))\n            throw Error();\n        transferables = [payload];\n    }\n    return _a = {},\n        _a[symbols_1.$transferable] = true,\n        _a.send = payload,\n        _a.transferables = transferables,\n        _a;\n}\nexports.Transfer = Transfer;\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/transferable.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/types/master.js":
/*!*******************************************************!*\
  !*** ./node_modules/threads/dist-esm/types/master.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerEventType = void 0;\n(function (WorkerEventType) {\n    WorkerEventType[\"internalError\"] = \"internalError\";\n    WorkerEventType[\"message\"] = \"message\";\n    WorkerEventType[\"termination\"] = \"termination\";\n})(exports.WorkerEventType || (exports.WorkerEventType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/types/master.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/types/messages.js":
/*!*********************************************************!*\
  !*** ./node_modules/threads/dist-esm/types/messages.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerMessageType = exports.MasterMessageType = void 0;\n(function (MasterMessageType) {\n    MasterMessageType[\"cancel\"] = \"cancel\";\n    MasterMessageType[\"run\"] = \"run\";\n})(exports.MasterMessageType || (exports.MasterMessageType = {}));\n(function (WorkerMessageType) {\n    WorkerMessageType[\"error\"] = \"error\";\n    WorkerMessageType[\"init\"] = \"init\";\n    WorkerMessageType[\"result\"] = \"result\";\n    WorkerMessageType[\"running\"] = \"running\";\n    WorkerMessageType[\"uncaughtError\"] = \"uncaughtError\";\n})(exports.WorkerMessageType || (exports.WorkerMessageType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/types/messages.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/worker/implementation.browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/threads/dist-esm/worker/implementation.browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference lib=\"dom\" />\n// tslint:disable no-shadowed-variable\nvar isWorkerRuntime = function isWorkerRuntime() {\n    var isWindowContext = typeof self !== \"undefined\" && typeof Window !== \"undefined\" && self instanceof Window;\n    return typeof self !== \"undefined\" && self.postMessage && !isWindowContext ? true : false;\n};\nvar postMessageToMaster = function postMessageToMaster(data, transferList) {\n    self.postMessage(data, transferList);\n};\nvar subscribeToMasterMessages = function subscribeToMasterMessages(onMessage) {\n    var messageHandler = function (messageEvent) {\n        onMessage(messageEvent.data);\n    };\n    var unsubscribe = function () {\n        self.removeEventListener(\"message\", messageHandler);\n    };\n    self.addEventListener(\"message\", messageHandler);\n    return unsubscribe;\n};\nexports.default = {\n    isWorkerRuntime: isWorkerRuntime,\n    postMessageToMaster: postMessageToMaster,\n    subscribeToMasterMessages: subscribeToMasterMessages\n};\n\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/worker/implementation.browser.js?");

/***/ }),

/***/ "./node_modules/threads/dist-esm/worker/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/threads/dist-esm/worker/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expose = exports.isWorkerRuntime = exports.Transfer = exports.registerSerializer = void 0;\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar is_observable_1 = __importDefault(__webpack_require__(/*! is-observable */ \"./node_modules/is-observable/index.js\"));\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/threads/dist-esm/common.js\");\nvar transferable_1 = __webpack_require__(/*! ../transferable */ \"./node_modules/threads/dist-esm/transferable.js\");\nvar messages_1 = __webpack_require__(/*! ../types/messages */ \"./node_modules/threads/dist-esm/types/messages.js\");\nvar implementation_1 = __importDefault(__webpack_require__(/*! ./implementation */ \"./node_modules/threads/dist-esm/worker/implementation.browser.js\"));\nvar common_2 = __webpack_require__(/*! ../common */ \"./node_modules/threads/dist-esm/common.js\");\nObject.defineProperty(exports, \"registerSerializer\", { enumerable: true, get: function () { return common_2.registerSerializer; } });\nvar transferable_2 = __webpack_require__(/*! ../transferable */ \"./node_modules/threads/dist-esm/transferable.js\");\nObject.defineProperty(exports, \"Transfer\", { enumerable: true, get: function () { return transferable_2.Transfer; } });\n/** Returns `true` if this code is currently running in a worker. */\nexports.isWorkerRuntime = implementation_1.default.isWorkerRuntime;\nvar exposeCalled = false;\nvar activeSubscriptions = new Map();\nvar isMasterJobCancelMessage = function (thing) { return thing && thing.type === messages_1.MasterMessageType.cancel; };\nvar isMasterJobRunMessage = function (thing) { return thing && thing.type === messages_1.MasterMessageType.run; };\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\nvar isObservable = function (thing) { return (0, is_observable_1.default)(thing) || isZenObservable(thing); };\nfunction isZenObservable(thing) {\n    return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\nfunction deconstructTransfer(thing) {\n    return (0, transferable_1.isTransferDescriptor)(thing)\n        ? { payload: thing.send, transferables: thing.transferables }\n        : { payload: thing, transferables: undefined };\n}\nfunction postFunctionInitMessage() {\n    var initMessage = {\n        type: messages_1.WorkerMessageType.init,\n        exposed: {\n            type: \"function\"\n        }\n    };\n    implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postModuleInitMessage(methodNames) {\n    var initMessage = {\n        type: messages_1.WorkerMessageType.init,\n        exposed: {\n            type: \"module\",\n            methods: methodNames\n        }\n    };\n    implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postJobErrorMessage(uid, rawError) {\n    var _a = deconstructTransfer(rawError), error = _a.payload, transferables = _a.transferables;\n    var errorMessage = {\n        type: messages_1.WorkerMessageType.error,\n        uid: uid,\n        error: (0, common_1.serialize)(error)\n    };\n    implementation_1.default.postMessageToMaster(errorMessage, transferables);\n}\nfunction postJobResultMessage(uid, completed, resultValue) {\n    var _a = deconstructTransfer(resultValue), payload = _a.payload, transferables = _a.transferables;\n    var resultMessage = {\n        type: messages_1.WorkerMessageType.result,\n        uid: uid,\n        complete: completed ? true : undefined,\n        payload: payload\n    };\n    implementation_1.default.postMessageToMaster(resultMessage, transferables);\n}\nfunction postJobStartMessage(uid, resultType) {\n    var startMessage = {\n        type: messages_1.WorkerMessageType.running,\n        uid: uid,\n        resultType: resultType\n    };\n    implementation_1.default.postMessageToMaster(startMessage);\n}\nfunction postUncaughtErrorMessage(error) {\n    try {\n        var errorMessage = {\n            type: messages_1.WorkerMessageType.uncaughtError,\n            error: (0, common_1.serialize)(error)\n        };\n        implementation_1.default.postMessageToMaster(errorMessage);\n    }\n    catch (subError) {\n        // tslint:disable-next-line no-console\n        console.error(\"Not reporting uncaught error back to master thread as it \" +\n            \"occured while reporting an uncaught error already.\" +\n            \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n    }\n}\nfunction runFunction(jobUID, fn, args) {\n    return __awaiter(this, void 0, void 0, function () {\n        var syncResult, resultType, subscription, result, error_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    try {\n                        syncResult = fn.apply(void 0, args);\n                    }\n                    catch (error) {\n                        return [2 /*return*/, postJobErrorMessage(jobUID, error)];\n                    }\n                    resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n                    postJobStartMessage(jobUID, resultType);\n                    if (!isObservable(syncResult)) return [3 /*break*/, 1];\n                    subscription = syncResult.subscribe(function (value) { return postJobResultMessage(jobUID, false, (0, common_1.serialize)(value)); }, function (error) {\n                        postJobErrorMessage(jobUID, (0, common_1.serialize)(error));\n                        activeSubscriptions.delete(jobUID);\n                    }, function () {\n                        postJobResultMessage(jobUID, true);\n                        activeSubscriptions.delete(jobUID);\n                    });\n                    activeSubscriptions.set(jobUID, subscription);\n                    return [3 /*break*/, 4];\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, syncResult];\n                case 2:\n                    result = _a.sent();\n                    postJobResultMessage(jobUID, true, (0, common_1.serialize)(result));\n                    return [3 /*break*/, 4];\n                case 3:\n                    error_1 = _a.sent();\n                    postJobErrorMessage(jobUID, (0, common_1.serialize)(error_1));\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\nfunction expose(exposed) {\n    if (!implementation_1.default.isWorkerRuntime()) {\n        throw Error(\"expose() called in the master thread.\");\n    }\n    if (exposeCalled) {\n        throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n    }\n    exposeCalled = true;\n    if (typeof exposed === \"function\") {\n        implementation_1.default.subscribeToMasterMessages(function (messageData) {\n            if (isMasterJobRunMessage(messageData) && !messageData.method) {\n                runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));\n            }\n        });\n        postFunctionInitMessage();\n    }\n    else if (typeof exposed === \"object\" && exposed) {\n        implementation_1.default.subscribeToMasterMessages(function (messageData) {\n            if (isMasterJobRunMessage(messageData) && messageData.method) {\n                runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));\n            }\n        });\n        var methodNames = Object.keys(exposed).filter(function (key) { return typeof exposed[key] === \"function\"; });\n        postModuleInitMessage(methodNames);\n    }\n    else {\n        throw Error(\"Invalid argument passed to expose(). Expected a function or an object, got: \".concat(exposed));\n    }\n    implementation_1.default.subscribeToMasterMessages(function (messageData) {\n        if (isMasterJobCancelMessage(messageData)) {\n            var jobUID = messageData.uid;\n            var subscription = activeSubscriptions.get(jobUID);\n            if (subscription) {\n                subscription.unsubscribe();\n                activeSubscriptions.delete(jobUID);\n            }\n        }\n    });\n}\nexports.expose = expose;\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && implementation_1.default.isWorkerRuntime()) {\n    self.addEventListener(\"error\", function (event) {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(function () { return postUncaughtErrorMessage(event.error || event); }, 250);\n    });\n    self.addEventListener(\"unhandledrejection\", function (event) {\n        var error = event.reason;\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(function () { return postUncaughtErrorMessage(error); }, 250);\n        }\n    });\n}\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && implementation_1.default.isWorkerRuntime()) {\n    process.on(\"uncaughtException\", function (error) {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(function () { return postUncaughtErrorMessage(error); }, 250);\n    });\n    process.on(\"unhandledRejection\", function (error) {\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(function () { return postUncaughtErrorMessage(error); }, 250);\n        }\n    });\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/threads/dist-esm/worker/index.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar scope = (typeof global !== \"undefined\" && global) ||\n    (typeof self !== \"undefined\" && self) ||\n    window;\nvar apply = Function.prototype.apply;\n// DOM APIs, for completeness\nexports.setTimeout = function () {\n    return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function () {\n    return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\n    exports.clearInterval = function (timeout) {\n        if (timeout) {\n            timeout.close();\n        }\n    };\nfunction Timeout(id, clearFn) {\n    this._id = id;\n    this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function () { };\nTimeout.prototype.close = function () {\n    this._clearFn.call(scope, this._id);\n};\n// Does not start the time, just sets up the members needed.\nexports.enroll = function (item, msecs) {\n    clearTimeout(item._idleTimeoutId);\n    item._idleTimeout = msecs;\n};\nexports.unenroll = function (item) {\n    clearTimeout(item._idleTimeoutId);\n    item._idleTimeout = -1;\n};\nexports._unrefActive = exports.active = function (item) {\n    clearTimeout(item._idleTimeoutId);\n    var msecs = item._idleTimeout;\n    if (msecs >= 0) {\n        item._idleTimeoutId = setTimeout(function onTimeout() {\n            if (item._onTimeout)\n                item._onTimeout();\n        }, msecs);\n    }\n};\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n    (typeof global !== \"undefined\" && global.setImmediate) ||\n    (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n    (typeof global !== \"undefined\" && global.clearImmediate) ||\n    (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar g;\n// This works in non-strict mode\ng = (function () {\n    return this;\n})();\ntry {\n    // This works if eval is allowed (see CSP)\n    g = g || new Function(\"return this\")();\n}\ncatch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\")\n        g = window;\n}\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/FaaS.ts":
/*!*********************!*\
  !*** ./src/FaaS.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright 2022 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FaaS = void 0;\nvar wasi_1 = __webpack_require__(/*! @wasmer/wasi */ \"./node_modules/@wasmer/wasi/lib/index.esm.js\");\nvar browser_1 = __importDefault(__webpack_require__(/*! @wasmer/wasi/lib/bindings/browser */ \"./node_modules/@wasmer/wasi/lib/bindings/browser.js\"));\nvar wasmfs_1 = __webpack_require__(/*! @wasmer/wasmfs */ \"./node_modules/@wasmer/wasmfs/lib/index.esm.js\");\nvar marine_web_runtime_1 = __webpack_require__(/*! ./marine_web_runtime */ \"./src/marine_web_runtime.js\");\nvar cachegetUint8Memory0 = null;\nfunction getUint8Memory0(wasm) {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\nfunction getStringFromWasm0(wasm, ptr, len) {\n    return decoder.decode(getUint8Memory0(wasm).subarray(ptr, ptr + len));\n}\nvar LEVEL_ERROR = 1;\nvar LEVEL_WARN = 2;\nvar LEVEL_INFO = 3;\nvar LEVEL_TRACE = 4;\nvar LEVEL_DEBUG = 5;\nvar decoder = new TextDecoder();\nvar FaaS = /** @class */ (function () {\n    function FaaS(controlModule, serviceModule, serviceId, faaSConfig, env) {\n        this._env = {};\n        this._marineInstance = 'not-set';\n        this._controlModule = controlModule;\n        this._serviceModule = serviceModule;\n        this._serviceId = serviceId;\n        this._env = __assign({ WASM_LOG: 'off' }, env);\n    }\n    FaaS.prototype.init = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var wasi, cfg, wasiImports, serviceInstance, controlModuleInstance, customSections, itCustomSections, rawResult, result;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        wasi = new wasi_1.WASI({\n                            args: [],\n                            env: this._env,\n                            bindings: __assign(__assign({}, browser_1.default), { fs: new wasmfs_1.WasmFs().fs }),\n                        });\n                        cfg = {\n                            exports: undefined,\n                        };\n                        wasiImports = hasWasiImports(this._serviceModule) ? wasi.getImports(this._serviceModule) : {};\n                        return [4 /*yield*/, WebAssembly.instantiate(this._serviceModule, __assign(__assign({}, wasiImports), { host: {\n                                    log_utf8_string: function (level, target, offset, size) {\n                                        var wasm = cfg.exports;\n                                        var message = getStringFromWasm0(wasm, offset, size);\n                                        var str = \"[marine service \\\"\".concat(_this._serviceId, \"\\\"]: \").concat(message);\n                                        if (level <= LEVEL_ERROR) {\n                                            console.error(str);\n                                        }\n                                        else if (level === LEVEL_WARN) {\n                                            console.warn(str);\n                                        }\n                                        else if (level === LEVEL_INFO) {\n                                            console.info(str);\n                                        }\n                                        else if (level === LEVEL_TRACE) {\n                                            console.log(str);\n                                        }\n                                        else if (level >= LEVEL_DEBUG) {\n                                            console.log(str);\n                                        }\n                                    },\n                                } }))];\n                    case 1:\n                        serviceInstance = _a.sent();\n                        wasi.start(serviceInstance);\n                        cfg.exports = serviceInstance.exports;\n                        return [4 /*yield*/, (0, marine_web_runtime_1.init)(this._controlModule)];\n                    case 2:\n                        controlModuleInstance = _a.sent();\n                        customSections = WebAssembly.Module.customSections(this._serviceModule, 'interface-types');\n                        itCustomSections = new Uint8Array(customSections[0]);\n                        rawResult = controlModuleInstance.register_module(this._serviceId, itCustomSections, serviceInstance);\n                        try {\n                            result = JSON.parse(rawResult);\n                            this._marineInstance = controlModuleInstance;\n                            return [2 /*return*/, result];\n                        }\n                        catch (ex) {\n                            throw 'register_module result parsing error: ' + ex + ', original text: ' + rawResult;\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FaaS.prototype.terminate = function () {\n        this._marineInstance = 'not-set';\n    };\n    FaaS.prototype.call = function (function_name, args, callParams) {\n        if (this._marineInstance === 'not-set') {\n            throw new Error('Not initialized');\n        }\n        if (this._marineInstance === 'terminated') {\n            throw new Error('Terminated');\n        }\n        return this._marineInstance.call_module(this._serviceId, function_name, args);\n    };\n    return FaaS;\n}());\nexports.FaaS = FaaS;\nfunction hasWasiImports(module) {\n    var imports = WebAssembly.Module.imports(module);\n    var firstWasiImport = imports.find(function (x) {\n        return x.module === 'wasi_snapshot_preview1' || x.module === 'wasi_unstable';\n    });\n    return firstWasiImport !== undefined;\n}\n\n\n//# sourceURL=webpack:///./src/FaaS.ts?");

/***/ }),

/***/ "./src/backgroundScript.ts":
/*!*********************************!*\
  !*** ./src/backgroundScript.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright 2022 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar threads_1 = __webpack_require__(/*! threads */ \"./node_modules/threads/dist-esm/index.js\");\nvar FaaS_1 = __webpack_require__(/*! ./FaaS */ \"./src/FaaS.ts\");\nvar faasInstances = new Map();\nvar controlModule;\nvar asArray = function (buf) {\n    return new Uint8Array(buf);\n};\nvar toExpose = {\n    init: function (controlModuleWasm) { return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, WebAssembly.compile(asArray(controlModuleWasm))];\n                case 1:\n                    controlModule = _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    }); },\n    createService: function (wasm, serviceId, faaSConfig, envs) { return __awaiter(void 0, void 0, void 0, function () {\n        var service, faas;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, WebAssembly.compile(asArray(wasm))];\n                case 1:\n                    service = _a.sent();\n                    faas = new FaaS_1.FaaS(controlModule, service, serviceId, faaSConfig, envs);\n                    return [4 /*yield*/, faas.init()];\n                case 2:\n                    _a.sent();\n                    faasInstances.set(serviceId, faas);\n                    return [2 /*return*/];\n            }\n        });\n    }); },\n    terminate: function () { return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            faasInstances.forEach(function (val, key) {\n                val.terminate();\n            });\n            return [2 /*return*/];\n        });\n    }); },\n    callService: function (serviceId, functionName, args, callParams) { return __awaiter(void 0, void 0, void 0, function () {\n        var faas;\n        return __generator(this, function (_a) {\n            faas = faasInstances.get(serviceId);\n            if (!faas) {\n                throw new Error(\"service with id=\".concat(serviceId, \" not found\"));\n            }\n            return [2 /*return*/, faas.call(functionName, args, callParams)];\n        });\n    }); },\n};\n(0, threads_1.expose)(toExpose);\n\n\n//# sourceURL=webpack:///./src/backgroundScript.ts?");

/***/ }),

/***/ "./src/marine_web_runtime.js":
/*!***********************************!*\
  !*** ./src/marine_web_runtime.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright 2022 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.init = void 0;\n// This is patched generated by wasm-pack file\nvar marine_js_js_1 = __webpack_require__(/*! ./snippets/marine-web-runtime-6faa67b8af9cc173/marine-js.js */ \"./src/snippets/marine-web-runtime-6faa67b8af9cc173/marine-js.js\");\nfunction init(module) {\n    return __awaiter(this, void 0, void 0, function () {\n        function getObject(idx) {\n            return heap[idx];\n        }\n        function dropObject(idx) {\n            if (idx < 36)\n                return;\n            heap[idx] = heap_next;\n            heap_next = idx;\n        }\n        function takeObject(idx) {\n            var ret = getObject(idx);\n            dropObject(idx);\n            return ret;\n        }\n        function getUint8Memory0() {\n            if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n                cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n            }\n            return cachegetUint8Memory0;\n        }\n        function getStringFromWasm0(ptr, len) {\n            return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n        }\n        function passStringToWasm0(arg, malloc, realloc) {\n            if (realloc === undefined) {\n                var buf = cachedTextEncoder.encode(arg);\n                var ptr_1 = malloc(buf.length);\n                getUint8Memory0()\n                    .subarray(ptr_1, ptr_1 + buf.length)\n                    .set(buf);\n                WASM_VECTOR_LEN = buf.length;\n                return ptr_1;\n            }\n            var len = arg.length;\n            var ptr = malloc(len);\n            var mem = getUint8Memory0();\n            var offset = 0;\n            for (; offset < len; offset++) {\n                var code = arg.charCodeAt(offset);\n                if (code > 0x7f)\n                    break;\n                mem[ptr + offset] = code;\n            }\n            if (offset !== len) {\n                if (offset !== 0) {\n                    arg = arg.slice(offset);\n                }\n                ptr = realloc(ptr, len, (len = offset + arg.length * 3));\n                var view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n                var ret = encodeString(arg, view);\n                offset += ret.written;\n            }\n            WASM_VECTOR_LEN = offset;\n            return ptr;\n        }\n        function getInt32Memory0() {\n            if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n                cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n            }\n            return cachegetInt32Memory0;\n        }\n        function getArrayU8FromWasm0(ptr, len) {\n            return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n        }\n        function addHeapObject(obj) {\n            if (heap_next === heap.length)\n                heap.push(heap.length + 1);\n            var idx = heap_next;\n            heap_next = heap[idx];\n            heap[idx] = obj;\n            return idx;\n        }\n        /**\n         */\n        function main() {\n            wasm.main();\n        }\n        function passArray8ToWasm0(arg, malloc) {\n            var ptr = malloc(arg.length * 1);\n            getUint8Memory0().set(arg, ptr / 1);\n            WASM_VECTOR_LEN = arg.length;\n            return ptr;\n        }\n        /**\n         * Registers a module insite web-runtime.\n         *\n         * # Arguments\n         *\n         * * `name` - name of module to register\n         * * `wit_section_bytes` - bytes of \"interface-types\" custom section from wasm file\n         * * `instance` - `WebAssembly::Instance` made from target wasm file\n         *\n         * # Return value\n         *\n         * JSON object with field \"error\". If error is empty, module is registered.\n         * otherwise, it contaits error message.\n         * @param {string} name\n         * @param {Uint8Array} wit_section_bytes\n         * @param {any} wasm_instance\n         * @returns {string}\n         */\n        function register_module(name, wit_section_bytes, wasm_instance) {\n            try {\n                var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n                var ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n                var len0 = WASM_VECTOR_LEN;\n                var ptr1 = passArray8ToWasm0(wit_section_bytes, wasm.__wbindgen_malloc);\n                var len1 = WASM_VECTOR_LEN;\n                wasm.register_module(retptr, ptr0, len0, ptr1, len1, addHeapObject(wasm_instance));\n                var r0 = getInt32Memory0()[retptr / 4 + 0];\n                var r1 = getInt32Memory0()[retptr / 4 + 1];\n                return getStringFromWasm0(r0, r1);\n            }\n            finally {\n                wasm.__wbindgen_add_to_stack_pointer(16);\n                wasm.__wbindgen_free(r0, r1);\n            }\n        }\n        /**\n         *  Calls a function from a module.\n         *\n         * # Arguments\n         *\n         * * module_name - name of registered module\n         * * function_name - name of the function to call\n         * * args - JSON array of function arguments\n         *\n         * # Return value\n         *\n         * JSON object with fields \"error\" and \"result\". If \"error\" is empty string,\n         * \"result\" contains a function return value. Othervise, \"error\" contains error message.\n         * @param {string} module_name\n         * @param {string} function_name\n         * @param {string} args\n         * @returns {string}\n         */\n        function call_module(module_name, function_name, args) {\n            try {\n                var retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n                var ptr0 = passStringToWasm0(module_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n                var len0 = WASM_VECTOR_LEN;\n                var ptr1 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n                var len1 = WASM_VECTOR_LEN;\n                var ptr2 = passStringToWasm0(args, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n                var len2 = WASM_VECTOR_LEN;\n                wasm.call_module(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n                var r0 = getInt32Memory0()[retptr / 4 + 0];\n                var r1 = getInt32Memory0()[retptr / 4 + 1];\n                return getStringFromWasm0(r0, r1);\n            }\n            finally {\n                wasm.__wbindgen_add_to_stack_pointer(16);\n                wasm.__wbindgen_free(r0, r1);\n            }\n        }\n        function init(wasmModule) {\n            return __awaiter(this, void 0, void 0, function () {\n                var imports, instance;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            imports = {};\n                            imports.wbg = {};\n                            imports.wbg.__wbg_new_693216e109162396 = function () {\n                                var ret = new Error();\n                                return addHeapObject(ret);\n                            };\n                            imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function (arg0, arg1) {\n                                var ret = getObject(arg1).stack;\n                                var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n                                var len0 = WASM_VECTOR_LEN;\n                                getInt32Memory0()[arg0 / 4 + 1] = len0;\n                                getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n                            };\n                            imports.wbg.__wbg_error_09919627ac0992f5 = function (arg0, arg1) {\n                                try {\n                                    console.error(getStringFromWasm0(arg0, arg1));\n                                }\n                                finally {\n                                    wasm.__wbindgen_free(arg0, arg1);\n                                }\n                            };\n                            imports.wbg.__wbindgen_object_drop_ref = function (arg0) {\n                                takeObject(arg0);\n                            };\n                            imports.wbg.__wbg_writebyte_5cf11e3bc7462ec2 = function (arg0, arg1, arg2) {\n                                (0, marine_js_js_1.write_byte)(getObject(arg0), arg1 >>> 0, arg2);\n                            };\n                            imports.wbg.__wbg_writebyterange_bca7718185fe74fe = function (arg0, arg1, arg2, arg3) {\n                                (0, marine_js_js_1.write_byte_range)(getObject(arg0), arg1 >>> 0, getArrayU8FromWasm0(arg2, arg3));\n                            };\n                            imports.wbg.__wbg_readbyte_4e42fb4a6e94d4cc = function (arg0, arg1) {\n                                var ret = (0, marine_js_js_1.read_byte)(getObject(arg0), arg1 >>> 0);\n                                return ret;\n                            };\n                            imports.wbg.__wbg_readbyterange_a6e4127576d4a165 = function (arg0, arg1, arg2, arg3) {\n                                (0, marine_js_js_1.read_byte_range)(getObject(arg0), arg1 >>> 0, getArrayU8FromWasm0(arg2, arg3));\n                            };\n                            imports.wbg.__wbg_getmemorysize_44ed7b542fa6e518 = function (arg0) {\n                                var ret = (0, marine_js_js_1.get_memory_size)(getObject(arg0));\n                                return ret;\n                            };\n                            imports.wbg.__wbg_callexport_a4e71f5003bf3d97 = function (arg0, arg1, arg2, arg3, arg4, arg5) {\n                                var ret = (0, marine_js_js_1.call_export)(getObject(arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5));\n                                var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n                                var len0 = WASM_VECTOR_LEN;\n                                getInt32Memory0()[arg0 / 4 + 1] = len0;\n                                getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n                            };\n                            return [4 /*yield*/, WebAssembly.instantiate(wasmModule, imports)];\n                        case 1:\n                            instance = _a.sent();\n                            wasm = instance.exports;\n                            // strange line from autogenerated code. No idea why it's needed\n                            init.__wbindgen_wasm_module = module;\n                            // calls main() function. Used to set up\n                            wasm.__wbindgen_start();\n                            return [2 /*return*/, wasm];\n                    }\n                });\n            });\n        }\n        var wasm, heap, heap_next, cachedTextDecoder, cachegetUint8Memory0, WASM_VECTOR_LEN, cachedTextEncoder, encodeString, cachegetInt32Memory0;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    heap = new Array(32).fill(undefined);\n                    heap.push(undefined, null, true, false);\n                    heap_next = heap.length;\n                    cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n                    cachedTextDecoder.decode();\n                    cachegetUint8Memory0 = null;\n                    WASM_VECTOR_LEN = 0;\n                    cachedTextEncoder = new TextEncoder('utf-8');\n                    encodeString = typeof cachedTextEncoder.encodeInto === 'function'\n                        ? function (arg, view) {\n                            return cachedTextEncoder.encodeInto(arg, view);\n                        }\n                        : function (arg, view) {\n                            var buf = cachedTextEncoder.encode(arg);\n                            view.set(buf);\n                            return {\n                                read: arg.length,\n                                written: buf.length,\n                            };\n                        };\n                    cachegetInt32Memory0 = null;\n                    return [4 /*yield*/, init(module)];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/, {\n                            wasm: wasm,\n                            register_module: register_module,\n                            call_module: call_module,\n                        }];\n            }\n        });\n    });\n}\nexports.init = init;\n\n\n//# sourceURL=webpack:///./src/marine_web_runtime.js?");

/***/ }),

/***/ "./src/snippets/marine-web-runtime-6faa67b8af9cc173/marine-js.js":
/*!***********************************************************************!*\
  !*** ./src/snippets/marine-web-runtime-6faa67b8af9cc173/marine-js.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright 2022 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.read_byte_range = exports.write_byte_range = exports.write_byte = exports.read_byte = exports.get_memory_size = exports.call_export = void 0;\n// Internal API if marine-web. Only these functions are used for interacting with WebAssembly.Instance\n// None of the functions below performs error-checking\n// It is caller's responsibility to ensure that the instance is valid and has all the exports and required memory size\n/**\n * Calls an export function from wasm module\n *\n * @param {WebAssembly.Instance} instance instance which will be called\n * @param {string} export_name name of the export\n * @param {string} args JSON array of args\n * @returns {string} JSON array of results\n * */\nfunction call_export(instance, export_name, args) {\n    var _a;\n    var parsed_args = JSON.parse(args);\n    var prepared_args = [];\n    for (var arg_index = 0; arg_index < parsed_args.length; arg_index++) {\n        var arg = parsed_args[arg_index];\n        if (arg[\"I32\"] !== undefined) {\n            prepared_args.push(arg[\"I32\"]);\n        }\n        if (arg[\"I64\"] !== undefined) {\n            ;\n            var val = BigInt(arg[\"I64\"]);\n            prepared_args.push(val);\n        }\n        if (arg[\"F32\"] !== undefined) {\n            prepared_args.push(arg[\"F32\"]);\n        }\n        if (arg[\"F64\"] !== undefined) {\n            prepared_args.push(arg[\"F64\"]);\n        }\n    }\n    var result = (_a = instance.exports)[export_name].apply(_a, prepared_args);\n    var json_result = \"[]\";\n    if (result !== undefined) {\n        if (typeof result == \"bigint\") {\n            json_result = \"[\" + result.toString() + \"]\";\n        }\n        else {\n            json_result = \"[\" + JSON.stringify(result) + \"]\";\n        }\n    }\n    return json_result;\n}\nexports.call_export = call_export;\n/**\n * Gets size of the wasm memory\n *\n * @param {WebAssembly.Instance} instance instance which will be called\n * @returns {number} size of data\n * */\nfunction get_memory_size(instance) {\n    var buf = new Uint8Array(instance.exports.memory.buffer);\n    return buf.byteLength;\n}\nexports.get_memory_size = get_memory_size;\n/**\n * Reads one byte from wasm memory\n *\n * @param {WebAssembly.Instance} instance instance which will be used\n * @param {number} offset offset in wasm memory\n * @returns {number} byte from wasm memory\n * */\nfunction read_byte(instance, offset) {\n    var buf = new Uint8Array(instance.exports.memory.buffer);\n    return buf[offset];\n}\nexports.read_byte = read_byte;\n/**\n * Writes one byte to wasm memory\n *\n * @param {WebAssembly.Instance} instance instance which will be used\n * @param {number} offset offset in wasm memory\n * @param {number} value value to write in memory\n * */\nfunction write_byte(instance, offset, value) {\n    var buf = new Uint8Array(instance.exports.memory.buffer);\n    buf[offset] = value;\n}\nexports.write_byte = write_byte;\n/**\n * Writes byte range to wasm memory\n *\n * @param {WebAssembly.Instance} instance instance which will be used\n * @param {number} offset offset in wasm memory\n * @param {Uint8Array} slice array with bytes to write into memory\n * */\nfunction write_byte_range(instance, offset, slice) {\n    var buf = new Uint8Array(instance.exports.memory.buffer);\n    for (var byte_index = 0; byte_index < slice.length; byte_index++) {\n        buf[offset + byte_index] = slice[byte_index];\n    }\n}\nexports.write_byte_range = write_byte_range;\n/**\n * Reads byte range from wasm memory\n *\n * @param {WebAssembly.Instance} instance instance which will be used\n * @param {number} offset offset in wasm memory\n * @param {Uint8Array} slice array to place read bytes\n * */\nfunction read_byte_range(instance, offset, slice) {\n    var buf = new Uint8Array(instance.exports.memory.buffer);\n    for (var byte_index = 0; byte_index < slice.length; byte_index++) {\n        slice[byte_index] = buf[offset + byte_index];\n    }\n}\nexports.read_byte_range = read_byte_range;\n\n\n//# sourceURL=webpack:///./src/snippets/marine-web-runtime-6faa67b8af9cc173/marine-js.js?");

/***/ })

/******/ });