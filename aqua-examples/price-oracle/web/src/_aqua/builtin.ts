/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/.
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.3.2-233
 *
 */
import { Fluence, FluencePeer } from '@fluencelabs/fluence';
import {
    ResultCodes,
    RequestFlow,
    RequestFlowBuilder,
    CallParams
} from '@fluencelabs/fluence/dist/internal/compilerSupport/v1';


function missingFields(obj: any, fields: string[]): string[] {
    return fields.filter(f => !(f in obj))
}

// Services

export interface SrvDef {
    add_alias: (alias: string, service_id: string, callParams: CallParams<'alias' | 'service_id'>) => void;
create: (blueprint_id: string, callParams: CallParams<'blueprint_id'>) => string;
get_interface: (service_id: string, callParams: CallParams<'service_id'>) => { function_signatures: { arguments: string[][]; name: string; output_types: string[]; }[]; record_types: { fields: string[][]; id: number; name: string; }[]; };
list: (callParams: CallParams<null>) => { blueprint_id: string; id: string; owner_id: string; }[];
remove: (service_id: string, callParams: CallParams<'service_id'>) => void;
resolve_alias: (alias: string, callParams: CallParams<'alias'>) => string;
}
export function registerSrv(service: SrvDef): void;
export function registerSrv(serviceId: string, service: SrvDef): void;
export function registerSrv(peer: FluencePeer, service: SrvDef): void;
export function registerSrv(peer: FluencePeer, serviceId: string, service: SrvDef): void;
       

export function registerSrv(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } else {
        serviceId = "srv"
    }

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['add_alias', 'create', 'get_interface', 'list', 'remove', 'resolve_alias']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service Srv: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'add_alias') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    alias: req.tetraplets[0],service_id: req.tetraplets[1]
                },
            };
            resp.retCode = ResultCodes.success;
            service.add_alias(req.args[0], req.args[1], callParams); resp.result = {}
        }

if (req.fnName === 'create') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    blueprint_id: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.create(req.args[0], callParams)
        }

if (req.fnName === 'get_interface') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    service_id: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.get_interface(req.args[0], callParams)
        }

if (req.fnName === 'list') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.list(callParams)
        }

if (req.fnName === 'remove') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    service_id: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            service.remove(req.args[0], callParams); resp.result = {}
        }

if (req.fnName === 'resolve_alias') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    alias: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.resolve_alias(req.args[0], callParams)
        }

        next();
    });
}
      


export interface PeerDef {
    connect: (id: string, multiaddrs: string[] | null, callParams: CallParams<'id' | 'multiaddrs'>) => boolean;
get_contact: (peer: string, callParams: CallParams<'peer'>) => { addresses: string[]; peer_id: string; };
identify: (callParams: CallParams<null>) => { external_addresses: string[]; };
is_connected: (peer: string, callParams: CallParams<'peer'>) => boolean;
timestamp_ms: (callParams: CallParams<null>) => number;
timestamp_sec: (callParams: CallParams<null>) => number;
}
export function registerPeer(service: PeerDef): void;
export function registerPeer(serviceId: string, service: PeerDef): void;
export function registerPeer(peer: FluencePeer, service: PeerDef): void;
export function registerPeer(peer: FluencePeer, serviceId: string, service: PeerDef): void;
       

export function registerPeer(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } else {
        serviceId = "peer"
    }

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['connect', 'get_contact', 'identify', 'is_connected', 'timestamp_ms', 'timestamp_sec']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service Peer: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'connect') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    id: req.tetraplets[0],multiaddrs: req.tetraplets[1]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.connect(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], callParams)
        }

if (req.fnName === 'get_contact') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    peer: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.get_contact(req.args[0], callParams)
        }

if (req.fnName === 'identify') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.identify(callParams)
        }

if (req.fnName === 'is_connected') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    peer: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.is_connected(req.args[0], callParams)
        }

if (req.fnName === 'timestamp_ms') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.timestamp_ms(callParams)
        }

if (req.fnName === 'timestamp_sec') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.timestamp_sec(callParams)
        }

        next();
    });
}
      


export interface OpDef {
    array: (a: string, b: string | null, c: string | null, d: string | null, callParams: CallParams<'a' | 'b' | 'c' | 'd'>) => string[];
array_length: (array: string[], callParams: CallParams<'array'>) => number;
bytes_from_b58: (b: string, callParams: CallParams<'b'>) => number[];
bytes_to_b58: (bs: number[], callParams: CallParams<'bs'>) => string;
concat: (a: string[], b: string[] | null, c: string[] | null, d: string[] | null, callParams: CallParams<'a' | 'b' | 'c' | 'd'>) => string[];
identity: (s: string | null, callParams: CallParams<'s'>) => string | null;
noop: (callParams: CallParams<null>) => void;
sha256_string: (s: string, callParams: CallParams<'s'>) => string;
string_from_b58: (b: string, callParams: CallParams<'b'>) => string;
string_to_b58: (s: string, callParams: CallParams<'s'>) => string;
}
export function registerOp(service: OpDef): void;
export function registerOp(serviceId: string, service: OpDef): void;
export function registerOp(peer: FluencePeer, service: OpDef): void;
export function registerOp(peer: FluencePeer, serviceId: string, service: OpDef): void;
       

export function registerOp(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } else {
        serviceId = "op"
    }

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['array', 'array_length', 'bytes_from_b58', 'bytes_to_b58', 'concat', 'identity', 'noop', 'sha256_string', 'string_from_b58', 'string_to_b58']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service Op: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'array') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    a: req.tetraplets[0],b: req.tetraplets[1],c: req.tetraplets[2],d: req.tetraplets[3]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.array(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], callParams)
        }

if (req.fnName === 'array_length') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    array: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.array_length(req.args[0], callParams)
        }

if (req.fnName === 'bytes_from_b58') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    b: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.bytes_from_b58(req.args[0], callParams)
        }

if (req.fnName === 'bytes_to_b58') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    bs: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.bytes_to_b58(req.args[0], callParams)
        }

if (req.fnName === 'concat') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    a: req.tetraplets[0],b: req.tetraplets[1],c: req.tetraplets[2],d: req.tetraplets[3]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.concat(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], callParams)
        }

if (req.fnName === 'identity') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    s: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            
 var respResult = service.identity(req.args[0].length === 0 ? null : req.args[0][0], callParams);
 resp.result = respResult === null ? [] : [respResult]

        }

if (req.fnName === 'noop') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    
                },
            };
            resp.retCode = ResultCodes.success;
            service.noop(callParams); resp.result = {}
        }

if (req.fnName === 'sha256_string') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    s: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.sha256_string(req.args[0], callParams)
        }

if (req.fnName === 'string_from_b58') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    b: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.string_from_b58(req.args[0], callParams)
        }

if (req.fnName === 'string_to_b58') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    s: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.string_to_b58(req.args[0], callParams)
        }

        next();
    });
}
      


export interface KademliaDef {
    merge: (target: string, left: string[], right: string[], count: number | null, callParams: CallParams<'target' | 'left' | 'right' | 'count'>) => string[];
neighborhood: (key: string, already_hashed: boolean | null, count: number | null, callParams: CallParams<'key' | 'already_hashed' | 'count'>) => string[];
}
export function registerKademlia(service: KademliaDef): void;
export function registerKademlia(serviceId: string, service: KademliaDef): void;
export function registerKademlia(peer: FluencePeer, service: KademliaDef): void;
export function registerKademlia(peer: FluencePeer, serviceId: string, service: KademliaDef): void;
       

export function registerKademlia(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } else {
        serviceId = "kad"
    }

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['merge', 'neighborhood']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service Kademlia: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'merge') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    target: req.tetraplets[0],left: req.tetraplets[1],right: req.tetraplets[2],count: req.tetraplets[3]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.merge(req.args[0], req.args[1], req.args[2], req.args[3].length === 0 ? null : req.args[3][0], callParams)
        }

if (req.fnName === 'neighborhood') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    key: req.tetraplets[0],already_hashed: req.tetraplets[1],count: req.tetraplets[2]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.neighborhood(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], callParams)
        }

        next();
    });
}
      


export interface ScriptDef {
    add: (air_script: string, interval: string | null, callParams: CallParams<'air_script' | 'interval'>) => string;
list: (callParams: CallParams<null>) => { failures: number; id: string; interval: string; owner: string; src: string; };
remove: (script_id: string, callParams: CallParams<'script_id'>) => boolean;
}
export function registerScript(service: ScriptDef): void;
export function registerScript(serviceId: string, service: ScriptDef): void;
export function registerScript(peer: FluencePeer, service: ScriptDef): void;
export function registerScript(peer: FluencePeer, serviceId: string, service: ScriptDef): void;
       

export function registerScript(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } else {
        serviceId = "script"
    }

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['add', 'list', 'remove']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service Script: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'add') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    air_script: req.tetraplets[0],interval: req.tetraplets[1]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.add(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], callParams)
        }

if (req.fnName === 'list') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.list(callParams)
        }

if (req.fnName === 'remove') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    script_id: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.remove(req.args[0], callParams)
        }

        next();
    });
}
      


export interface DistDef {
    add_blueprint: (blueprint: { dependencies: string[]; name: string; }, callParams: CallParams<'blueprint'>) => string;
add_module: (wasm_b56_content: number[], conf: { name: string; }, callParams: CallParams<'wasm_b56_content' | 'conf'>) => string;
get_interface: (module_id: string, callParams: CallParams<'module_id'>) => { function_signatures: { arguments: string[][]; name: string; output_types: string[]; }[]; record_types: { fields: string[][]; id: number; name: string; }[]; };
list_blueprints: (callParams: CallParams<null>) => { dependencies: string[]; id: string; name: string; }[];
list_modules: (callParams: CallParams<null>) => { config: { name: string; }; hash: string; name: string; }[];
make_blueprint: (name: string, dependencies: string[], callParams: CallParams<'name' | 'dependencies'>) => { dependencies: string[]; name: string; };
make_module_config: (name: string, mem_pages_count: number | null, logger_enabled: boolean | null, preopened_files: string[] | null, envs: string[][] | null, mapped_dirs: string[][] | null, mounted_binaries: string[][] | null, logging_mask: number | null, callParams: CallParams<'name' | 'mem_pages_count' | 'logger_enabled' | 'preopened_files' | 'envs' | 'mapped_dirs' | 'mounted_binaries' | 'logging_mask'>) => { name: string; };
}
export function registerDist(service: DistDef): void;
export function registerDist(serviceId: string, service: DistDef): void;
export function registerDist(peer: FluencePeer, service: DistDef): void;
export function registerDist(peer: FluencePeer, serviceId: string, service: DistDef): void;
       

export function registerDist(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } else {
        serviceId = "dist"
    }

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['add_blueprint', 'add_module', 'get_interface', 'list_blueprints', 'list_modules', 'make_blueprint', 'make_module_config']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service Dist: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'add_blueprint') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    blueprint: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.add_blueprint(req.args[0], callParams)
        }

if (req.fnName === 'add_module') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    wasm_b56_content: req.tetraplets[0],conf: req.tetraplets[1]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.add_module(req.args[0], req.args[1], callParams)
        }

if (req.fnName === 'get_interface') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    module_id: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.get_interface(req.args[0], callParams)
        }

if (req.fnName === 'list_blueprints') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.list_blueprints(callParams)
        }

if (req.fnName === 'list_modules') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.list_modules(callParams)
        }

if (req.fnName === 'make_blueprint') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    name: req.tetraplets[0],dependencies: req.tetraplets[1]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.make_blueprint(req.args[0], req.args[1], callParams)
        }

if (req.fnName === 'make_module_config') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    name: req.tetraplets[0],mem_pages_count: req.tetraplets[1],logger_enabled: req.tetraplets[2],preopened_files: req.tetraplets[3],envs: req.tetraplets[4],mapped_dirs: req.tetraplets[5],mounted_binaries: req.tetraplets[6],logging_mask: req.tetraplets[7]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.make_module_config(req.args[0], req.args[1].length === 0 ? null : req.args[1][0], req.args[2].length === 0 ? null : req.args[2][0], req.args[3].length === 0 ? null : req.args[3][0], req.args[4].length === 0 ? null : req.args[4][0], req.args[5].length === 0 ? null : req.args[5][0], req.args[6].length === 0 ? null : req.args[6][0], req.args[7].length === 0 ? null : req.args[7][0], callParams)
        }

        next();
    });
}
      
// Functions

